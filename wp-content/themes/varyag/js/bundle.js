/******/ (function(modules) { // webpackBootstrap
    /******/ 	// The module cache
    /******/ 	var installedModules = {};
    /******/
    /******/ 	// The require function
    /******/ 	function __webpack_require__(moduleId) {
        /******/
        /******/ 		// Check if module is in cache
        /******/ 		if(installedModules[moduleId]) {
            /******/ 			return installedModules[moduleId].exports;
            /******/ 		}
        /******/ 		// Create a new module (and put it into the cache)
        /******/ 		var module = installedModules[moduleId] = {
            /******/ 			i: moduleId,
            /******/ 			l: false,
            /******/ 			exports: {}
            /******/ 		};
        /******/
        /******/ 		// Execute the module function
        /******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        /******/
        /******/ 		// Flag the module as loaded
        /******/ 		module.l = true;
        /******/
        /******/ 		// Return the exports of the module
        /******/ 		return module.exports;
        /******/ 	}
    /******/
    /******/
    /******/ 	// expose the modules object (__webpack_modules__)
    /******/ 	__webpack_require__.m = modules;
    /******/
    /******/ 	// expose the module cache
    /******/ 	__webpack_require__.c = installedModules;
    /******/
    /******/ 	// define getter function for harmony exports
    /******/ 	__webpack_require__.d = function(exports, name, getter) {
        /******/ 		if(!__webpack_require__.o(exports, name)) {
            /******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
            /******/ 		}
        /******/ 	};
    /******/
    /******/ 	// define __esModule on exports
    /******/ 	__webpack_require__.r = function(exports) {
        /******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
            /******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
            /******/ 		}
        /******/ 		Object.defineProperty(exports, '__esModule', { value: true });
        /******/ 	};
    /******/
    /******/ 	// create a fake namespace object
    /******/ 	// mode & 1: value is a module id, require it
    /******/ 	// mode & 2: merge all properties of value into the ns
    /******/ 	// mode & 4: return value when already ns object
    /******/ 	// mode & 8|1: behave like require
    /******/ 	__webpack_require__.t = function(value, mode) {
        /******/ 		if(mode & 1) value = __webpack_require__(value);
        /******/ 		if(mode & 8) return value;
        /******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
        /******/ 		var ns = Object.create(null);
        /******/ 		__webpack_require__.r(ns);
        /******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
        /******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
        /******/ 		return ns;
        /******/ 	};
    /******/
    /******/ 	// getDefaultExport function for compatibility with non-harmony modules
    /******/ 	__webpack_require__.n = function(module) {
        /******/ 		var getter = module && module.__esModule ?
            /******/ 			function getDefault() { return module['default']; } :
            /******/ 			function getModuleExports() { return module; };
        /******/ 		__webpack_require__.d(getter, 'a', getter);
        /******/ 		return getter;
        /******/ 	};
    /******/
    /******/ 	// Object.prototype.hasOwnProperty.call
    /******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
    /******/
    /******/ 	// __webpack_public_path__
    /******/ 	__webpack_require__.p = "";
    /******/
    /******/
    /******/ 	// Load entry module and return exports
    /******/ 	return __webpack_require__(__webpack_require__.s = 0);
    /******/ })
    /************************************************************************/
    /******/ ({

        /***/ "./node_modules/inputmask/dist/inputmask.js":
        /*!**************************************************!*\
  !*** ./node_modules/inputmask/dist/inputmask.js ***!
  \**************************************************/
        /*! no static exports found */
        /***/ (function(module, exports, __webpack_require__) {

            /*!
 * dist/inputmask
 * https://github.com/RobinHerbots/Inputmask
 * Copyright (c) 2010 - 2021 Robin Herbots
 * Licensed under the MIT license
 * Version: 5.0.7
 */
            !function(e, t) {
                if (true) module.exports = t(); else { var a, i; }
            }(self, (function() {
                return function() {
                    "use strict";
                    var e = {
                        8741: function(e, t) {
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            }), t.default = void 0;
                            var i = !("undefined" == typeof window || !window.document || !window.document.createElement);
                            t.default = i;
                        },
                        3976: function(e, t, i) {
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            }), t.default = void 0;
                            var a, n = (a = i(5581)) && a.__esModule ? a : {
                                default: a
                            };
                            var r = {
                                _maxTestPos: 500,
                                placeholder: "_",
                                optionalmarker: [ "[", "]" ],
                                quantifiermarker: [ "{", "}" ],
                                groupmarker: [ "(", ")" ],
                                alternatormarker: "|",
                                escapeChar: "\\",
                                mask: null,
                                regex: null,
                                oncomplete: function() {},
                                onincomplete: function() {},
                                oncleared: function() {},
                                repeat: 0,
                                greedy: !1,
                                autoUnmask: !1,
                                removeMaskOnSubmit: !1,
                                clearMaskOnLostFocus: !0,
                                insertMode: !0,
                                insertModeVisual: !0,
                                clearIncomplete: !1,
                                alias: null,
                                onKeyDown: function() {},
                                onBeforeMask: null,
                                onBeforePaste: function(e, t) {
                                    return "function" == typeof t.onBeforeMask ? t.onBeforeMask.call(this, e, t) : e;
                                },
                                onBeforeWrite: null,
                                onUnMask: null,
                                showMaskOnFocus: !0,
                                showMaskOnHover: !0,
                                onKeyValidation: function() {},
                                skipOptionalPartCharacter: " ",
                                numericInput: !1,
                                rightAlign: !1,
                                undoOnEscape: !0,
                                radixPoint: "",
                                _radixDance: !1,
                                groupSeparator: "",
                                keepStatic: null,
                                positionCaretOnTab: !0,
                                tabThrough: !1,
                                supportsInputType: [ "text", "tel", "url", "password", "search" ],
                                ignorables: [ n.default.BACKSPACE, n.default.TAB, n.default["PAUSE/BREAK"], n.default.ESCAPE, n.default.PAGE_UP, n.default.PAGE_DOWN, n.default.END, n.default.HOME, n.default.LEFT, n.default.UP, n.default.RIGHT, n.default.DOWN, n.default.INSERT, n.default.DELETE, 93, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 0, 229 ],
                                isComplete: null,
                                preValidation: null,
                                postValidation: null,
                                staticDefinitionSymbol: void 0,
                                jitMasking: !1,
                                nullable: !0,
                                inputEventOnly: !1,
                                noValuePatching: !1,
                                positionCaretOnClick: "lvp",
                                casing: null,
                                inputmode: "text",
                                importDataAttributes: !0,
                                shiftPositions: !0,
                                usePrototypeDefinitions: !0,
                                validationEventTimeOut: 3e3,
                                substitutes: {}
                            };
                            t.default = r;
                        },
                        7392: function(e, t) {
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            }), t.default = void 0;
                            t.default = {
                                9: {
                                    validator: "[0-9\uff10-\uff19]",
                                    definitionSymbol: "*"
                                },
                                a: {
                                    validator: "[A-Za-z\u0410-\u044f\u0401\u0451\xc0-\xff\xb5]",
                                    definitionSymbol: "*"
                                },
                                "*": {
                                    validator: "[0-9\uff10-\uff19A-Za-z\u0410-\u044f\u0401\u0451\xc0-\xff\xb5]"
                                }
                            };
                        },
                        253: function(e, t) {
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            }), t.default = function(e, t, i) {
                                if (void 0 === i) return e.__data ? e.__data[t] : null;
                                e.__data = e.__data || {}, e.__data[t] = i;
                            };
                        },
                        3776: function(e, t, i) {
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            }), t.Event = void 0, t.off = function(e, t) {
                                var i, a;
                                function n(e, t, n) {
                                    if (e in i == !0) if (a.removeEventListener ? a.removeEventListener(e, n, !1) : a.detachEvent && a.detachEvent("on" + e, n),
                                    "global" === t) for (var r in i[e]) i[e][r].splice(i[e][r].indexOf(n), 1); else i[e][t].splice(i[e][t].indexOf(n), 1);
                                }
                                function r(e, a) {
                                    var n, r, o = [];
                                    if (e.length > 0) if (void 0 === t) for (n = 0, r = i[e][a].length; n < r; n++) o.push({
                                        ev: e,
                                        namespace: a && a.length > 0 ? a : "global",
                                        handler: i[e][a][n]
                                    }); else o.push({
                                        ev: e,
                                        namespace: a && a.length > 0 ? a : "global",
                                        handler: t
                                    }); else if (a.length > 0) for (var l in i) for (var s in i[l]) if (s === a) if (void 0 === t) for (n = 0,
                                                                                                                                            r = i[l][s].length; n < r; n++) o.push({
                                        ev: l,
                                        namespace: s,
                                        handler: i[l][s][n]
                                    }); else o.push({
                                        ev: l,
                                        namespace: s,
                                        handler: t
                                    });
                                    return o;
                                }
                                if (u(this[0]) && e) {
                                    i = this[0].eventRegistry, a = this[0];
                                    for (var o = e.split(" "), l = 0; l < o.length; l++) for (var s = o[l].split("."), c = r(s[0], s[1]), f = 0, d = c.length; f < d; f++) n(c[f].ev, c[f].namespace, c[f].handler);
                                }
                                return this;
                            }, t.on = function(e, t) {
                                function i(e, i) {
                                    n.addEventListener ? n.addEventListener(e, t, !1) : n.attachEvent && n.attachEvent("on" + e, t),
                                        a[e] = a[e] || {}, a[e][i] = a[e][i] || [], a[e][i].push(t);
                                }
                                if (u(this[0])) for (var a = this[0].eventRegistry, n = this[0], r = e.split(" "), o = 0; o < r.length; o++) {
                                    var l = r[o].split("."), s = l[0], c = l[1] || "global";
                                    i(s, c);
                                }
                                return this;
                            }, t.trigger = function(e) {
                                if (u(this[0])) for (var t = this[0].eventRegistry, i = this[0], a = "string" == typeof e ? e.split(" ") : [ e.type ], r = 0; r < a.length; r++) {
                                    var l = a[r].split("."), s = l[0], c = l[1] || "global";
                                    if (void 0 !== document && "global" === c) {
                                        var f, d, p = {
                                            bubbles: !0,
                                            cancelable: !0,
                                            detail: arguments[1]
                                        };
                                        if (document.createEvent) {
                                            try {
                                                if ("input" === s) p.inputType = "insertText", f = new InputEvent(s, p); else f = new CustomEvent(s, p);
                                            } catch (e) {
                                                (f = document.createEvent("CustomEvent")).initCustomEvent(s, p.bubbles, p.cancelable, p.detail);
                                            }
                                            e.type && (0, n.default)(f, e), i.dispatchEvent(f);
                                        } else (f = document.createEventObject()).eventType = s, f.detail = arguments[1],
                                        e.type && (0, n.default)(f, e), i.fireEvent("on" + f.eventType, f);
                                    } else if (void 0 !== t[s]) if (arguments[0] = arguments[0].type ? arguments[0] : o.default.Event(arguments[0]),
                                        arguments[0].detail = arguments.slice(1), "global" === c) for (var h in t[s]) for (d = 0; d < t[s][h].length; d++) t[s][h][d].apply(i, arguments); else for (d = 0; d < t[s][c].length; d++) t[s][c][d].apply(i, arguments);
                                }
                                return this;
                            };
                            var a, n = s(i(600)), r = s(i(9380)), o = s(i(4963)), l = s(i(8741));
                            function s(e) {
                                return e && e.__esModule ? e : {
                                    default: e
                                };
                            }
                            function u(e) {
                                return e instanceof Element;
                            }
                            t.Event = a, "function" == typeof r.default.CustomEvent ? t.Event = a = r.default.CustomEvent : l.default && (t.Event = a = function(e, t) {
                                t = t || {
                                    bubbles: !1,
                                    cancelable: !1,
                                    detail: void 0
                                };
                                var i = document.createEvent("CustomEvent");
                                return i.initCustomEvent(e, t.bubbles, t.cancelable, t.detail), i;
                            }, a.prototype = r.default.Event.prototype);
                        },
                        600: function(e, t) {
                            function i(e) {
                                return i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                                    return typeof e;
                                } : function(e) {
                                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
                                }, i(e);
                            }
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            }), t.default = function e() {
                                var t, a, n, r, o, l, s = arguments[0] || {}, u = 1, c = arguments.length, f = !1;
                                "boolean" == typeof s && (f = s, s = arguments[u] || {}, u++);
                                "object" !== i(s) && "function" != typeof s && (s = {});
                                for (;u < c; u++) if (null != (t = arguments[u])) for (a in t) n = s[a], r = t[a],
                                s !== r && (f && r && ("[object Object]" === Object.prototype.toString.call(r) || (o = Array.isArray(r))) ? (o ? (o = !1,
                                    l = n && Array.isArray(n) ? n : []) : l = n && "[object Object]" === Object.prototype.toString.call(n) ? n : {},
                                    s[a] = e(f, l, r)) : void 0 !== r && (s[a] = r));
                                return s;
                            };
                        },
                        4963: function(e, t, i) {
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            }), t.default = void 0;
                            var a = l(i(600)), n = l(i(9380)), r = l(i(253)), o = i(3776);
                            function l(e) {
                                return e && e.__esModule ? e : {
                                    default: e
                                };
                            }
                            var s = n.default.document;
                            function u(e) {
                                return e instanceof u ? e : this instanceof u ? void (null != e && e !== n.default && (this[0] = e.nodeName ? e : void 0 !== e[0] && e[0].nodeName ? e[0] : s.querySelector(e),
                                void 0 !== this[0] && null !== this[0] && (this[0].eventRegistry = this[0].eventRegistry || {}))) : new u(e);
                            }
                            u.prototype = {
                                on: o.on,
                                off: o.off,
                                trigger: o.trigger
                            }, u.extend = a.default, u.data = r.default, u.Event = o.Event;
                            var c = u;
                            t.default = c;
                        },
                        9845: function(e, t, i) {
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            }), t.ua = t.mobile = t.iphone = t.iemobile = t.ie = void 0;
                            var a, n = (a = i(9380)) && a.__esModule ? a : {
                                default: a
                            };
                            var r = n.default.navigator && n.default.navigator.userAgent || "", o = r.indexOf("MSIE ") > 0 || r.indexOf("Trident/") > 0, l = "ontouchstart" in n.default, s = /iemobile/i.test(r), u = /iphone/i.test(r) && !s;
                            t.iphone = u, t.iemobile = s, t.mobile = l, t.ie = o, t.ua = r;
                        },
                        7184: function(e, t) {
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            }), t.default = function(e) {
                                return e.replace(i, "\\$1");
                            };
                            var i = new RegExp("(\\" + [ "/", ".", "*", "+", "?", "|", "(", ")", "[", "]", "{", "}", "\\", "$", "^" ].join("|\\") + ")", "gim");
                        },
                        6030: function(e, t, i) {
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            }), t.EventHandlers = void 0;
                            var a, n = i(8711), r = (a = i(5581)) && a.__esModule ? a : {
                                default: a
                            }, o = i(9845), l = i(7215), s = i(7760), u = i(4713);
                            function c(e, t) {
                                var i = "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
                                if (!i) {
                                    if (Array.isArray(e) || (i = function(e, t) {
                                        if (!e) return;
                                        if ("string" == typeof e) return f(e, t);
                                        var i = Object.prototype.toString.call(e).slice(8, -1);
                                        "Object" === i && e.constructor && (i = e.constructor.name);
                                        if ("Map" === i || "Set" === i) return Array.from(e);
                                        if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)) return f(e, t);
                                    }(e)) || t && e && "number" == typeof e.length) {
                                        i && (e = i);
                                        var a = 0, n = function() {};
                                        return {
                                            s: n,
                                            n: function() {
                                                return a >= e.length ? {
                                                    done: !0
                                                } : {
                                                    done: !1,
                                                    value: e[a++]
                                                };
                                            },
                                            e: function(e) {
                                                throw e;
                                            },
                                            f: n
                                        };
                                    }
                                    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                                }
                                var r, o = !0, l = !1;
                                return {
                                    s: function() {
                                        i = i.call(e);
                                    },
                                    n: function() {
                                        var e = i.next();
                                        return o = e.done, e;
                                    },
                                    e: function(e) {
                                        l = !0, r = e;
                                    },
                                    f: function() {
                                        try {
                                            o || null == i.return || i.return();
                                        } finally {
                                            if (l) throw r;
                                        }
                                    }
                                };
                            }
                            function f(e, t) {
                                (null == t || t > e.length) && (t = e.length);
                                for (var i = 0, a = new Array(t); i < t; i++) a[i] = e[i];
                                return a;
                            }
                            var d = {
                                keydownEvent: function(e) {
                                    var t = this.inputmask, i = t.opts, a = t.dependencyLib, c = t.maskset, f = this, d = a(f), p = e.keyCode, h = n.caret.call(t, f), v = i.onKeyDown.call(this, e, n.getBuffer.call(t), h, i);
                                    if (void 0 !== v) return v;
                                    if (p === r.default.BACKSPACE || p === r.default.DELETE || o.iphone && p === r.default.BACKSPACE_SAFARI || e.ctrlKey && p === r.default.X && !("oncut" in f)) e.preventDefault(),
                                        l.handleRemove.call(t, f, p, h), (0, s.writeBuffer)(f, n.getBuffer.call(t, !0), c.p, e, f.inputmask._valueGet() !== n.getBuffer.call(t).join("")); else if (p === r.default.END || p === r.default.PAGE_DOWN) {
                                        e.preventDefault();
                                        var m = n.seekNext.call(t, n.getLastValidPosition.call(t));
                                        n.caret.call(t, f, e.shiftKey ? h.begin : m, m, !0);
                                    } else p === r.default.HOME && !e.shiftKey || p === r.default.PAGE_UP ? (e.preventDefault(),
                                        n.caret.call(t, f, 0, e.shiftKey ? h.begin : 0, !0)) : i.undoOnEscape && p === r.default.ESCAPE && !0 !== e.altKey ? ((0,
                                        s.checkVal)(f, !0, !1, t.undoValue.split("")), d.trigger("click")) : p !== r.default.INSERT || e.shiftKey || e.ctrlKey || void 0 !== t.userOptions.insertMode ? !0 === i.tabThrough && p === r.default.TAB ? !0 === e.shiftKey ? (h.end = n.seekPrevious.call(t, h.end, !0),
                                    !0 === u.getTest.call(t, h.end - 1).match.static && h.end--, h.begin = n.seekPrevious.call(t, h.end, !0),
                                    h.begin >= 0 && h.end > 0 && (e.preventDefault(), n.caret.call(t, f, h.begin, h.end))) : (h.begin = n.seekNext.call(t, h.begin, !0),
                                        h.end = n.seekNext.call(t, h.begin, !0), h.end < c.maskLength && h.end--, h.begin <= c.maskLength && (e.preventDefault(),
                                        n.caret.call(t, f, h.begin, h.end))) : e.shiftKey || i.insertModeVisual && !1 === i.insertMode && (p === r.default.RIGHT ? setTimeout((function() {
                                        var e = n.caret.call(t, f);
                                        n.caret.call(t, f, e.begin);
                                    }), 0) : p === r.default.LEFT && setTimeout((function() {
                                        var e = n.translatePosition.call(t, f.inputmask.caretPos.begin);
                                        n.translatePosition.call(t, f.inputmask.caretPos.end);
                                        t.isRTL ? n.caret.call(t, f, e + (e === c.maskLength ? 0 : 1)) : n.caret.call(t, f, e - (0 === e ? 0 : 1));
                                    }), 0)) : l.isSelection.call(t, h) ? i.insertMode = !i.insertMode : (i.insertMode = !i.insertMode,
                                        n.caret.call(t, f, h.begin, h.begin));
                                    t.ignorable = i.ignorables.includes(p);
                                },
                                keypressEvent: function(e, t, i, a, o) {
                                    var u = this.inputmask || this, c = u.opts, f = u.dependencyLib, d = u.maskset, p = u.el, h = f(p), v = e.keyCode;
                                    if (!(!0 === t || e.ctrlKey && e.altKey) && (e.ctrlKey || e.metaKey || u.ignorable)) return v === r.default.ENTER && u.undoValue !== u._valueGet(!0) && (u.undoValue = u._valueGet(!0),
                                        setTimeout((function() {
                                            h.trigger("change");
                                        }), 0)), u.skipInputEvent = !0, !0;
                                    if (v) {
                                        44 !== v && 46 !== v || 3 !== e.location || "" === c.radixPoint || (v = c.radixPoint.charCodeAt(0));
                                        var m, g = t ? {
                                            begin: o,
                                            end: o
                                        } : n.caret.call(u, p), k = String.fromCharCode(v);
                                        k = c.substitutes[k] || k, d.writeOutBuffer = !0;
                                        var y = l.isValid.call(u, g, k, a, void 0, void 0, void 0, t);
                                        if (!1 !== y && (n.resetMaskSet.call(u, !0), m = void 0 !== y.caret ? y.caret : n.seekNext.call(u, y.pos.begin ? y.pos.begin : y.pos),
                                            d.p = m), m = c.numericInput && void 0 === y.caret ? n.seekPrevious.call(u, m) : m,
                                        !1 !== i && (setTimeout((function() {
                                            c.onKeyValidation.call(p, v, y);
                                        }), 0), d.writeOutBuffer && !1 !== y)) {
                                            var b = n.getBuffer.call(u);
                                            (0, s.writeBuffer)(p, b, m, e, !0 !== t);
                                        }
                                        if (e.preventDefault(), t) return !1 !== y && (y.forwardPosition = m), y;
                                    }
                                },
                                keyupEvent: function(e) {
                                    var t = this.inputmask;
                                    !t.isComposing || e.keyCode !== r.default.KEY_229 && e.keyCode !== r.default.ENTER || t.$el.trigger("input");
                                },
                                pasteEvent: function(e) {
                                    var t, i = this.inputmask, a = i.opts, r = i._valueGet(!0), o = n.caret.call(i, this);
                                    i.isRTL && (t = o.end, o.end = n.translatePosition.call(i, o.begin), o.begin = n.translatePosition.call(i, t));
                                    var l = r.substr(0, o.begin), u = r.substr(o.end, r.length);
                                    if (l == (i.isRTL ? n.getBufferTemplate.call(i).slice().reverse() : n.getBufferTemplate.call(i)).slice(0, o.begin).join("") && (l = ""),
                                    u == (i.isRTL ? n.getBufferTemplate.call(i).slice().reverse() : n.getBufferTemplate.call(i)).slice(o.end).join("") && (u = ""),
                                    window.clipboardData && window.clipboardData.getData) r = l + window.clipboardData.getData("Text") + u; else {
                                        if (!e.clipboardData || !e.clipboardData.getData) return !0;
                                        r = l + e.clipboardData.getData("text/plain") + u;
                                    }
                                    var f = r;
                                    if (i.isRTL) {
                                        f = f.split("");
                                        var d, p = c(n.getBufferTemplate.call(i));
                                        try {
                                            for (p.s(); !(d = p.n()).done; ) {
                                                var h = d.value;
                                                f[0] === h && f.shift();
                                            }
                                        } catch (e) {
                                            p.e(e);
                                        } finally {
                                            p.f();
                                        }
                                        f = f.join("");
                                    }
                                    if ("function" == typeof a.onBeforePaste) {
                                        if (!1 === (f = a.onBeforePaste.call(i, f, a))) return !1;
                                        f || (f = r);
                                    }
                                    (0, s.checkVal)(this, !0, !1, f.toString().split(""), e), e.preventDefault();
                                },
                                inputFallBackEvent: function(e) {
                                    var t = this.inputmask, i = t.opts, a = t.dependencyLib;
                                    var l = this, c = l.inputmask._valueGet(!0), f = (t.isRTL ? n.getBuffer.call(t).slice().reverse() : n.getBuffer.call(t)).join(""), p = n.caret.call(t, l, void 0, void 0, !0);
                                    if (f !== c) {
                                        c = function(e, i, a) {
                                            if (o.iemobile) {
                                                var r = i.replace(n.getBuffer.call(t).join(""), "");
                                                if (1 === r.length) {
                                                    var l = i.split("");
                                                    l.splice(a.begin, 0, r), i = l.join("");
                                                }
                                            }
                                            return i;
                                        }(0, c, p);
                                        var h = function(e, a, r) {
                                            for (var o, l, s, c = e.substr(0, r.begin).split(""), f = e.substr(r.begin).split(""), d = a.substr(0, r.begin).split(""), p = a.substr(r.begin).split(""), h = c.length >= d.length ? c.length : d.length, v = f.length >= p.length ? f.length : p.length, m = "", g = [], k = "~"; c.length < h; ) c.push(k);
                                            for (;d.length < h; ) d.push(k);
                                            for (;f.length < v; ) f.unshift(k);
                                            for (;p.length < v; ) p.unshift(k);
                                            var y = c.concat(f), b = d.concat(p);
                                            for (l = 0, o = y.length; l < o; l++) switch (s = u.getPlaceholder.call(t, n.translatePosition.call(t, l)),
                                                m) {
                                                case "insertText":
                                                    b[l - 1] === y[l] && r.begin == y.length - 1 && g.push(y[l]), l = o;
                                                    break;

                                                case "insertReplacementText":
                                                case "deleteContentBackward":
                                                    y[l] === k ? r.end++ : l = o;
                                                    break;

                                                default:
                                                    y[l] !== b[l] && (y[l + 1] !== k && y[l + 1] !== s && void 0 !== y[l + 1] || (b[l] !== s || b[l + 1] !== k) && b[l] !== k ? b[l + 1] === k && b[l] === y[l + 1] ? (m = "insertText",
                                                        g.push(y[l]), r.begin--, r.end--) : y[l] !== s && y[l] !== k && (y[l + 1] === k || b[l] !== y[l] && b[l + 1] === y[l + 1]) ? (m = "insertReplacementText",
                                                        g.push(y[l]), r.begin--) : y[l] === k ? (m = "deleteContentBackward", (n.isMask.call(t, n.translatePosition.call(t, l), !0) || b[l] === i.radixPoint) && r.end++) : l = o : (m = "insertText",
                                                        g.push(y[l]), r.begin--, r.end--));
                                            }
                                            return {
                                                action: m,
                                                data: g,
                                                caret: r
                                            };
                                        }(c, f, p);
                                        switch ((l.inputmask.shadowRoot || l.ownerDocument).activeElement !== l && l.focus(),
                                            (0, s.writeBuffer)(l, n.getBuffer.call(t)), n.caret.call(t, l, p.begin, p.end, !0),
                                            h.action) {
                                            case "insertText":
                                            case "insertReplacementText":
                                                h.data.forEach((function(e, i) {
                                                    var n = new a.Event("keypress");
                                                    n.keyCode = e.charCodeAt(0), t.ignorable = !1, d.keypressEvent.call(l, n);
                                                })), setTimeout((function() {
                                                    t.$el.trigger("keyup");
                                                }), 0);
                                                break;

                                            case "deleteContentBackward":
                                                var v = new a.Event("keydown");
                                                v.keyCode = r.default.BACKSPACE, d.keydownEvent.call(l, v);
                                                break;

                                            default:
                                                (0, s.applyInputValue)(l, c);
                                        }
                                        e.preventDefault();
                                    }
                                },
                                compositionendEvent: function(e) {
                                    var t = this.inputmask;
                                    t.isComposing = !1, t.$el.trigger("input");
                                },
                                setValueEvent: function(e) {
                                    var t = this.inputmask, i = this, a = e && e.detail ? e.detail[0] : arguments[1];
                                    void 0 === a && (a = i.inputmask._valueGet(!0)), (0, s.applyInputValue)(i, a), (e.detail && void 0 !== e.detail[1] || void 0 !== arguments[2]) && n.caret.call(t, i, e.detail ? e.detail[1] : arguments[2]);
                                },
                                focusEvent: function(e) {
                                    var t = this.inputmask, i = t.opts, a = this, r = a.inputmask._valueGet();
                                    i.showMaskOnFocus && r !== n.getBuffer.call(t).join("") && (0, s.writeBuffer)(a, n.getBuffer.call(t), n.seekNext.call(t, n.getLastValidPosition.call(t))),
                                    !0 !== i.positionCaretOnTab || !1 !== t.mouseEnter || l.isComplete.call(t, n.getBuffer.call(t)) && -1 !== n.getLastValidPosition.call(t) || d.clickEvent.apply(a, [ e, !0 ]),
                                        t.undoValue = t._valueGet(!0);
                                },
                                invalidEvent: function(e) {
                                    this.inputmask.validationEvent = !0;
                                },
                                mouseleaveEvent: function() {
                                    var e = this.inputmask, t = e.opts, i = this;
                                    e.mouseEnter = !1, t.clearMaskOnLostFocus && (i.inputmask.shadowRoot || i.ownerDocument).activeElement !== i && (0,
                                        s.HandleNativePlaceholder)(i, e.originalPlaceholder);
                                },
                                clickEvent: function(e, t) {
                                    var i = this.inputmask, a = this;
                                    if ((a.inputmask.shadowRoot || a.ownerDocument).activeElement === a) {
                                        var r = n.determineNewCaretPosition.call(i, n.caret.call(i, a), t);
                                        void 0 !== r && n.caret.call(i, a, r);
                                    }
                                },
                                cutEvent: function(e) {
                                    var t = this.inputmask, i = t.maskset, a = this, o = n.caret.call(t, a), u = t.isRTL ? n.getBuffer.call(t).slice(o.end, o.begin) : n.getBuffer.call(t).slice(o.begin, o.end), c = t.isRTL ? u.reverse().join("") : u.join("");
                                    window.navigator.clipboard ? window.navigator.clipboard.writeText(c) : window.clipboardData && window.clipboardData.getData && window.clipboardData.setData("Text", c),
                                        l.handleRemove.call(t, a, r.default.DELETE, o), (0, s.writeBuffer)(a, n.getBuffer.call(t), i.p, e, t.undoValue !== t._valueGet(!0));
                                },
                                blurEvent: function(e) {
                                    var t = this.inputmask, i = t.opts, a = (0, t.dependencyLib)(this), r = this;
                                    if (r.inputmask) {
                                        (0, s.HandleNativePlaceholder)(r, t.originalPlaceholder);
                                        var o = r.inputmask._valueGet(), u = n.getBuffer.call(t).slice();
                                        "" !== o && (i.clearMaskOnLostFocus && (-1 === n.getLastValidPosition.call(t) && o === n.getBufferTemplate.call(t).join("") ? u = [] : s.clearOptionalTail.call(t, u)),
                                        !1 === l.isComplete.call(t, u) && (setTimeout((function() {
                                            a.trigger("incomplete");
                                        }), 0), i.clearIncomplete && (n.resetMaskSet.call(t), u = i.clearMaskOnLostFocus ? [] : n.getBufferTemplate.call(t).slice())),
                                            (0, s.writeBuffer)(r, u, void 0, e)), t.undoValue !== t._valueGet(!0) && (t.undoValue = t._valueGet(!0),
                                            a.trigger("change"));
                                    }
                                },
                                mouseenterEvent: function() {
                                    var e = this.inputmask, t = e.opts, i = this;
                                    if (e.mouseEnter = !0, (i.inputmask.shadowRoot || i.ownerDocument).activeElement !== i) {
                                        var a = (e.isRTL ? n.getBufferTemplate.call(e).slice().reverse() : n.getBufferTemplate.call(e)).join("");
                                        e.placeholder !== a && i.placeholder !== e.originalPlaceholder && (e.originalPlaceholder = i.placeholder),
                                        t.showMaskOnHover && (0, s.HandleNativePlaceholder)(i, a);
                                    }
                                },
                                submitEvent: function() {
                                    var e = this.inputmask, t = e.opts;
                                    e.undoValue !== e._valueGet(!0) && e.$el.trigger("change"), -1 === n.getLastValidPosition.call(e) && e._valueGet && e._valueGet() === n.getBufferTemplate.call(e).join("") && e._valueSet(""),
                                    t.clearIncomplete && !1 === l.isComplete.call(e, n.getBuffer.call(e)) && e._valueSet(""),
                                    t.removeMaskOnSubmit && (e._valueSet(e.unmaskedvalue(), !0), setTimeout((function() {
                                        (0, s.writeBuffer)(e.el, n.getBuffer.call(e));
                                    }), 0));
                                },
                                resetEvent: function() {
                                    var e = this.inputmask;
                                    e.refreshValue = !0, setTimeout((function() {
                                        (0, s.applyInputValue)(e.el, e._valueGet(!0));
                                    }), 0);
                                }
                            };
                            t.EventHandlers = d;
                        },
                        9716: function(e, t, i) {
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            }), t.EventRuler = void 0;
                            var a = l(i(2394)), n = l(i(5581)), r = i(8711), o = i(7760);
                            function l(e) {
                                return e && e.__esModule ? e : {
                                    default: e
                                };
                            }
                            var s = {
                                on: function(e, t, i) {
                                    var l = e.inputmask.dependencyLib, s = function(t) {
                                        t.originalEvent && (t = t.originalEvent || t, arguments[0] = t);
                                        var s, u = this, c = u.inputmask, f = c ? c.opts : void 0;
                                        if (void 0 === c && "FORM" !== this.nodeName) {
                                            var d = l.data(u, "_inputmask_opts");
                                            l(u).off(), d && new a.default(d).mask(u);
                                        } else {
                                            if ([ "submit", "reset", "setvalue" ].includes(t.type) || "FORM" === this.nodeName || !(u.disabled || u.readOnly && !("keydown" === t.type && t.ctrlKey && 67 === t.keyCode || !1 === f.tabThrough && t.keyCode === n.default.TAB))) {
                                                switch (t.type) {
                                                    case "input":
                                                        if (!0 === c.skipInputEvent || t.inputType && "insertCompositionText" === t.inputType) return c.skipInputEvent = !1,
                                                            t.preventDefault();
                                                        break;

                                                    case "keydown":
                                                        c.skipKeyPressEvent = !1, c.skipInputEvent = c.isComposing = t.keyCode === n.default.KEY_229;
                                                        break;

                                                    case "keyup":
                                                    case "compositionend":
                                                        c.isComposing && (c.skipInputEvent = !1);
                                                        break;

                                                    case "keypress":
                                                        if (!0 === c.skipKeyPressEvent) return t.preventDefault();
                                                        c.skipKeyPressEvent = !0;
                                                        break;

                                                    case "click":
                                                    case "focus":
                                                        return c.validationEvent ? (c.validationEvent = !1, e.blur(), (0, o.HandleNativePlaceholder)(e, (c.isRTL ? r.getBufferTemplate.call(c).slice().reverse() : r.getBufferTemplate.call(c)).join("")),
                                                            setTimeout((function() {
                                                                e.focus();
                                                            }), f.validationEventTimeOut), !1) : (s = arguments, setTimeout((function() {
                                                            e.inputmask && i.apply(u, s);
                                                        }), 0), !1);
                                                }
                                                var p = i.apply(u, arguments);
                                                return !1 === p && (t.preventDefault(), t.stopPropagation()), p;
                                            }
                                            t.preventDefault();
                                        }
                                    };
                                    [ "submit", "reset" ].includes(t) ? (s = s.bind(e), null !== e.form && l(e.form).on(t, s)) : l(e).on(t, s),
                                        e.inputmask.events[t] = e.inputmask.events[t] || [], e.inputmask.events[t].push(s);
                                },
                                off: function(e, t) {
                                    if (e.inputmask && e.inputmask.events) {
                                        var i = e.inputmask.dependencyLib, a = e.inputmask.events;
                                        for (var n in t && ((a = [])[t] = e.inputmask.events[t]), a) {
                                            for (var r = a[n]; r.length > 0; ) {
                                                var o = r.pop();
                                                [ "submit", "reset" ].includes(n) ? null !== e.form && i(e.form).off(n, o) : i(e).off(n, o);
                                            }
                                            delete e.inputmask.events[n];
                                        }
                                    }
                                }
                            };
                            t.EventRuler = s;
                        },
                        219: function(e, t, i) {
                            var a = d(i(2394)), n = d(i(5581)), r = d(i(7184)), o = i(8711), l = i(4713);
                            function s(e) {
                                return s = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                                    return typeof e;
                                } : function(e) {
                                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
                                }, s(e);
                            }
                            function u(e, t) {
                                return function(e) {
                                    if (Array.isArray(e)) return e;
                                }(e) || function(e, t) {
                                    var i = null == e ? null : "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
                                    if (null == i) return;
                                    var a, n, r = [], o = !0, l = !1;
                                    try {
                                        for (i = i.call(e); !(o = (a = i.next()).done) && (r.push(a.value), !t || r.length !== t); o = !0) ;
                                    } catch (e) {
                                        l = !0, n = e;
                                    } finally {
                                        try {
                                            o || null == i.return || i.return();
                                        } finally {
                                            if (l) throw n;
                                        }
                                    }
                                    return r;
                                }(e, t) || function(e, t) {
                                    if (!e) return;
                                    if ("string" == typeof e) return c(e, t);
                                    var i = Object.prototype.toString.call(e).slice(8, -1);
                                    "Object" === i && e.constructor && (i = e.constructor.name);
                                    if ("Map" === i || "Set" === i) return Array.from(e);
                                    if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)) return c(e, t);
                                }(e, t) || function() {
                                    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                                }();
                            }
                            function c(e, t) {
                                (null == t || t > e.length) && (t = e.length);
                                for (var i = 0, a = new Array(t); i < t; i++) a[i] = e[i];
                                return a;
                            }
                            function f(e, t) {
                                for (var i = 0; i < t.length; i++) {
                                    var a = t[i];
                                    a.enumerable = a.enumerable || !1, a.configurable = !0, "value" in a && (a.writable = !0),
                                        Object.defineProperty(e, a.key, a);
                                }
                            }
                            function d(e) {
                                return e && e.__esModule ? e : {
                                    default: e
                                };
                            }
                            var p = a.default.dependencyLib, h = function() {
                                function e(t, i, a) {
                                    !function(e, t) {
                                        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
                                    }(this, e), this.mask = t, this.format = i, this.opts = a, this._date = new Date(1, 0, 1),
                                        this.initDateObject(t, this.opts);
                                }
                                var t, i, a;
                                return t = e, (i = [ {
                                    key: "date",
                                    get: function() {
                                        return void 0 === this._date && (this._date = new Date(1, 0, 1), this.initDateObject(void 0, this.opts)),
                                            this._date;
                                    }
                                }, {
                                    key: "initDateObject",
                                    value: function(e, t) {
                                        var i;
                                        for (P(t).lastIndex = 0; i = P(t).exec(this.format); ) {
                                            var a = new RegExp("\\d+$").exec(i[0]), n = a ? i[0][0] + "x" : i[0], r = void 0;
                                            if (void 0 !== e) {
                                                if (a) {
                                                    var o = P(t).lastIndex, l = O(i.index, t);
                                                    P(t).lastIndex = o, r = e.slice(0, e.indexOf(l.nextMatch[0]));
                                                } else r = e.slice(0, n.length);
                                                e = e.slice(r.length);
                                            }
                                            Object.prototype.hasOwnProperty.call(g, n) && this.setValue(this, r, n, g[n][2], g[n][1]);
                                        }
                                    }
                                }, {
                                    key: "setValue",
                                    value: function(e, t, i, a, n) {
                                        if (void 0 !== t && (e[a] = "ampm" === a ? t : t.replace(/[^0-9]/g, "0"), e["raw" + a] = t.replace(/\s/g, "_")),
                                        void 0 !== n) {
                                            var r = e[a];
                                            ("day" === a && 29 === parseInt(r) || "month" === a && 2 === parseInt(r)) && (29 !== parseInt(e.day) || 2 !== parseInt(e.month) || "" !== e.year && void 0 !== e.year || e._date.setFullYear(2012, 1, 29)),
                                            "day" === a && (m = !0, 0 === parseInt(r) && (r = 1)), "month" === a && (m = !0),
                                            "year" === a && (m = !0, r.length < 4 && (r = _(r, 4, !0))), "" === r || isNaN(r) || n.call(e._date, r),
                                            "ampm" === a && n.call(e._date, r);
                                        }
                                    }
                                }, {
                                    key: "reset",
                                    value: function() {
                                        this._date = new Date(1, 0, 1);
                                    }
                                }, {
                                    key: "reInit",
                                    value: function() {
                                        this._date = void 0, this.date;
                                    }
                                } ]) && f(t.prototype, i), a && f(t, a), Object.defineProperty(t, "prototype", {
                                    writable: !1
                                }), e;
                            }(), v = (new Date).getFullYear(), m = !1, g = {
                                d: [ "[1-9]|[12][0-9]|3[01]", Date.prototype.setDate, "day", Date.prototype.getDate ],
                                dd: [ "0[1-9]|[12][0-9]|3[01]", Date.prototype.setDate, "day", function() {
                                    return _(Date.prototype.getDate.call(this), 2);
                                } ],
                                ddd: [ "" ],
                                dddd: [ "" ],
                                m: [ "[1-9]|1[012]", function(e) {
                                    var t = e ? parseInt(e) : 0;
                                    return t > 0 && t--, Date.prototype.setMonth.call(this, t);
                                }, "month", function() {
                                    return Date.prototype.getMonth.call(this) + 1;
                                } ],
                                mm: [ "0[1-9]|1[012]", function(e) {
                                    var t = e ? parseInt(e) : 0;
                                    return t > 0 && t--, Date.prototype.setMonth.call(this, t);
                                }, "month", function() {
                                    return _(Date.prototype.getMonth.call(this) + 1, 2);
                                } ],
                                mmm: [ "" ],
                                mmmm: [ "" ],
                                yy: [ "[0-9]{2}", Date.prototype.setFullYear, "year", function() {
                                    return _(Date.prototype.getFullYear.call(this), 2);
                                } ],
                                yyyy: [ "[0-9]{4}", Date.prototype.setFullYear, "year", function() {
                                    return _(Date.prototype.getFullYear.call(this), 4);
                                } ],
                                h: [ "[1-9]|1[0-2]", Date.prototype.setHours, "hours", Date.prototype.getHours ],
                                hh: [ "0[1-9]|1[0-2]", Date.prototype.setHours, "hours", function() {
                                    return _(Date.prototype.getHours.call(this), 2);
                                } ],
                                hx: [ function(e) {
                                    return "[0-9]{".concat(e, "}");
                                }, Date.prototype.setHours, "hours", function(e) {
                                    return Date.prototype.getHours;
                                } ],
                                H: [ "1?[0-9]|2[0-3]", Date.prototype.setHours, "hours", Date.prototype.getHours ],
                                HH: [ "0[0-9]|1[0-9]|2[0-3]", Date.prototype.setHours, "hours", function() {
                                    return _(Date.prototype.getHours.call(this), 2);
                                } ],
                                Hx: [ function(e) {
                                    return "[0-9]{".concat(e, "}");
                                }, Date.prototype.setHours, "hours", function(e) {
                                    return function() {
                                        return _(Date.prototype.getHours.call(this), e);
                                    };
                                } ],
                                M: [ "[1-5]?[0-9]", Date.prototype.setMinutes, "minutes", Date.prototype.getMinutes ],
                                MM: [ "0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]", Date.prototype.setMinutes, "minutes", function() {
                                    return _(Date.prototype.getMinutes.call(this), 2);
                                } ],
                                s: [ "[1-5]?[0-9]", Date.prototype.setSeconds, "seconds", Date.prototype.getSeconds ],
                                ss: [ "0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]", Date.prototype.setSeconds, "seconds", function() {
                                    return _(Date.prototype.getSeconds.call(this), 2);
                                } ],
                                l: [ "[0-9]{3}", Date.prototype.setMilliseconds, "milliseconds", function() {
                                    return _(Date.prototype.getMilliseconds.call(this), 3);
                                } ],
                                L: [ "[0-9]{2}", Date.prototype.setMilliseconds, "milliseconds", function() {
                                    return _(Date.prototype.getMilliseconds.call(this), 2);
                                } ],
                                t: [ "[ap]", y, "ampm", b, 1 ],
                                tt: [ "[ap]m", y, "ampm", b, 2 ],
                                T: [ "[AP]", y, "ampm", b, 1 ],
                                TT: [ "[AP]M", y, "ampm", b, 2 ],
                                Z: [ ".*", void 0, "Z", function() {
                                    var e = this.toString().match(/\((.+)\)/)[1];
                                    e.includes(" ") && (e = (e = e.replace("-", " ").toUpperCase()).split(" ").map((function(e) {
                                        return u(e, 1)[0];
                                    })).join(""));
                                    return e;
                                } ],
                                o: [ "" ],
                                S: [ "" ]
                            }, k = {
                                isoDate: "yyyy-mm-dd",
                                isoTime: "HH:MM:ss",
                                isoDateTime: "yyyy-mm-dd'T'HH:MM:ss",
                                isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'"
                            };
                            function y(e) {
                                var t = this.getHours();
                                e.toLowerCase().includes("p") ? this.setHours(t + 12) : e.toLowerCase().includes("a") && t >= 12 && this.setHours(t - 12);
                            }
                            function b() {
                                var e = this.getHours();
                                return (e = e || 12) >= 12 ? "PM" : "AM";
                            }
                            function x(e) {
                                var t = new RegExp("\\d+$").exec(e[0]);
                                if (t && void 0 !== t[0]) {
                                    var i = g[e[0][0] + "x"].slice("");
                                    return i[0] = i[0](t[0]), i[3] = i[3](t[0]), i;
                                }
                                if (g[e[0]]) return g[e[0]];
                            }
                            function P(e) {
                                if (!e.tokenizer) {
                                    var t = [], i = [];
                                    for (var a in g) if (/\.*x$/.test(a)) {
                                        var n = a[0] + "\\d+";
                                        -1 === i.indexOf(n) && i.push(n);
                                    } else -1 === t.indexOf(a[0]) && t.push(a[0]);
                                    e.tokenizer = "(" + (i.length > 0 ? i.join("|") + "|" : "") + t.join("+|") + ")+?|.",
                                        e.tokenizer = new RegExp(e.tokenizer, "g");
                                }
                                return e.tokenizer;
                            }
                            function E(e, t, i) {
                                if (!m) return !0;
                                if (void 0 === e.rawday || !isFinite(e.rawday) && new Date(e.date.getFullYear(), isFinite(e.rawmonth) ? e.month : e.date.getMonth() + 1, 0).getDate() >= e.day || "29" == e.day && (!isFinite(e.rawyear) || void 0 === e.rawyear || "" === e.rawyear) || new Date(e.date.getFullYear(), isFinite(e.rawmonth) ? e.month : e.date.getMonth() + 1, 0).getDate() >= e.day) return t;
                                if ("29" == e.day) {
                                    var a = O(t.pos, i);
                                    if ("yyyy" === a.targetMatch[0] && t.pos - a.targetMatchIndex == 2) return t.remove = t.pos + 1,
                                        t;
                                } else if ("02" == e.month && "30" == e.day && void 0 !== t.c) return e.day = "03",
                                    e.date.setDate(3), e.date.setMonth(1), t.insert = [ {
                                    pos: t.pos,
                                    c: "0"
                                }, {
                                    pos: t.pos + 1,
                                    c: t.c
                                } ], t.caret = o.seekNext.call(this, t.pos + 1), t;
                                return !1;
                            }
                            function S(e, t, i, a) {
                                var n, o, l = "";
                                for (P(i).lastIndex = 0; n = P(i).exec(e); ) {
                                    if (void 0 === t) if (o = x(n)) l += "(" + o[0] + ")"; else switch (n[0]) {
                                        case "[":
                                            l += "(";
                                            break;

                                        case "]":
                                            l += ")?";
                                            break;

                                        default:
                                            l += (0, r.default)(n[0]);
                                    } else if (o = x(n)) if (!0 !== a && o[3]) l += o[3].call(t.date); else o[2] ? l += t["raw" + o[2]] : l += n[0]; else l += n[0];
                                }
                                return l;
                            }
                            function _(e, t, i) {
                                for (e = String(e), t = t || 2; e.length < t; ) e = i ? e + "0" : "0" + e;
                                return e;
                            }
                            function w(e, t, i) {
                                return "string" == typeof e ? new h(e, t, i) : e && "object" === s(e) && Object.prototype.hasOwnProperty.call(e, "date") ? e : void 0;
                            }
                            function M(e, t) {
                                return S(t.inputFormat, {
                                    date: e
                                }, t);
                            }
                            function O(e, t) {
                                var i, a, n = 0, r = 0;
                                for (P(t).lastIndex = 0; a = P(t).exec(t.inputFormat); ) {
                                    var o = new RegExp("\\d+$").exec(a[0]);
                                    if ((n += r = o ? parseInt(o[0]) : a[0].length) >= e + 1) {
                                        i = a, a = P(t).exec(t.inputFormat);
                                        break;
                                    }
                                }
                                return {
                                    targetMatchIndex: n - r,
                                    nextMatch: a,
                                    targetMatch: i
                                };
                            }
                            a.default.extendAliases({
                                datetime: {
                                    mask: function(e) {
                                        return e.numericInput = !1, g.S = e.i18n.ordinalSuffix.join("|"), e.inputFormat = k[e.inputFormat] || e.inputFormat,
                                            e.displayFormat = k[e.displayFormat] || e.displayFormat || e.inputFormat, e.outputFormat = k[e.outputFormat] || e.outputFormat || e.inputFormat,
                                            e.placeholder = "" !== e.placeholder ? e.placeholder : e.inputFormat.replace(/[[\]]/, ""),
                                            e.regex = S(e.inputFormat, void 0, e), e.min = w(e.min, e.inputFormat, e), e.max = w(e.max, e.inputFormat, e),
                                            null;
                                    },
                                    placeholder: "",
                                    inputFormat: "isoDateTime",
                                    displayFormat: null,
                                    outputFormat: null,
                                    min: null,
                                    max: null,
                                    skipOptionalPartCharacter: "",
                                    i18n: {
                                        dayNames: [ "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday" ],
                                        monthNames: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
                                        ordinalSuffix: [ "st", "nd", "rd", "th" ]
                                    },
                                    preValidation: function(e, t, i, a, n, r, o, l) {
                                        if (l) return !0;
                                        if (isNaN(i) && e[t] !== i) {
                                            var s = O(t, n);
                                            if (s.nextMatch && s.nextMatch[0] === i && s.targetMatch[0].length > 1) {
                                                var u = g[s.targetMatch[0]][0];
                                                if (new RegExp(u).test("0" + e[t - 1])) return e[t] = e[t - 1], e[t - 1] = "0",
                                                    {
                                                        fuzzy: !0,
                                                        buffer: e,
                                                        refreshFromBuffer: {
                                                            start: t - 1,
                                                            end: t + 1
                                                        },
                                                        pos: t + 1
                                                    };
                                            }
                                        }
                                        return !0;
                                    },
                                    postValidation: function(e, t, i, a, n, r, o, s) {
                                        var u, c;
                                        if (o) return !0;
                                        if (!1 === a && (((u = O(t + 1, n)).targetMatch && u.targetMatchIndex === t && u.targetMatch[0].length > 1 && void 0 !== g[u.targetMatch[0]] || (u = O(t + 2, n)).targetMatch && u.targetMatchIndex === t + 1 && u.targetMatch[0].length > 1 && void 0 !== g[u.targetMatch[0]]) && (c = g[u.targetMatch[0]][0]),
                                        void 0 !== c && (void 0 !== r.validPositions[t + 1] && new RegExp(c).test(i + "0") ? (e[t] = i,
                                            e[t + 1] = "0", a = {
                                            pos: t + 2,
                                            caret: t
                                        }) : new RegExp(c).test("0" + i) && (e[t] = "0", e[t + 1] = i, a = {
                                            pos: t + 2
                                        })), !1 === a)) return a;
                                        if (a.fuzzy && (e = a.buffer, t = a.pos), (u = O(t, n)).targetMatch && u.targetMatch[0] && void 0 !== g[u.targetMatch[0]]) {
                                            var f = g[u.targetMatch[0]];
                                            c = f[0];
                                            var d = e.slice(u.targetMatchIndex, u.targetMatchIndex + u.targetMatch[0].length);
                                            if (!1 === new RegExp(c).test(d.join("")) && 2 === u.targetMatch[0].length && r.validPositions[u.targetMatchIndex] && r.validPositions[u.targetMatchIndex + 1] && (r.validPositions[u.targetMatchIndex + 1].input = "0"),
                                            "year" == f[2]) for (var p = l.getMaskTemplate.call(this, !1, 1, void 0, !0), h = t + 1; h < e.length; h++) e[h] = p[h],
                                                delete r.validPositions[h];
                                        }
                                        var m = a, k = w(e.join(""), n.inputFormat, n);
                                        return m && k.date.getTime() == k.date.getTime() && (n.prefillYear && (m = function(e, t, i) {
                                            if (e.year !== e.rawyear) {
                                                var a = v.toString(), n = e.rawyear.replace(/[^0-9]/g, ""), r = a.slice(0, n.length), o = a.slice(n.length);
                                                if (2 === n.length && n === r) {
                                                    var l = new Date(v, e.month - 1, e.day);
                                                    e.day == l.getDate() && (!i.max || i.max.date.getTime() >= l.getTime()) && (e.date.setFullYear(v),
                                                        e.year = a, t.insert = [ {
                                                        pos: t.pos + 1,
                                                        c: o[0]
                                                    }, {
                                                        pos: t.pos + 2,
                                                        c: o[1]
                                                    } ]);
                                                }
                                            }
                                            return t;
                                        }(k, m, n)), m = function(e, t, i, a, n) {
                                            if (!t) return t;
                                            if (t && i.min && i.min.date.getTime() == i.min.date.getTime()) {
                                                var r;
                                                for (e.reset(), P(i).lastIndex = 0; r = P(i).exec(i.inputFormat); ) {
                                                    var o;
                                                    if ((o = x(r)) && o[3]) {
                                                        for (var l = o[1], s = e[o[2]], u = i.min[o[2]], c = i.max ? i.max[o[2]] : u, f = [], d = !1, p = 0; p < u.length; p++) void 0 !== a.validPositions[p + r.index] || d ? (f[p] = s[p],
                                                            d = d || s[p] > u[p]) : (f[p] = u[p], "year" === o[2] && s.length - 1 == p && u != c && (f = (parseInt(f.join("")) + 1).toString().split("")),
                                                        "ampm" === o[2] && u != c && i.min.date.getTime() > e.date.getTime() && (f[p] = c[p]));
                                                        l.call(e._date, f.join(""));
                                                    }
                                                }
                                                t = i.min.date.getTime() <= e.date.getTime(), e.reInit();
                                            }
                                            return t && i.max && i.max.date.getTime() == i.max.date.getTime() && (t = i.max.date.getTime() >= e.date.getTime()),
                                                t;
                                        }(k, m = E.call(this, k, m, n), n, r)), void 0 !== t && m && a.pos !== t ? {
                                            buffer: S(n.inputFormat, k, n).split(""),
                                            refreshFromBuffer: {
                                                start: t,
                                                end: a.pos
                                            },
                                            pos: a.caret || a.pos
                                        } : m;
                                    },
                                    onKeyDown: function(e, t, i, a) {
                                        e.ctrlKey && e.keyCode === n.default.RIGHT && (this.inputmask._valueSet(M(new Date, a)),
                                            p(this).trigger("setvalue"));
                                    },
                                    onUnMask: function(e, t, i) {
                                        return t ? S(i.outputFormat, w(e, i.inputFormat, i), i, !0) : t;
                                    },
                                    casing: function(e, t, i, a) {
                                        return 0 == t.nativeDef.indexOf("[ap]") ? e.toLowerCase() : 0 == t.nativeDef.indexOf("[AP]") ? e.toUpperCase() : e;
                                    },
                                    onBeforeMask: function(e, t) {
                                        return "[object Date]" === Object.prototype.toString.call(e) && (e = M(e, t)), e;
                                    },
                                    insertMode: !1,
                                    shiftPositions: !1,
                                    keepStatic: !1,
                                    inputmode: "numeric",
                                    prefillYear: !0
                                }
                            });
                        },
                        3851: function(e, t, i) {
                            var a, n = (a = i(2394)) && a.__esModule ? a : {
                                default: a
                            }, r = i(8711), o = i(4713);
                            n.default.extendDefinitions({
                                A: {
                                    validator: "[A-Za-z\u0410-\u044f\u0401\u0451\xc0-\xff\xb5]",
                                    casing: "upper"
                                },
                                "&": {
                                    validator: "[0-9A-Za-z\u0410-\u044f\u0401\u0451\xc0-\xff\xb5]",
                                    casing: "upper"
                                },
                                "#": {
                                    validator: "[0-9A-Fa-f]",
                                    casing: "upper"
                                }
                            });
                            var l = new RegExp("25[0-5]|2[0-4][0-9]|[01][0-9][0-9]");
                            function s(e, t, i, a, n) {
                                return i - 1 > -1 && "." !== t.buffer[i - 1] ? (e = t.buffer[i - 1] + e, e = i - 2 > -1 && "." !== t.buffer[i - 2] ? t.buffer[i - 2] + e : "0" + e) : e = "00" + e,
                                    l.test(e);
                            }
                            n.default.extendAliases({
                                cssunit: {
                                    regex: "[+-]?[0-9]+\\.?([0-9]+)?(px|em|rem|ex|%|in|cm|mm|pt|pc)"
                                },
                                url: {
                                    regex: "(https?|ftp)://.*",
                                    autoUnmask: !1,
                                    keepStatic: !1,
                                    tabThrough: !0
                                },
                                ip: {
                                    mask: "i{1,3}.j{1,3}.k{1,3}.l{1,3}",
                                    definitions: {
                                        i: {
                                            validator: s
                                        },
                                        j: {
                                            validator: s
                                        },
                                        k: {
                                            validator: s
                                        },
                                        l: {
                                            validator: s
                                        }
                                    },
                                    onUnMask: function(e, t, i) {
                                        return e;
                                    },
                                    inputmode: "decimal",
                                    substitutes: {
                                        ",": "."
                                    }
                                },
                                email: {
                                    mask: function(e) {
                                        var t = "*{1,64}[.*{1,64}][.*{1,64}][.*{1,63}]@-{1,63}.-{1,63}[.-{1,63}][.-{1,63}]", i = t;
                                        if (e.separator) for (var a = 0; a < e.quantifier; a++) i += "[".concat(e.separator).concat(t, "]");
                                        return i;
                                    },
                                    greedy: !1,
                                    casing: "lower",
                                    separator: null,
                                    quantifier: 5,
                                    skipOptionalPartCharacter: "",
                                    onBeforePaste: function(e, t) {
                                        return (e = e.toLowerCase()).replace("mailto:", "");
                                    },
                                    definitions: {
                                        "*": {
                                            validator: "[0-9\uff11-\uff19A-Za-z\u0410-\u044f\u0401\u0451\xc0-\xff\xb5!#$%&'*+/=?^_`{|}~-]"
                                        },
                                        "-": {
                                            validator: "[0-9A-Za-z-]"
                                        }
                                    },
                                    onUnMask: function(e, t, i) {
                                        return e;
                                    },
                                    inputmode: "email"
                                },
                                mac: {
                                    mask: "##:##:##:##:##:##"
                                },
                                vin: {
                                    mask: "V{13}9{4}",
                                    definitions: {
                                        V: {
                                            validator: "[A-HJ-NPR-Za-hj-npr-z\\d]",
                                            casing: "upper"
                                        }
                                    },
                                    clearIncomplete: !0,
                                    autoUnmask: !0
                                },
                                ssn: {
                                    mask: "999-99-9999",
                                    postValidation: function(e, t, i, a, n, l, s) {
                                        var u = o.getMaskTemplate.call(this, !0, r.getLastValidPosition.call(this), !0, !0);
                                        return /^(?!219-09-9999|078-05-1120)(?!666|000|9.{2}).{3}-(?!00).{2}-(?!0{4}).{4}$/.test(u.join(""));
                                    }
                                }
                            });
                        },
                        207: function(e, t, i) {
                            var a = l(i(2394)), n = l(i(5581)), r = l(i(7184)), o = i(8711);
                            function l(e) {
                                return e && e.__esModule ? e : {
                                    default: e
                                };
                            }
                            var s = a.default.dependencyLib;
                            function u(e, t) {
                                for (var i = "", n = 0; n < e.length; n++) a.default.prototype.definitions[e.charAt(n)] || t.definitions[e.charAt(n)] || t.optionalmarker[0] === e.charAt(n) || t.optionalmarker[1] === e.charAt(n) || t.quantifiermarker[0] === e.charAt(n) || t.quantifiermarker[1] === e.charAt(n) || t.groupmarker[0] === e.charAt(n) || t.groupmarker[1] === e.charAt(n) || t.alternatormarker === e.charAt(n) ? i += "\\" + e.charAt(n) : i += e.charAt(n);
                                return i;
                            }
                            function c(e, t, i, a) {
                                if (e.length > 0 && t > 0 && (!i.digitsOptional || a)) {
                                    var n = e.indexOf(i.radixPoint), r = !1;
                                    i.negationSymbol.back === e[e.length - 1] && (r = !0, e.length--), -1 === n && (e.push(i.radixPoint),
                                        n = e.length - 1);
                                    for (var o = 1; o <= t; o++) isFinite(e[n + o]) || (e[n + o] = "0");
                                }
                                return r && e.push(i.negationSymbol.back), e;
                            }
                            function f(e, t) {
                                var i = 0;
                                if ("+" === e) {
                                    for (i in t.validPositions) ;
                                    i = o.seekNext.call(this, parseInt(i));
                                }
                                for (var a in t.tests) if ((a = parseInt(a)) >= i) for (var n = 0, r = t.tests[a].length; n < r; n++) if ((void 0 === t.validPositions[a] || "-" === e) && t.tests[a][n].match.def === e) return a + (void 0 !== t.validPositions[a] && "-" !== e ? 1 : 0);
                                return i;
                            }
                            function d(e, t) {
                                var i = -1;
                                for (var a in t.validPositions) {
                                    var n = t.validPositions[a];
                                    if (n && n.match.def === e) {
                                        i = parseInt(a);
                                        break;
                                    }
                                }
                                return i;
                            }
                            function p(e, t, i, a, n) {
                                var r = t.buffer ? t.buffer.indexOf(n.radixPoint) : -1, o = (-1 !== r || a && n.jitMasking) && new RegExp(n.definitions[9].validator).test(e);
                                return n._radixDance && -1 !== r && o && null == t.validPositions[r] ? {
                                    insert: {
                                        pos: r === i ? r + 1 : r,
                                        c: n.radixPoint
                                    },
                                    pos: i
                                } : o;
                            }
                            a.default.extendAliases({
                                numeric: {
                                    mask: function(e) {
                                        e.repeat = 0, e.groupSeparator === e.radixPoint && e.digits && "0" !== e.digits && ("." === e.radixPoint ? e.groupSeparator = "," : "," === e.radixPoint ? e.groupSeparator = "." : e.groupSeparator = ""),
                                        " " === e.groupSeparator && (e.skipOptionalPartCharacter = void 0), e.placeholder.length > 1 && (e.placeholder = e.placeholder.charAt(0)),
                                        "radixFocus" === e.positionCaretOnClick && "" === e.placeholder && (e.positionCaretOnClick = "lvp");
                                        var t = "0", i = e.radixPoint;
                                        !0 === e.numericInput && void 0 === e.__financeInput ? (t = "1", e.positionCaretOnClick = "radixFocus" === e.positionCaretOnClick ? "lvp" : e.positionCaretOnClick,
                                            e.digitsOptional = !1, isNaN(e.digits) && (e.digits = 2), e._radixDance = !1, i = "," === e.radixPoint ? "?" : "!",
                                        "" !== e.radixPoint && void 0 === e.definitions[i] && (e.definitions[i] = {}, e.definitions[i].validator = "[" + e.radixPoint + "]",
                                            e.definitions[i].placeholder = e.radixPoint, e.definitions[i].static = !0, e.definitions[i].generated = !0)) : (e.__financeInput = !1,
                                            e.numericInput = !0);
                                        var a, n = "[+]";
                                        if (n += u(e.prefix, e), "" !== e.groupSeparator ? (void 0 === e.definitions[e.groupSeparator] && (e.definitions[e.groupSeparator] = {},
                                            e.definitions[e.groupSeparator].validator = "[" + e.groupSeparator + "]", e.definitions[e.groupSeparator].placeholder = e.groupSeparator,
                                            e.definitions[e.groupSeparator].static = !0, e.definitions[e.groupSeparator].generated = !0),
                                            n += e._mask(e)) : n += "9{+}", void 0 !== e.digits && 0 !== e.digits) {
                                            var o = e.digits.toString().split(",");
                                            isFinite(o[0]) && o[1] && isFinite(o[1]) ? n += i + t + "{" + e.digits + "}" : (isNaN(e.digits) || parseInt(e.digits) > 0) && (e.digitsOptional || e.jitMasking ? (a = n + i + t + "{0," + e.digits + "}",
                                                e.keepStatic = !0) : n += i + t + "{" + e.digits + "}");
                                        } else e.inputmode = "numeric";
                                        return n += u(e.suffix, e), n += "[-]", a && (n = [ a + u(e.suffix, e) + "[-]", n ]),
                                            e.greedy = !1, function(e) {
                                            void 0 === e.parseMinMaxOptions && (null !== e.min && (e.min = e.min.toString().replace(new RegExp((0,
                                                r.default)(e.groupSeparator), "g"), ""), "," === e.radixPoint && (e.min = e.min.replace(e.radixPoint, ".")),
                                                e.min = isFinite(e.min) ? parseFloat(e.min) : NaN, isNaN(e.min) && (e.min = Number.MIN_VALUE)),
                                            null !== e.max && (e.max = e.max.toString().replace(new RegExp((0, r.default)(e.groupSeparator), "g"), ""),
                                            "," === e.radixPoint && (e.max = e.max.replace(e.radixPoint, ".")), e.max = isFinite(e.max) ? parseFloat(e.max) : NaN,
                                            isNaN(e.max) && (e.max = Number.MAX_VALUE)), e.parseMinMaxOptions = "done");
                                        }(e), "" !== e.radixPoint && (e.substitutes["." == e.radixPoint ? "," : "."] = e.radixPoint),
                                            n;
                                    },
                                    _mask: function(e) {
                                        return "(" + e.groupSeparator + "999){+|1}";
                                    },
                                    digits: "*",
                                    digitsOptional: !0,
                                    enforceDigitsOnBlur: !1,
                                    radixPoint: ".",
                                    positionCaretOnClick: "radixFocus",
                                    _radixDance: !0,
                                    groupSeparator: "",
                                    allowMinus: !0,
                                    negationSymbol: {
                                        front: "-",
                                        back: ""
                                    },
                                    prefix: "",
                                    suffix: "",
                                    min: null,
                                    max: null,
                                    SetMaxOnOverflow: !1,
                                    step: 1,
                                    inputType: "text",
                                    unmaskAsNumber: !1,
                                    roundingFN: Math.round,
                                    inputmode: "decimal",
                                    shortcuts: {
                                        k: "1000",
                                        m: "1000000"
                                    },
                                    placeholder: "0",
                                    greedy: !1,
                                    rightAlign: !0,
                                    insertMode: !0,
                                    autoUnmask: !1,
                                    skipOptionalPartCharacter: "",
                                    usePrototypeDefinitions: !1,
                                    stripLeadingZeroes: !0,
                                    definitions: {
                                        0: {
                                            validator: p
                                        },
                                        1: {
                                            validator: p,
                                            definitionSymbol: "9"
                                        },
                                        9: {
                                            validator: "[0-9\uff10-\uff19\u0660-\u0669\u06f0-\u06f9]",
                                            definitionSymbol: "*"
                                        },
                                        "+": {
                                            validator: function(e, t, i, a, n) {
                                                return n.allowMinus && ("-" === e || e === n.negationSymbol.front);
                                            }
                                        },
                                        "-": {
                                            validator: function(e, t, i, a, n) {
                                                return n.allowMinus && e === n.negationSymbol.back;
                                            }
                                        }
                                    },
                                    preValidation: function(e, t, i, a, n, r, o, l) {
                                        if (!1 !== n.__financeInput && i === n.radixPoint) return !1;
                                        var s = e.indexOf(n.radixPoint), u = t;
                                        if (t = function(e, t, i, a, n) {
                                            return n._radixDance && n.numericInput && t !== n.negationSymbol.back && e <= i && (i > 0 || t == n.radixPoint) && (void 0 === a.validPositions[e - 1] || a.validPositions[e - 1].input !== n.negationSymbol.back) && (e -= 1),
                                                e;
                                        }(t, i, s, r, n), "-" === i || i === n.negationSymbol.front) {
                                            if (!0 !== n.allowMinus) return !1;
                                            var c = !1, p = d("+", r), h = d("-", r);
                                            return -1 !== p && (c = [ p, h ]), !1 !== c ? {
                                                remove: c,
                                                caret: u - n.negationSymbol.back.length
                                            } : {
                                                insert: [ {
                                                    pos: f.call(this, "+", r),
                                                    c: n.negationSymbol.front,
                                                    fromIsValid: !0
                                                }, {
                                                    pos: f.call(this, "-", r),
                                                    c: n.negationSymbol.back,
                                                    fromIsValid: void 0
                                                } ],
                                                caret: u + n.negationSymbol.back.length
                                            };
                                        }
                                        if (i === n.groupSeparator) return {
                                            caret: u
                                        };
                                        if (l) return !0;
                                        if (-1 !== s && !0 === n._radixDance && !1 === a && i === n.radixPoint && void 0 !== n.digits && (isNaN(n.digits) || parseInt(n.digits) > 0) && s !== t) return {
                                            caret: n._radixDance && t === s - 1 ? s + 1 : s
                                        };
                                        if (!1 === n.__financeInput) if (a) {
                                            if (n.digitsOptional) return {
                                                rewritePosition: o.end
                                            };
                                            if (!n.digitsOptional) {
                                                if (o.begin > s && o.end <= s) return i === n.radixPoint ? {
                                                    insert: {
                                                        pos: s + 1,
                                                        c: "0",
                                                        fromIsValid: !0
                                                    },
                                                    rewritePosition: s
                                                } : {
                                                    rewritePosition: s + 1
                                                };
                                                if (o.begin < s) return {
                                                    rewritePosition: o.begin - 1
                                                };
                                            }
                                        } else if (!n.showMaskOnHover && !n.showMaskOnFocus && !n.digitsOptional && n.digits > 0 && "" === this.__valueGet.call(this.el)) return {
                                            rewritePosition: s
                                        };
                                        return {
                                            rewritePosition: t
                                        };
                                    },
                                    postValidation: function(e, t, i, a, n, r, o) {
                                        if (!1 === a) return a;
                                        if (o) return !0;
                                        if (null !== n.min || null !== n.max) {
                                            var l = n.onUnMask(e.slice().reverse().join(""), void 0, s.extend({}, n, {
                                                unmaskAsNumber: !0
                                            }));
                                            if (null !== n.min && l < n.min && (l.toString().length > n.min.toString().length || l < 0)) return !1;
                                            if (null !== n.max && l > n.max) return !!n.SetMaxOnOverflow && {
                                                refreshFromBuffer: !0,
                                                buffer: c(n.max.toString().replace(".", n.radixPoint).split(""), n.digits, n).reverse()
                                            };
                                        }
                                        return a;
                                    },
                                    onUnMask: function(e, t, i) {
                                        if ("" === t && !0 === i.nullable) return t;
                                        var a = e.replace(i.prefix, "");
                                        return a = (a = a.replace(i.suffix, "")).replace(new RegExp((0, r.default)(i.groupSeparator), "g"), ""),
                                        "" !== i.placeholder.charAt(0) && (a = a.replace(new RegExp(i.placeholder.charAt(0), "g"), "0")),
                                            i.unmaskAsNumber ? ("" !== i.radixPoint && -1 !== a.indexOf(i.radixPoint) && (a = a.replace(r.default.call(this, i.radixPoint), ".")),
                                                a = (a = a.replace(new RegExp("^" + (0, r.default)(i.negationSymbol.front)), "-")).replace(new RegExp((0,
                                                    r.default)(i.negationSymbol.back) + "$"), ""), Number(a)) : a;
                                    },
                                    isComplete: function(e, t) {
                                        var i = (t.numericInput ? e.slice().reverse() : e).join("");
                                        return i = (i = (i = (i = (i = i.replace(new RegExp("^" + (0, r.default)(t.negationSymbol.front)), "-")).replace(new RegExp((0,
                                            r.default)(t.negationSymbol.back) + "$"), "")).replace(t.prefix, "")).replace(t.suffix, "")).replace(new RegExp((0,
                                            r.default)(t.groupSeparator) + "([0-9]{3})", "g"), "$1"), "," === t.radixPoint && (i = i.replace((0,
                                            r.default)(t.radixPoint), ".")), isFinite(i);
                                    },
                                    onBeforeMask: function(e, t) {
                                        var i = t.radixPoint || ",";
                                        isFinite(t.digits) && (t.digits = parseInt(t.digits)), "number" != typeof e && "number" !== t.inputType || "" === i || (e = e.toString().replace(".", i));
                                        var a = "-" === e.charAt(0) || e.charAt(0) === t.negationSymbol.front, n = e.split(i), o = n[0].replace(/[^\-0-9]/g, ""), l = n.length > 1 ? n[1].replace(/[^0-9]/g, "") : "", s = n.length > 1;
                                        e = o + ("" !== l ? i + l : l);
                                        var u = 0;
                                        if ("" !== i && (u = t.digitsOptional ? t.digits < l.length ? t.digits : l.length : t.digits,
                                        "" !== l || !t.digitsOptional)) {
                                            var f = Math.pow(10, u || 1);
                                            e = e.replace((0, r.default)(i), "."), isNaN(parseFloat(e)) || (e = (t.roundingFN(parseFloat(e) * f) / f).toFixed(u)),
                                                e = e.toString().replace(".", i);
                                        }
                                        if (0 === t.digits && -1 !== e.indexOf(i) && (e = e.substring(0, e.indexOf(i))),
                                        null !== t.min || null !== t.max) {
                                            var d = e.toString().replace(i, ".");
                                            null !== t.min && d < t.min ? e = t.min.toString().replace(".", i) : null !== t.max && d > t.max && (e = t.max.toString().replace(".", i));
                                        }
                                        return a && "-" !== e.charAt(0) && (e = "-" + e), c(e.toString().split(""), u, t, s).join("");
                                    },
                                    onBeforeWrite: function(e, t, i, a) {
                                        function n(e, t) {
                                            if (!1 !== a.__financeInput || t) {
                                                var i = e.indexOf(a.radixPoint);
                                                -1 !== i && e.splice(i, 1);
                                            }
                                            if ("" !== a.groupSeparator) for (;-1 !== (i = e.indexOf(a.groupSeparator)); ) e.splice(i, 1);
                                            return e;
                                        }
                                        var o, l;
                                        if (a.stripLeadingZeroes && (l = function(e, t) {
                                            var i = new RegExp("(^" + ("" !== t.negationSymbol.front ? (0, r.default)(t.negationSymbol.front) + "?" : "") + (0,
                                                r.default)(t.prefix) + ")(.*)(" + (0, r.default)(t.suffix) + ("" != t.negationSymbol.back ? (0,
                                                r.default)(t.negationSymbol.back) + "?" : "") + "$)").exec(e.slice().reverse().join("")), a = i ? i[2] : "", n = !1;
                                            return a && (a = a.split(t.radixPoint.charAt(0))[0], n = new RegExp("^[0" + t.groupSeparator + "]*").exec(a)),
                                            !(!n || !(n[0].length > 1 || n[0].length > 0 && n[0].length < a.length)) && n;
                                        }(t, a))) for (var u = t.join("").lastIndexOf(l[0].split("").reverse().join("")) - (l[0] == l.input ? 0 : 1), f = l[0] == l.input ? 1 : 0, d = l[0].length - f; d > 0; d--) delete this.maskset.validPositions[u + d],
                                            delete t[u + d];
                                        if (e) switch (e.type) {
                                            case "blur":
                                            case "checkval":
                                                if (null !== a.min) {
                                                    var p = a.onUnMask(t.slice().reverse().join(""), void 0, s.extend({}, a, {
                                                        unmaskAsNumber: !0
                                                    }));
                                                    if (null !== a.min && p < a.min) return {
                                                        refreshFromBuffer: !0,
                                                        buffer: c(a.min.toString().replace(".", a.radixPoint).split(""), a.digits, a).reverse()
                                                    };
                                                }
                                                if (t[t.length - 1] === a.negationSymbol.front) {
                                                    var h = new RegExp("(^" + ("" != a.negationSymbol.front ? (0, r.default)(a.negationSymbol.front) + "?" : "") + (0,
                                                        r.default)(a.prefix) + ")(.*)(" + (0, r.default)(a.suffix) + ("" != a.negationSymbol.back ? (0,
                                                        r.default)(a.negationSymbol.back) + "?" : "") + "$)").exec(n(t.slice(), !0).reverse().join(""));
                                                    0 == (h ? h[2] : "") && (o = {
                                                        refreshFromBuffer: !0,
                                                        buffer: [ 0 ]
                                                    });
                                                } else if ("" !== a.radixPoint) {
                                                    t.indexOf(a.radixPoint) === a.suffix.length && (o && o.buffer ? o.buffer.splice(0, 1 + a.suffix.length) : (t.splice(0, 1 + a.suffix.length),
                                                        o = {
                                                            refreshFromBuffer: !0,
                                                            buffer: n(t)
                                                        }));
                                                }
                                                if (a.enforceDigitsOnBlur) {
                                                    var v = (o = o || {}) && o.buffer || t.slice().reverse();
                                                    o.refreshFromBuffer = !0, o.buffer = c(v, a.digits, a, !0).reverse();
                                                }
                                        }
                                        return o;
                                    },
                                    onKeyDown: function(e, t, i, a) {
                                        var r, o, l = s(this), u = String.fromCharCode(e.keyCode).toLowerCase();
                                        if ((o = a.shortcuts && a.shortcuts[u]) && o.length > 1) return this.inputmask.__valueSet.call(this, parseFloat(this.inputmask.unmaskedvalue()) * parseInt(o)),
                                            l.trigger("setvalue"), !1;
                                        if (e.ctrlKey) switch (e.keyCode) {
                                            case n.default.UP:
                                                return this.inputmask.__valueSet.call(this, parseFloat(this.inputmask.unmaskedvalue()) + parseInt(a.step)),
                                                    l.trigger("setvalue"), !1;

                                            case n.default.DOWN:
                                                return this.inputmask.__valueSet.call(this, parseFloat(this.inputmask.unmaskedvalue()) - parseInt(a.step)),
                                                    l.trigger("setvalue"), !1;
                                        }
                                        if (!e.shiftKey && (e.keyCode === n.default.DELETE || e.keyCode === n.default.BACKSPACE || e.keyCode === n.default.BACKSPACE_SAFARI) && i.begin !== t.length) {
                                            if (t[e.keyCode === n.default.DELETE ? i.begin - 1 : i.end] === a.negationSymbol.front) return r = t.slice().reverse(),
                                            "" !== a.negationSymbol.front && r.shift(), "" !== a.negationSymbol.back && r.pop(),
                                                l.trigger("setvalue", [ r.join(""), i.begin ]), !1;
                                            if (!0 === a._radixDance) {
                                                var f = t.indexOf(a.radixPoint);
                                                if (a.digitsOptional) {
                                                    if (0 === f) return (r = t.slice().reverse()).pop(), l.trigger("setvalue", [ r.join(""), i.begin >= r.length ? r.length : i.begin ]),
                                                        !1;
                                                } else if (-1 !== f && (i.begin < f || i.end < f || e.keyCode === n.default.DELETE && i.begin === f)) return i.begin !== i.end || e.keyCode !== n.default.BACKSPACE && e.keyCode !== n.default.BACKSPACE_SAFARI || i.begin++,
                                                    (r = t.slice().reverse()).splice(r.length - i.begin, i.begin - i.end + 1), r = c(r, a.digits, a).join(""),
                                                    l.trigger("setvalue", [ r, i.begin >= r.length ? f + 1 : i.begin ]), !1;
                                            }
                                        }
                                    }
                                },
                                currency: {
                                    prefix: "",
                                    groupSeparator: ",",
                                    alias: "numeric",
                                    digits: 2,
                                    digitsOptional: !1
                                },
                                decimal: {
                                    alias: "numeric"
                                },
                                integer: {
                                    alias: "numeric",
                                    inputmode: "numeric",
                                    digits: 0
                                },
                                percentage: {
                                    alias: "numeric",
                                    min: 0,
                                    max: 100,
                                    suffix: " %",
                                    digits: 0,
                                    allowMinus: !1
                                },
                                indianns: {
                                    alias: "numeric",
                                    _mask: function(e) {
                                        return "(" + e.groupSeparator + "99){*|1}(" + e.groupSeparator + "999){1|1}";
                                    },
                                    groupSeparator: ",",
                                    radixPoint: ".",
                                    placeholder: "0",
                                    digits: 2,
                                    digitsOptional: !1
                                }
                            });
                        },
                        9380: function(e, t, i) {
                            var a;
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            }), t.default = void 0;
                            var n = ((a = i(8741)) && a.__esModule ? a : {
                                default: a
                            }).default ? window : {};
                            t.default = n;
                        },
                        7760: function(e, t, i) {
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            }), t.HandleNativePlaceholder = function(e, t) {
                                var i = e ? e.inputmask : this;
                                if (s.ie) {
                                    if (e.inputmask._valueGet() !== t && (e.placeholder !== t || "" === e.placeholder)) {
                                        var a = o.getBuffer.call(i).slice(), n = e.inputmask._valueGet();
                                        if (n !== t) {
                                            var r = o.getLastValidPosition.call(i);
                                            -1 === r && n === o.getBufferTemplate.call(i).join("") ? a = [] : -1 !== r && f.call(i, a),
                                                p(e, a);
                                        }
                                    }
                                } else e.placeholder !== t && (e.placeholder = t, "" === e.placeholder && e.removeAttribute("placeholder"));
                            }, t.applyInputValue = c, t.checkVal = d, t.clearOptionalTail = f, t.unmaskedvalue = function(e) {
                                var t = e ? e.inputmask : this, i = t.opts, a = t.maskset;
                                if (e) {
                                    if (void 0 === e.inputmask) return e.value;
                                    e.inputmask && e.inputmask.refreshValue && c(e, e.inputmask._valueGet(!0));
                                }
                                var n = [], r = a.validPositions;
                                for (var l in r) r[l] && r[l].match && (1 != r[l].match.static || Array.isArray(a.metadata) && !0 !== r[l].generatedInput) && n.push(r[l].input);
                                var s = 0 === n.length ? "" : (t.isRTL ? n.reverse() : n).join("");
                                if ("function" == typeof i.onUnMask) {
                                    var u = (t.isRTL ? o.getBuffer.call(t).slice().reverse() : o.getBuffer.call(t)).join("");
                                    s = i.onUnMask.call(t, u, s, i);
                                }
                                return s;
                            }, t.writeBuffer = p;
                            var a, n = (a = i(5581)) && a.__esModule ? a : {
                                default: a
                            }, r = i(4713), o = i(8711), l = i(7215), s = i(9845), u = i(6030);
                            function c(e, t) {
                                var i = e ? e.inputmask : this, a = i.opts;
                                e.inputmask.refreshValue = !1, "function" == typeof a.onBeforeMask && (t = a.onBeforeMask.call(i, t, a) || t),
                                    d(e, !0, !1, t = t.toString().split("")), i.undoValue = i._valueGet(!0), (a.clearMaskOnLostFocus || a.clearIncomplete) && e.inputmask._valueGet() === o.getBufferTemplate.call(i).join("") && -1 === o.getLastValidPosition.call(i) && e.inputmask._valueSet("");
                            }
                            function f(e) {
                                e.length = 0;
                                for (var t, i = r.getMaskTemplate.call(this, !0, 0, !0, void 0, !0); void 0 !== (t = i.shift()); ) e.push(t);
                                return e;
                            }
                            function d(e, t, i, a, n) {
                                var s = e ? e.inputmask : this, c = s.maskset, f = s.opts, d = s.dependencyLib, h = a.slice(), v = "", m = -1, g = void 0, k = f.skipOptionalPartCharacter;
                                f.skipOptionalPartCharacter = "", o.resetMaskSet.call(s), c.tests = {}, m = f.radixPoint ? o.determineNewCaretPosition.call(s, {
                                    begin: 0,
                                    end: 0
                                }, !1, !1 === f.__financeInput ? "radixFocus" : void 0).begin : 0, c.p = m, s.caretPos = {
                                    begin: m
                                };
                                var y = [], b = s.caretPos;
                                if (h.forEach((function(e, t) {
                                    if (void 0 !== e) {
                                        var a = new d.Event("_checkval");
                                        a.keyCode = e.toString().charCodeAt(0), v += e;
                                        var n = o.getLastValidPosition.call(s, void 0, !0);
                                        !function(e, t) {
                                            for (var i = r.getMaskTemplate.call(s, !0, 0).slice(e, o.seekNext.call(s, e, !1, !1)).join("").replace(/'/g, ""), a = i.indexOf(t); a > 0 && " " === i[a - 1]; ) a--;
                                            var n = 0 === a && !o.isMask.call(s, e) && (r.getTest.call(s, e).match.nativeDef === t.charAt(0) || !0 === r.getTest.call(s, e).match.static && r.getTest.call(s, e).match.nativeDef === "'" + t.charAt(0) || " " === r.getTest.call(s, e).match.nativeDef && (r.getTest.call(s, e + 1).match.nativeDef === t.charAt(0) || !0 === r.getTest.call(s, e + 1).match.static && r.getTest.call(s, e + 1).match.nativeDef === "'" + t.charAt(0)));
                                            if (!n && a > 0 && !o.isMask.call(s, e, !1, !0)) {
                                                var l = o.seekNext.call(s, e);
                                                s.caretPos.begin < l && (s.caretPos = {
                                                    begin: l
                                                });
                                            }
                                            return n;
                                        }(m, v) ? (g = u.EventHandlers.keypressEvent.call(s, a, !0, !1, i, s.caretPos.begin)) && (m = s.caretPos.begin + 1,
                                            v = "") : g = u.EventHandlers.keypressEvent.call(s, a, !0, !1, i, n + 1), g ? (void 0 !== g.pos && c.validPositions[g.pos] && !0 === c.validPositions[g.pos].match.static && void 0 === c.validPositions[g.pos].alternation && (y.push(g.pos),
                                        s.isRTL || (g.forwardPosition = g.pos + 1)), p.call(s, void 0, o.getBuffer.call(s), g.forwardPosition, a, !1),
                                            s.caretPos = {
                                                begin: g.forwardPosition,
                                                end: g.forwardPosition
                                            }, b = s.caretPos) : void 0 === c.validPositions[t] && h[t] === r.getPlaceholder.call(s, t) && o.isMask.call(s, t, !0) ? s.caretPos.begin++ : s.caretPos = b;
                                    }
                                })), y.length > 0) {
                                    var x, P, E = o.seekNext.call(s, -1, void 0, !1);
                                    if (!l.isComplete.call(s, o.getBuffer.call(s)) && y.length <= E || l.isComplete.call(s, o.getBuffer.call(s)) && y.length > 0 && y.length !== E && 0 === y[0]) for (var S = E; void 0 !== (x = y.shift()); ) {
                                        var _ = new d.Event("_checkval");
                                        if ((P = c.validPositions[x]).generatedInput = !0, _.keyCode = P.input.charCodeAt(0),
                                        (g = u.EventHandlers.keypressEvent.call(s, _, !0, !1, i, S)) && void 0 !== g.pos && g.pos !== x && c.validPositions[g.pos] && !0 === c.validPositions[g.pos].match.static) y.push(g.pos); else if (!g) break;
                                        S++;
                                    }
                                }
                                t && p.call(s, e, o.getBuffer.call(s), g ? g.forwardPosition : s.caretPos.begin, n || new d.Event("checkval"), n && ("input" === n.type && s.undoValue !== o.getBuffer.call(s).join("") || "paste" === n.type)),
                                    f.skipOptionalPartCharacter = k;
                            }
                            function p(e, t, i, a, r) {
                                var s = e ? e.inputmask : this, u = s.opts, c = s.dependencyLib;
                                if (a && "function" == typeof u.onBeforeWrite) {
                                    var f = u.onBeforeWrite.call(s, a, t, i, u);
                                    if (f) {
                                        if (f.refreshFromBuffer) {
                                            var d = f.refreshFromBuffer;
                                            l.refreshFromBuffer.call(s, !0 === d ? d : d.start, d.end, f.buffer || t), t = o.getBuffer.call(s, !0);
                                        }
                                        void 0 !== i && (i = void 0 !== f.caret ? f.caret : i);
                                    }
                                }
                                if (void 0 !== e && (e.inputmask._valueSet(t.join("")), void 0 === i || void 0 !== a && "blur" === a.type || o.caret.call(s, e, i, void 0, void 0, void 0 !== a && "keydown" === a.type && (a.keyCode === n.default.DELETE || a.keyCode === n.default.BACKSPACE)),
                                !0 === r)) {
                                    var p = c(e), h = e.inputmask._valueGet();
                                    e.inputmask.skipInputEvent = !0, p.trigger("input"), setTimeout((function() {
                                        h === o.getBufferTemplate.call(s).join("") ? p.trigger("cleared") : !0 === l.isComplete.call(s, t) && p.trigger("complete");
                                    }), 0);
                                }
                            }
                        },
                        2394: function(e, t, i) {
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            }), t.default = void 0, i(7149), i(3194);
                            var a = i(157), n = m(i(4963)), r = m(i(9380)), o = i(2391), l = i(4713), s = i(8711), u = i(7215), c = i(7760), f = i(9716), d = m(i(7392)), p = m(i(3976)), h = m(i(8741));
                            function v(e) {
                                return v = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                                    return typeof e;
                                } : function(e) {
                                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
                                }, v(e);
                            }
                            function m(e) {
                                return e && e.__esModule ? e : {
                                    default: e
                                };
                            }
                            var g = r.default.document, k = "_inputmask_opts";
                            function y(e, t, i) {
                                if (h.default) {
                                    if (!(this instanceof y)) return new y(e, t, i);
                                    this.dependencyLib = n.default, this.el = void 0, this.events = {}, this.maskset = void 0,
                                    !0 !== i && ("[object Object]" === Object.prototype.toString.call(e) ? t = e : (t = t || {},
                                    e && (t.alias = e)), this.opts = n.default.extend(!0, {}, this.defaults, t), this.noMasksCache = t && void 0 !== t.definitions,
                                        this.userOptions = t || {}, b(this.opts.alias, t, this.opts)), this.refreshValue = !1,
                                        this.undoValue = void 0, this.$el = void 0, this.skipKeyPressEvent = !1, this.skipInputEvent = !1,
                                        this.validationEvent = !1, this.ignorable = !1, this.maxLength, this.mouseEnter = !1,
                                        this.originalPlaceholder = void 0, this.isComposing = !1;
                                }
                            }
                            function b(e, t, i) {
                                var a = y.prototype.aliases[e];
                                return a ? (a.alias && b(a.alias, void 0, i), n.default.extend(!0, i, a), n.default.extend(!0, i, t),
                                    !0) : (null === i.mask && (i.mask = e), !1);
                            }
                            y.prototype = {
                                dataAttribute: "data-inputmask",
                                defaults: p.default,
                                definitions: d.default,
                                aliases: {},
                                masksCache: {},
                                get isRTL() {
                                    return this.opts.isRTL || this.opts.numericInput;
                                },
                                mask: function(e) {
                                    var t = this;
                                    return "string" == typeof e && (e = g.getElementById(e) || g.querySelectorAll(e)),
                                        (e = e.nodeName ? [ e ] : Array.isArray(e) ? e : Array.from(e)).forEach((function(e, i) {
                                            var l = n.default.extend(!0, {}, t.opts);
                                            if (function(e, t, i, a) {
                                                function o(t, n) {
                                                    var o = "" === a ? t : a + "-" + t;
                                                    null !== (n = void 0 !== n ? n : e.getAttribute(o)) && ("string" == typeof n && (0 === t.indexOf("on") ? n = r.default[n] : "false" === n ? n = !1 : "true" === n && (n = !0)),
                                                        i[t] = n);
                                                }
                                                if (!0 === t.importDataAttributes) {
                                                    var l, s, u, c, f = e.getAttribute(a);
                                                    if (f && "" !== f && (f = f.replace(/'/g, '"'), s = JSON.parse("{" + f + "}")),
                                                        s) for (c in u = void 0, s) if ("alias" === c.toLowerCase()) {
                                                        u = s[c];
                                                        break;
                                                    }
                                                    for (l in o("alias", u), i.alias && b(i.alias, i, t), t) {
                                                        if (s) for (c in u = void 0, s) if (c.toLowerCase() === l.toLowerCase()) {
                                                            u = s[c];
                                                            break;
                                                        }
                                                        o(l, u);
                                                    }
                                                }
                                                n.default.extend(!0, t, i), ("rtl" === e.dir || t.rightAlign) && (e.style.textAlign = "right");
                                                ("rtl" === e.dir || t.numericInput) && (e.dir = "ltr", e.removeAttribute("dir"),
                                                    t.isRTL = !0);
                                                return Object.keys(i).length;
                                            }(e, l, n.default.extend(!0, {}, t.userOptions), t.dataAttribute)) {
                                                var s = (0, o.generateMaskSet)(l, t.noMasksCache);
                                                void 0 !== s && (void 0 !== e.inputmask && (e.inputmask.opts.autoUnmask = !0, e.inputmask.remove()),
                                                    e.inputmask = new y(void 0, void 0, !0), e.inputmask.opts = l, e.inputmask.noMasksCache = t.noMasksCache,
                                                    e.inputmask.userOptions = n.default.extend(!0, {}, t.userOptions), e.inputmask.el = e,
                                                    e.inputmask.$el = (0, n.default)(e), e.inputmask.maskset = s, n.default.data(e, k, t.userOptions),
                                                    a.mask.call(e.inputmask));
                                            }
                                        })), e && e[0] && e[0].inputmask || this;
                                },
                                option: function(e, t) {
                                    return "string" == typeof e ? this.opts[e] : "object" === v(e) ? (n.default.extend(this.userOptions, e),
                                    this.el && !0 !== t && this.mask(this.el), this) : void 0;
                                },
                                unmaskedvalue: function(e) {
                                    if (this.maskset = this.maskset || (0, o.generateMaskSet)(this.opts, this.noMasksCache),
                                    void 0 === this.el || void 0 !== e) {
                                        var t = ("function" == typeof this.opts.onBeforeMask && this.opts.onBeforeMask.call(this, e, this.opts) || e).split("");
                                        c.checkVal.call(this, void 0, !1, !1, t), "function" == typeof this.opts.onBeforeWrite && this.opts.onBeforeWrite.call(this, void 0, s.getBuffer.call(this), 0, this.opts);
                                    }
                                    return c.unmaskedvalue.call(this, this.el);
                                },
                                remove: function() {
                                    if (this.el) {
                                        n.default.data(this.el, k, null);
                                        var e = this.opts.autoUnmask ? (0, c.unmaskedvalue)(this.el) : this._valueGet(this.opts.autoUnmask);
                                        e !== s.getBufferTemplate.call(this).join("") ? this._valueSet(e, this.opts.autoUnmask) : this._valueSet(""),
                                            f.EventRuler.off(this.el), Object.getOwnPropertyDescriptor && Object.getPrototypeOf ? Object.getOwnPropertyDescriptor(Object.getPrototypeOf(this.el), "value") && this.__valueGet && Object.defineProperty(this.el, "value", {
                                            get: this.__valueGet,
                                            set: this.__valueSet,
                                            configurable: !0
                                        }) : g.__lookupGetter__ && this.el.__lookupGetter__("value") && this.__valueGet && (this.el.__defineGetter__("value", this.__valueGet),
                                            this.el.__defineSetter__("value", this.__valueSet)), this.el.inputmask = void 0;
                                    }
                                    return this.el;
                                },
                                getemptymask: function() {
                                    return this.maskset = this.maskset || (0, o.generateMaskSet)(this.opts, this.noMasksCache),
                                        s.getBufferTemplate.call(this).join("");
                                },
                                hasMaskedValue: function() {
                                    return !this.opts.autoUnmask;
                                },
                                isComplete: function() {
                                    return this.maskset = this.maskset || (0, o.generateMaskSet)(this.opts, this.noMasksCache),
                                        u.isComplete.call(this, s.getBuffer.call(this));
                                },
                                getmetadata: function() {
                                    if (this.maskset = this.maskset || (0, o.generateMaskSet)(this.opts, this.noMasksCache),
                                        Array.isArray(this.maskset.metadata)) {
                                        var e = l.getMaskTemplate.call(this, !0, 0, !1).join("");
                                        return this.maskset.metadata.forEach((function(t) {
                                            return t.mask !== e || (e = t, !1);
                                        })), e;
                                    }
                                    return this.maskset.metadata;
                                },
                                isValid: function(e) {
                                    if (this.maskset = this.maskset || (0, o.generateMaskSet)(this.opts, this.noMasksCache),
                                        e) {
                                        var t = ("function" == typeof this.opts.onBeforeMask && this.opts.onBeforeMask.call(this, e, this.opts) || e).split("");
                                        c.checkVal.call(this, void 0, !0, !1, t);
                                    } else e = this.isRTL ? s.getBuffer.call(this).slice().reverse().join("") : s.getBuffer.call(this).join("");
                                    for (var i = s.getBuffer.call(this), a = s.determineLastRequiredPosition.call(this), n = i.length - 1; n > a && !s.isMask.call(this, n); n--) ;
                                    return i.splice(a, n + 1 - a), u.isComplete.call(this, i) && e === (this.isRTL ? s.getBuffer.call(this).slice().reverse().join("") : s.getBuffer.call(this).join(""));
                                },
                                format: function(e, t) {
                                    this.maskset = this.maskset || (0, o.generateMaskSet)(this.opts, this.noMasksCache);
                                    var i = ("function" == typeof this.opts.onBeforeMask && this.opts.onBeforeMask.call(this, e, this.opts) || e).split("");
                                    c.checkVal.call(this, void 0, !0, !1, i);
                                    var a = this.isRTL ? s.getBuffer.call(this).slice().reverse().join("") : s.getBuffer.call(this).join("");
                                    return t ? {
                                        value: a,
                                        metadata: this.getmetadata()
                                    } : a;
                                },
                                setValue: function(e) {
                                    this.el && (0, n.default)(this.el).trigger("setvalue", [ e ]);
                                },
                                analyseMask: o.analyseMask
                            }, y.extendDefaults = function(e) {
                                n.default.extend(!0, y.prototype.defaults, e);
                            }, y.extendDefinitions = function(e) {
                                n.default.extend(!0, y.prototype.definitions, e);
                            }, y.extendAliases = function(e) {
                                n.default.extend(!0, y.prototype.aliases, e);
                            }, y.format = function(e, t, i) {
                                return y(t).format(e, i);
                            }, y.unmask = function(e, t) {
                                return y(t).unmaskedvalue(e);
                            }, y.isValid = function(e, t) {
                                return y(t).isValid(e);
                            }, y.remove = function(e) {
                                "string" == typeof e && (e = g.getElementById(e) || g.querySelectorAll(e)), (e = e.nodeName ? [ e ] : e).forEach((function(e) {
                                    e.inputmask && e.inputmask.remove();
                                }));
                            }, y.setValue = function(e, t) {
                                "string" == typeof e && (e = g.getElementById(e) || g.querySelectorAll(e)), (e = e.nodeName ? [ e ] : e).forEach((function(e) {
                                    e.inputmask ? e.inputmask.setValue(t) : (0, n.default)(e).trigger("setvalue", [ t ]);
                                }));
                            }, y.dependencyLib = n.default, r.default.Inputmask = y;
                            var x = y;
                            t.default = x;
                        },
                        5296: function(e, t, i) {
                            function a(e) {
                                return a = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                                    return typeof e;
                                } : function(e) {
                                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
                                }, a(e);
                            }
                            var n = h(i(9380)), r = h(i(2394)), o = h(i(8741));
                            function l(e, t) {
                                for (var i = 0; i < t.length; i++) {
                                    var a = t[i];
                                    a.enumerable = a.enumerable || !1, a.configurable = !0, "value" in a && (a.writable = !0),
                                        Object.defineProperty(e, a.key, a);
                                }
                            }
                            function s(e, t) {
                                if (t && ("object" === a(t) || "function" == typeof t)) return t;
                                if (void 0 !== t) throw new TypeError("Derived constructors may only return object or undefined");
                                return function(e) {
                                    if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                                    return e;
                                }(e);
                            }
                            function u(e) {
                                var t = "function" == typeof Map ? new Map : void 0;
                                return u = function(e) {
                                    if (null === e || (i = e, -1 === Function.toString.call(i).indexOf("[native code]"))) return e;
                                    var i;
                                    if ("function" != typeof e) throw new TypeError("Super expression must either be null or a function");
                                    if (void 0 !== t) {
                                        if (t.has(e)) return t.get(e);
                                        t.set(e, a);
                                    }
                                    function a() {
                                        return c(e, arguments, p(this).constructor);
                                    }
                                    return a.prototype = Object.create(e.prototype, {
                                        constructor: {
                                            value: a,
                                            enumerable: !1,
                                            writable: !0,
                                            configurable: !0
                                        }
                                    }), d(a, e);
                                }, u(e);
                            }
                            function c(e, t, i) {
                                return c = f() ? Reflect.construct : function(e, t, i) {
                                    var a = [ null ];
                                    a.push.apply(a, t);
                                    var n = new (Function.bind.apply(e, a));
                                    return i && d(n, i.prototype), n;
                                }, c.apply(null, arguments);
                            }
                            function f() {
                                if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                                if (Reflect.construct.sham) return !1;
                                if ("function" == typeof Proxy) return !0;
                                try {
                                    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))),
                                        !0;
                                } catch (e) {
                                    return !1;
                                }
                            }
                            function d(e, t) {
                                return d = Object.setPrototypeOf || function(e, t) {
                                    return e.__proto__ = t, e;
                                }, d(e, t);
                            }
                            function p(e) {
                                return p = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
                                    return e.__proto__ || Object.getPrototypeOf(e);
                                }, p(e);
                            }
                            function h(e) {
                                return e && e.__esModule ? e : {
                                    default: e
                                };
                            }
                            var v = n.default.document;
                            if (o.default && v && v.head && v.head.attachShadow && n.default.customElements && void 0 === n.default.customElements.get("input-mask")) {
                                var m = function(e) {
                                    !function(e, t) {
                                        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                                        Object.defineProperty(e, "prototype", {
                                            value: Object.create(t && t.prototype, {
                                                constructor: {
                                                    value: e,
                                                    writable: !0,
                                                    configurable: !0
                                                }
                                            }),
                                            writable: !1
                                        }), t && d(e, t);
                                    }(c, e);
                                    var t, i, a, n, o, u = (t = c, i = f(), function() {
                                        var e, a = p(t);
                                        if (i) {
                                            var n = p(this).constructor;
                                            e = Reflect.construct(a, arguments, n);
                                        } else e = a.apply(this, arguments);
                                        return s(this, e);
                                    });
                                    function c() {
                                        var e;
                                        !function(e, t) {
                                            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
                                        }(this, c);
                                        var t = (e = u.call(this)).getAttributeNames(), i = e.attachShadow({
                                            mode: "closed"
                                        }), a = v.createElement("input");
                                        for (var n in a.type = "text", i.appendChild(a), t) Object.prototype.hasOwnProperty.call(t, n) && a.setAttribute(t[n], e.getAttribute(t[n]));
                                        var o = new r.default;
                                        return o.dataAttribute = "", o.mask(a), a.inputmask.shadowRoot = i, e;
                                    }
                                    return a = c, n && l(a.prototype, n), o && l(a, o), Object.defineProperty(a, "prototype", {
                                        writable: !1
                                    }), a;
                                }(u(HTMLElement));
                                n.default.customElements.define("input-mask", m);
                            }
                        },
                        2391: function(e, t, i) {
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            }), t.analyseMask = function(e, t, i) {
                                var a, o, l, s, u, c, f = /(?:[?*+]|\{[0-9+*]+(?:,[0-9+*]*)?(?:\|[0-9+*]*)?\})|[^.?*+^${[]()|\\]+|./g, d = /\[\^?]?(?:[^\\\]]+|\\[\S\s]?)*]?|\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9][0-9]*|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|c[A-Za-z]|[\S\s]?)|\((?:\?[:=!]?)?|(?:[?*+]|\{[0-9]+(?:,[0-9]*)?\})\??|[^.?*+^${[()|\\]+|./g, p = !1, h = new n.default, v = [], m = [], g = !1;
                                function k(e, a, n) {
                                    n = void 0 !== n ? n : e.matches.length;
                                    var o = e.matches[n - 1];
                                    if (t) 0 === a.indexOf("[") || p && /\\d|\\s|\\w/i.test(a) || "." === a ? e.matches.splice(n++, 0, {
                                        fn: new RegExp(a, i.casing ? "i" : ""),
                                        static: !1,
                                        optionality: !1,
                                        newBlockMarker: void 0 === o ? "master" : o.def !== a,
                                        casing: null,
                                        def: a,
                                        placeholder: void 0,
                                        nativeDef: a
                                    }) : (p && (a = a[a.length - 1]), a.split("").forEach((function(t, a) {
                                        o = e.matches[n - 1], e.matches.splice(n++, 0, {
                                            fn: /[a-z]/i.test(i.staticDefinitionSymbol || t) ? new RegExp("[" + (i.staticDefinitionSymbol || t) + "]", i.casing ? "i" : "") : null,
                                            static: !0,
                                            optionality: !1,
                                            newBlockMarker: void 0 === o ? "master" : o.def !== t && !0 !== o.static,
                                            casing: null,
                                            def: i.staticDefinitionSymbol || t,
                                            placeholder: void 0 !== i.staticDefinitionSymbol ? t : void 0,
                                            nativeDef: (p ? "'" : "") + t
                                        });
                                    }))), p = !1; else {
                                        var l = i.definitions && i.definitions[a] || i.usePrototypeDefinitions && r.default.prototype.definitions[a];
                                        l && !p ? e.matches.splice(n++, 0, {
                                            fn: l.validator ? "string" == typeof l.validator ? new RegExp(l.validator, i.casing ? "i" : "") : new function() {
                                                this.test = l.validator;
                                            } : new RegExp("."),
                                            static: l.static || !1,
                                            optionality: l.optional || !1,
                                            newBlockMarker: void 0 === o || l.optional ? "master" : o.def !== (l.definitionSymbol || a),
                                            casing: l.casing,
                                            def: l.definitionSymbol || a,
                                            placeholder: l.placeholder,
                                            nativeDef: a,
                                            generated: l.generated
                                        }) : (e.matches.splice(n++, 0, {
                                            fn: /[a-z]/i.test(i.staticDefinitionSymbol || a) ? new RegExp("[" + (i.staticDefinitionSymbol || a) + "]", i.casing ? "i" : "") : null,
                                            static: !0,
                                            optionality: !1,
                                            newBlockMarker: void 0 === o ? "master" : o.def !== a && !0 !== o.static,
                                            casing: null,
                                            def: i.staticDefinitionSymbol || a,
                                            placeholder: void 0 !== i.staticDefinitionSymbol ? a : void 0,
                                            nativeDef: (p ? "'" : "") + a
                                        }), p = !1);
                                    }
                                }
                                function y() {
                                    if (v.length > 0) {
                                        if (k(s = v[v.length - 1], o), s.isAlternator) {
                                            u = v.pop();
                                            for (var e = 0; e < u.matches.length; e++) u.matches[e].isGroup && (u.matches[e].isGroup = !1);
                                            v.length > 0 ? (s = v[v.length - 1]).matches.push(u) : h.matches.push(u);
                                        }
                                    } else k(h, o);
                                }
                                function b(e) {
                                    var t = new n.default(!0);
                                    return t.openGroup = !1, t.matches = e, t;
                                }
                                function x() {
                                    if ((l = v.pop()).openGroup = !1, void 0 !== l) if (v.length > 0) {
                                        if ((s = v[v.length - 1]).matches.push(l), s.isAlternator) {
                                            for (var e = (u = v.pop()).matches[0].matches ? u.matches[0].matches.length : 1, t = 0; t < u.matches.length; t++) u.matches[t].isGroup = !1,
                                                u.matches[t].alternatorGroup = !1, null === i.keepStatic && e < (u.matches[t].matches ? u.matches[t].matches.length : 1) && (i.keepStatic = !0),
                                                e = u.matches[t].matches ? u.matches[t].matches.length : 1;
                                            v.length > 0 ? (s = v[v.length - 1]).matches.push(u) : h.matches.push(u);
                                        }
                                    } else h.matches.push(l); else y();
                                }
                                function P(e) {
                                    var t = e.pop();
                                    return t.isQuantifier && (t = b([ e.pop(), t ])), t;
                                }
                                t && (i.optionalmarker[0] = void 0, i.optionalmarker[1] = void 0);
                                for (;a = t ? d.exec(e) : f.exec(e); ) {
                                    if (o = a[0], t) {
                                        switch (o.charAt(0)) {
                                            case "?":
                                                o = "{0,1}";
                                                break;

                                            case "+":
                                            case "*":
                                                o = "{" + o + "}";
                                                break;

                                            case "|":
                                                if (0 === v.length) {
                                                    var E = b(h.matches);
                                                    E.openGroup = !0, v.push(E), h.matches = [], g = !0;
                                                }
                                        }
                                        if ("\\d" === o) o = "[0-9]";
                                    }
                                    if (p) y(); else switch (o.charAt(0)) {
                                        case "$":
                                        case "^":
                                            t || y();
                                            break;

                                        case i.escapeChar:
                                            p = !0, t && y();
                                            break;

                                        case i.optionalmarker[1]:
                                        case i.groupmarker[1]:
                                            x();
                                            break;

                                        case i.optionalmarker[0]:
                                            v.push(new n.default(!1, !0));
                                            break;

                                        case i.groupmarker[0]:
                                            v.push(new n.default(!0));
                                            break;

                                        case i.quantifiermarker[0]:
                                            var S = new n.default(!1, !1, !0), _ = (o = o.replace(/[{}?]/g, "")).split("|"), w = _[0].split(","), M = isNaN(w[0]) ? w[0] : parseInt(w[0]), O = 1 === w.length ? M : isNaN(w[1]) ? w[1] : parseInt(w[1]), T = isNaN(_[1]) ? _[1] : parseInt(_[1]);
                                            "*" !== M && "+" !== M || (M = "*" === O ? 0 : 1), S.quantifier = {
                                                min: M,
                                                max: O,
                                                jit: T
                                            };
                                            var C = v.length > 0 ? v[v.length - 1].matches : h.matches;
                                            if ((a = C.pop()).isAlternator) {
                                                C.push(a), C = a.matches;
                                                var A = new n.default(!0), D = C.pop();
                                                C.push(A), C = A.matches, a = D;
                                            }
                                            a.isGroup || (a = b([ a ])), C.push(a), C.push(S);
                                            break;

                                        case i.alternatormarker:
                                            if (v.length > 0) {
                                                var j = (s = v[v.length - 1]).matches[s.matches.length - 1];
                                                c = s.openGroup && (void 0 === j.matches || !1 === j.isGroup && !1 === j.isAlternator) ? v.pop() : P(s.matches);
                                            } else c = P(h.matches);
                                            if (c.isAlternator) v.push(c); else if (c.alternatorGroup ? (u = v.pop(), c.alternatorGroup = !1) : u = new n.default(!1, !1, !1, !0),
                                                u.matches.push(c), v.push(u), c.openGroup) {
                                                c.openGroup = !1;
                                                var B = new n.default(!0);
                                                B.alternatorGroup = !0, v.push(B);
                                            }
                                            break;

                                        default:
                                            y();
                                    }
                                }
                                g && x();
                                for (;v.length > 0; ) l = v.pop(), h.matches.push(l);
                                h.matches.length > 0 && (!function e(a) {
                                    a && a.matches && a.matches.forEach((function(n, r) {
                                        var o = a.matches[r + 1];
                                        (void 0 === o || void 0 === o.matches || !1 === o.isQuantifier) && n && n.isGroup && (n.isGroup = !1,
                                        t || (k(n, i.groupmarker[0], 0), !0 !== n.openGroup && k(n, i.groupmarker[1]))),
                                            e(n);
                                    }));
                                }(h), m.push(h));
                                (i.numericInput || i.isRTL) && function e(t) {
                                    for (var a in t.matches = t.matches.reverse(), t.matches) if (Object.prototype.hasOwnProperty.call(t.matches, a)) {
                                        var n = parseInt(a);
                                        if (t.matches[a].isQuantifier && t.matches[n + 1] && t.matches[n + 1].isGroup) {
                                            var r = t.matches[a];
                                            t.matches.splice(a, 1), t.matches.splice(n + 1, 0, r);
                                        }
                                        void 0 !== t.matches[a].matches ? t.matches[a] = e(t.matches[a]) : t.matches[a] = ((o = t.matches[a]) === i.optionalmarker[0] ? o = i.optionalmarker[1] : o === i.optionalmarker[1] ? o = i.optionalmarker[0] : o === i.groupmarker[0] ? o = i.groupmarker[1] : o === i.groupmarker[1] && (o = i.groupmarker[0]),
                                            o);
                                    }
                                    var o;
                                    return t;
                                }(m[0]);
                                return m;
                            }, t.generateMaskSet = function(e, t) {
                                var i;
                                function n(e, i, n) {
                                    var o, l, s = !1;
                                    if (null !== e && "" !== e || ((s = null !== n.regex) ? e = (e = n.regex).replace(/^(\^)(.*)(\$)$/, "$2") : (s = !0,
                                        e = ".*")), 1 === e.length && !1 === n.greedy && 0 !== n.repeat && (n.placeholder = ""),
                                    n.repeat > 0 || "*" === n.repeat || "+" === n.repeat) {
                                        var u = "*" === n.repeat ? 0 : "+" === n.repeat ? 1 : n.repeat;
                                        e = n.groupmarker[0] + e + n.groupmarker[1] + n.quantifiermarker[0] + u + "," + n.repeat + n.quantifiermarker[1];
                                    }
                                    return l = s ? "regex_" + n.regex : n.numericInput ? e.split("").reverse().join("") : e,
                                    null !== n.keepStatic && (l = "ks_" + n.keepStatic + l), void 0 === r.default.prototype.masksCache[l] || !0 === t ? (o = {
                                        mask: e,
                                        maskToken: r.default.prototype.analyseMask(e, s, n),
                                        validPositions: {},
                                        _buffer: void 0,
                                        buffer: void 0,
                                        tests: {},
                                        excludes: {},
                                        metadata: i,
                                        maskLength: void 0,
                                        jitOffset: {}
                                    }, !0 !== t && (r.default.prototype.masksCache[l] = o, o = a.default.extend(!0, {}, r.default.prototype.masksCache[l]))) : o = a.default.extend(!0, {}, r.default.prototype.masksCache[l]),
                                        o;
                                }
                                "function" == typeof e.mask && (e.mask = e.mask(e));
                                if (Array.isArray(e.mask)) {
                                    if (e.mask.length > 1) {
                                        null === e.keepStatic && (e.keepStatic = !0);
                                        var o = e.groupmarker[0];
                                        return (e.isRTL ? e.mask.reverse() : e.mask).forEach((function(t) {
                                            o.length > 1 && (o += e.alternatormarker), void 0 !== t.mask && "function" != typeof t.mask ? o += t.mask : o += t;
                                        })), n(o += e.groupmarker[1], e.mask, e);
                                    }
                                    e.mask = e.mask.pop();
                                }
                                i = e.mask && void 0 !== e.mask.mask && "function" != typeof e.mask.mask ? n(e.mask.mask, e.mask, e) : n(e.mask, e.mask, e);
                                null === e.keepStatic && (e.keepStatic = !1);
                                return i;
                            };
                            var a = o(i(4963)), n = o(i(9695)), r = o(i(2394));
                            function o(e) {
                                return e && e.__esModule ? e : {
                                    default: e
                                };
                            }
                        },
                        157: function(e, t, i) {
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            }), t.mask = function() {
                                var e = this, t = this.opts, i = this.el, a = this.dependencyLib;
                                l.EventRuler.off(i);
                                var f = function(t, i) {
                                    "textarea" !== t.tagName.toLowerCase() && i.ignorables.push(n.default.ENTER);
                                    var s = t.getAttribute("type"), u = "input" === t.tagName.toLowerCase() && i.supportsInputType.includes(s) || t.isContentEditable || "textarea" === t.tagName.toLowerCase();
                                    if (!u) if ("input" === t.tagName.toLowerCase()) {
                                        var c = document.createElement("input");
                                        c.setAttribute("type", s), u = "text" === c.type, c = null;
                                    } else u = "partial";
                                    return !1 !== u ? function(t) {
                                        var n, s;
                                        function u() {
                                            return this.inputmask ? this.inputmask.opts.autoUnmask ? this.inputmask.unmaskedvalue() : -1 !== r.getLastValidPosition.call(e) || !0 !== i.nullable ? (this.inputmask.shadowRoot || this.ownerDocument).activeElement === this && i.clearMaskOnLostFocus ? (e.isRTL ? o.clearOptionalTail.call(e, r.getBuffer.call(e).slice()).reverse() : o.clearOptionalTail.call(e, r.getBuffer.call(e).slice())).join("") : n.call(this) : "" : n.call(this);
                                        }
                                        function c(e) {
                                            s.call(this, e), this.inputmask && (0, o.applyInputValue)(this, e);
                                        }
                                        if (!t.inputmask.__valueGet) {
                                            if (!0 !== i.noValuePatching) {
                                                if (Object.getOwnPropertyDescriptor) {
                                                    var f = Object.getPrototypeOf ? Object.getOwnPropertyDescriptor(Object.getPrototypeOf(t), "value") : void 0;
                                                    f && f.get && f.set ? (n = f.get, s = f.set, Object.defineProperty(t, "value", {
                                                        get: u,
                                                        set: c,
                                                        configurable: !0
                                                    })) : "input" !== t.tagName.toLowerCase() && (n = function() {
                                                        return this.textContent;
                                                    }, s = function(e) {
                                                        this.textContent = e;
                                                    }, Object.defineProperty(t, "value", {
                                                        get: u,
                                                        set: c,
                                                        configurable: !0
                                                    }));
                                                } else document.__lookupGetter__ && t.__lookupGetter__("value") && (n = t.__lookupGetter__("value"),
                                                    s = t.__lookupSetter__("value"), t.__defineGetter__("value", u), t.__defineSetter__("value", c));
                                                t.inputmask.__valueGet = n, t.inputmask.__valueSet = s;
                                            }
                                            t.inputmask._valueGet = function(t) {
                                                return e.isRTL && !0 !== t ? n.call(this.el).split("").reverse().join("") : n.call(this.el);
                                            }, t.inputmask._valueSet = function(t, i) {
                                                s.call(this.el, null == t ? "" : !0 !== i && e.isRTL ? t.split("").reverse().join("") : t);
                                            }, void 0 === n && (n = function() {
                                                return this.value;
                                            }, s = function(e) {
                                                this.value = e;
                                            }, function(t) {
                                                if (a.valHooks && (void 0 === a.valHooks[t] || !0 !== a.valHooks[t].inputmaskpatch)) {
                                                    var n = a.valHooks[t] && a.valHooks[t].get ? a.valHooks[t].get : function(e) {
                                                        return e.value;
                                                    }, l = a.valHooks[t] && a.valHooks[t].set ? a.valHooks[t].set : function(e, t) {
                                                        return e.value = t, e;
                                                    };
                                                    a.valHooks[t] = {
                                                        get: function(t) {
                                                            if (t.inputmask) {
                                                                if (t.inputmask.opts.autoUnmask) return t.inputmask.unmaskedvalue();
                                                                var a = n(t);
                                                                return -1 !== r.getLastValidPosition.call(e, void 0, void 0, t.inputmask.maskset.validPositions) || !0 !== i.nullable ? a : "";
                                                            }
                                                            return n(t);
                                                        },
                                                        set: function(e, t) {
                                                            var i = l(e, t);
                                                            return e.inputmask && (0, o.applyInputValue)(e, t), i;
                                                        },
                                                        inputmaskpatch: !0
                                                    };
                                                }
                                            }(t.type), function(t) {
                                                l.EventRuler.on(t, "mouseenter", (function() {
                                                    var t = this.inputmask._valueGet(!0);
                                                    t !== (e.isRTL ? r.getBuffer.call(e).reverse() : r.getBuffer.call(e)).join("") && (0,
                                                        o.applyInputValue)(this, t);
                                                }));
                                            }(t));
                                        }
                                    }(t) : t.inputmask = void 0, u;
                                }(i, t);
                                if (!1 !== f) {
                                    e.originalPlaceholder = i.placeholder, e.maxLength = void 0 !== i ? i.maxLength : void 0,
                                    -1 === e.maxLength && (e.maxLength = void 0), "inputMode" in i && null === i.getAttribute("inputmode") && (i.inputMode = t.inputmode,
                                        i.setAttribute("inputmode", t.inputmode)), !0 === f && (t.showMaskOnFocus = t.showMaskOnFocus && -1 === [ "cc-number", "cc-exp" ].indexOf(i.autocomplete),
                                    s.iphone && (t.insertModeVisual = !1), l.EventRuler.on(i, "submit", c.EventHandlers.submitEvent),
                                        l.EventRuler.on(i, "reset", c.EventHandlers.resetEvent), l.EventRuler.on(i, "blur", c.EventHandlers.blurEvent),
                                        l.EventRuler.on(i, "focus", c.EventHandlers.focusEvent), l.EventRuler.on(i, "invalid", c.EventHandlers.invalidEvent),
                                        l.EventRuler.on(i, "click", c.EventHandlers.clickEvent), l.EventRuler.on(i, "mouseleave", c.EventHandlers.mouseleaveEvent),
                                        l.EventRuler.on(i, "mouseenter", c.EventHandlers.mouseenterEvent), l.EventRuler.on(i, "paste", c.EventHandlers.pasteEvent),
                                        l.EventRuler.on(i, "cut", c.EventHandlers.cutEvent), l.EventRuler.on(i, "complete", t.oncomplete),
                                        l.EventRuler.on(i, "incomplete", t.onincomplete), l.EventRuler.on(i, "cleared", t.oncleared),
                                    !0 !== t.inputEventOnly && (l.EventRuler.on(i, "keydown", c.EventHandlers.keydownEvent),
                                        l.EventRuler.on(i, "keypress", c.EventHandlers.keypressEvent), l.EventRuler.on(i, "keyup", c.EventHandlers.keyupEvent)),
                                    (s.mobile || t.inputEventOnly) && i.removeAttribute("maxLength"), l.EventRuler.on(i, "input", c.EventHandlers.inputFallBackEvent),
                                        l.EventRuler.on(i, "compositionend", c.EventHandlers.compositionendEvent)), l.EventRuler.on(i, "setvalue", c.EventHandlers.setValueEvent),
                                        r.getBufferTemplate.call(e).join(""), e.undoValue = e._valueGet(!0);
                                    var d = (i.inputmask.shadowRoot || i.ownerDocument).activeElement;
                                    if ("" !== i.inputmask._valueGet(!0) || !1 === t.clearMaskOnLostFocus || d === i) {
                                        (0, o.applyInputValue)(i, i.inputmask._valueGet(!0), t);
                                        var p = r.getBuffer.call(e).slice();
                                        !1 === u.isComplete.call(e, p) && t.clearIncomplete && r.resetMaskSet.call(e), t.clearMaskOnLostFocus && d !== i && (-1 === r.getLastValidPosition.call(e) ? p = [] : o.clearOptionalTail.call(e, p)),
                                        (!1 === t.clearMaskOnLostFocus || t.showMaskOnFocus && d === i || "" !== i.inputmask._valueGet(!0)) && (0,
                                            o.writeBuffer)(i, p), d === i && r.caret.call(e, i, r.seekNext.call(e, r.getLastValidPosition.call(e)));
                                    }
                                }
                            };
                            var a, n = (a = i(5581)) && a.__esModule ? a : {
                                default: a
                            }, r = i(8711), o = i(7760), l = i(9716), s = i(9845), u = i(7215), c = i(6030);
                        },
                        9695: function(e, t) {
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            }), t.default = function(e, t, i, a) {
                                this.matches = [], this.openGroup = e || !1, this.alternatorGroup = !1, this.isGroup = e || !1,
                                    this.isOptional = t || !1, this.isQuantifier = i || !1, this.isAlternator = a || !1,
                                    this.quantifier = {
                                        min: 1,
                                        max: 1
                                    };
                            };
                        },
                        3194: function() {
                            Array.prototype.includes || Object.defineProperty(Array.prototype, "includes", {
                                value: function(e, t) {
                                    if (null == this) throw new TypeError('"this" is null or not defined');
                                    var i = Object(this), a = i.length >>> 0;
                                    if (0 === a) return !1;
                                    for (var n = 0 | t, r = Math.max(n >= 0 ? n : a - Math.abs(n), 0); r < a; ) {
                                        if (i[r] === e) return !0;
                                        r++;
                                    }
                                    return !1;
                                }
                            });
                        },
                        7149: function() {
                            function e(t) {
                                return e = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                                    return typeof e;
                                } : function(e) {
                                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
                                }, e(t);
                            }
                            "function" != typeof Object.getPrototypeOf && (Object.getPrototypeOf = "object" === e("test".__proto__) ? function(e) {
                                return e.__proto__;
                            } : function(e) {
                                return e.constructor.prototype;
                            });
                        },
                        8711: function(e, t, i) {
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            }), t.caret = function(e, t, i, a, n) {
                                var r, o = this, l = this.opts;
                                if (void 0 === t) return "selectionStart" in e && "selectionEnd" in e ? (t = e.selectionStart,
                                    i = e.selectionEnd) : window.getSelection ? (r = window.getSelection().getRangeAt(0)).commonAncestorContainer.parentNode !== e && r.commonAncestorContainer !== e || (t = r.startOffset,
                                    i = r.endOffset) : document.selection && document.selection.createRange && (r = document.selection.createRange(),
                                    t = 0 - r.duplicate().moveStart("character", -e.inputmask._valueGet().length), i = t + r.text.length),
                                    {
                                        begin: a ? t : u.call(o, t),
                                        end: a ? i : u.call(o, i)
                                    };
                                if (Array.isArray(t) && (i = o.isRTL ? t[0] : t[1], t = o.isRTL ? t[1] : t[0]),
                                void 0 !== t.begin && (i = o.isRTL ? t.begin : t.end, t = o.isRTL ? t.end : t.begin),
                                "number" == typeof t) {
                                    t = a ? t : u.call(o, t), i = "number" == typeof (i = a ? i : u.call(o, i)) ? i : t;
                                    var s = parseInt(((e.ownerDocument.defaultView || window).getComputedStyle ? (e.ownerDocument.defaultView || window).getComputedStyle(e, null) : e.currentStyle).fontSize) * i;
                                    if (e.scrollLeft = s > e.scrollWidth ? s : 0, e.inputmask.caretPos = {
                                        begin: t,
                                        end: i
                                    }, l.insertModeVisual && !1 === l.insertMode && t === i && (n || i++), e === (e.inputmask.shadowRoot || e.ownerDocument).activeElement) if ("setSelectionRange" in e) e.setSelectionRange(t, i); else if (window.getSelection) {
                                        if (r = document.createRange(), void 0 === e.firstChild || null === e.firstChild) {
                                            var c = document.createTextNode("");
                                            e.appendChild(c);
                                        }
                                        r.setStart(e.firstChild, t < e.inputmask._valueGet().length ? t : e.inputmask._valueGet().length),
                                            r.setEnd(e.firstChild, i < e.inputmask._valueGet().length ? i : e.inputmask._valueGet().length),
                                            r.collapse(!0);
                                        var f = window.getSelection();
                                        f.removeAllRanges(), f.addRange(r);
                                    } else e.createTextRange && ((r = e.createTextRange()).collapse(!0), r.moveEnd("character", i),
                                        r.moveStart("character", t), r.select());
                                }
                            }, t.determineLastRequiredPosition = function(e) {
                                var t, i, r = this, l = this.maskset, s = this.dependencyLib, u = a.getMaskTemplate.call(r, !0, o.call(r), !0, !0), c = u.length, f = o.call(r), d = {}, p = l.validPositions[f], h = void 0 !== p ? p.locator.slice() : void 0;
                                for (t = f + 1; t < u.length; t++) i = a.getTestTemplate.call(r, t, h, t - 1), h = i.locator.slice(),
                                    d[t] = s.extend(!0, {}, i);
                                var v = p && void 0 !== p.alternation ? p.locator[p.alternation] : void 0;
                                for (t = c - 1; t > f && (((i = d[t]).match.optionality || i.match.optionalQuantifier && i.match.newBlockMarker || v && (v !== d[t].locator[p.alternation] && 1 != i.match.static || !0 === i.match.static && i.locator[p.alternation] && n.checkAlternationMatch.call(r, i.locator[p.alternation].toString().split(","), v.toString().split(",")) && "" !== a.getTests.call(r, t)[0].def)) && u[t] === a.getPlaceholder.call(r, t, i.match)); t--) c--;
                                return e ? {
                                    l: c,
                                    def: d[c] ? d[c].match : void 0
                                } : c;
                            }, t.determineNewCaretPosition = function(e, t, i) {
                                var n = this, u = this.maskset, c = this.opts;
                                t && (n.isRTL ? e.end = e.begin : e.begin = e.end);
                                if (e.begin === e.end) {
                                    switch (i = i || c.positionCaretOnClick) {
                                        case "none":
                                            break;

                                        case "select":
                                            e = {
                                                begin: 0,
                                                end: r.call(n).length
                                            };
                                            break;

                                        case "ignore":
                                            e.end = e.begin = s.call(n, o.call(n));
                                            break;

                                        case "radixFocus":
                                            if (function(e) {
                                                if ("" !== c.radixPoint && 0 !== c.digits) {
                                                    var t = u.validPositions;
                                                    if (void 0 === t[e] || t[e].input === a.getPlaceholder.call(n, e)) {
                                                        if (e < s.call(n, -1)) return !0;
                                                        var i = r.call(n).indexOf(c.radixPoint);
                                                        if (-1 !== i) {
                                                            for (var o in t) if (t[o] && i < o && t[o].input !== a.getPlaceholder.call(n, o)) return !1;
                                                            return !0;
                                                        }
                                                    }
                                                }
                                                return !1;
                                            }(e.begin)) {
                                                var f = r.call(n).join("").indexOf(c.radixPoint);
                                                e.end = e.begin = c.numericInput ? s.call(n, f) : f;
                                                break;
                                            }

                                        default:
                                            var d = e.begin, p = o.call(n, d, !0), h = s.call(n, -1 !== p || l.call(n, 0) ? p : -1);
                                            if (d <= h) e.end = e.begin = l.call(n, d, !1, !0) ? d : s.call(n, d); else {
                                                var v = u.validPositions[p], m = a.getTestTemplate.call(n, h, v ? v.match.locator : void 0, v), g = a.getPlaceholder.call(n, h, m.match);
                                                if ("" !== g && r.call(n)[h] !== g && !0 !== m.match.optionalQuantifier && !0 !== m.match.newBlockMarker || !l.call(n, h, c.keepStatic, !0) && m.match.def === g) {
                                                    var k = s.call(n, h);
                                                    (d >= k || d === h) && (h = k);
                                                }
                                                e.end = e.begin = h;
                                            }
                                    }
                                    return e;
                                }
                            }, t.getBuffer = r, t.getBufferTemplate = function() {
                                var e = this.maskset;
                                void 0 === e._buffer && (e._buffer = a.getMaskTemplate.call(this, !1, 1), void 0 === e.buffer && (e.buffer = e._buffer.slice()));
                                return e._buffer;
                            }, t.getLastValidPosition = o, t.isMask = l, t.resetMaskSet = function(e) {
                                var t = this.maskset;
                                t.buffer = void 0, !0 !== e && (t.validPositions = {}, t.p = 0);
                            }, t.seekNext = s, t.seekPrevious = function(e, t) {
                                var i = this, n = e - 1;
                                if (e <= 0) return 0;
                                for (;n > 0 && (!0 === t && (!0 !== a.getTest.call(i, n).match.newBlockMarker || !l.call(i, n, void 0, !0)) || !0 !== t && !l.call(i, n, void 0, !0)); ) n--;
                                return n;
                            }, t.translatePosition = u;
                            var a = i(4713), n = i(7215);
                            function r(e) {
                                var t = this.maskset;
                                return void 0 !== t.buffer && !0 !== e || (t.buffer = a.getMaskTemplate.call(this, !0, o.call(this), !0),
                                void 0 === t._buffer && (t._buffer = t.buffer.slice())), t.buffer;
                            }
                            function o(e, t, i) {
                                var a = this.maskset, n = -1, r = -1, o = i || a.validPositions;
                                for (var l in void 0 === e && (e = -1), o) {
                                    var s = parseInt(l);
                                    o[s] && (t || !0 !== o[s].generatedInput) && (s <= e && (n = s), s >= e && (r = s));
                                }
                                return -1 === n || n == e ? r : -1 == r || e - n < r - e ? n : r;
                            }
                            function l(e, t, i) {
                                var n = this, r = this.maskset, o = a.getTestTemplate.call(n, e).match;
                                if ("" === o.def && (o = a.getTest.call(n, e).match), !0 !== o.static) return o.fn;
                                if (!0 === i && void 0 !== r.validPositions[e] && !0 !== r.validPositions[e].generatedInput) return !0;
                                if (!0 !== t && e > -1) {
                                    if (i) {
                                        var l = a.getTests.call(n, e);
                                        return l.length > 1 + ("" === l[l.length - 1].match.def ? 1 : 0);
                                    }
                                    var s = a.determineTestTemplate.call(n, e, a.getTests.call(n, e)), u = a.getPlaceholder.call(n, e, s.match);
                                    return s.match.def !== u;
                                }
                                return !1;
                            }
                            function s(e, t, i) {
                                var n = this;
                                void 0 === i && (i = !0);
                                for (var r = e + 1; "" !== a.getTest.call(n, r).match.def && (!0 === t && (!0 !== a.getTest.call(n, r).match.newBlockMarker || !l.call(n, r, void 0, !0)) || !0 !== t && !l.call(n, r, void 0, i)); ) r++;
                                return r;
                            }
                            function u(e) {
                                var t = this.opts, i = this.el;
                                return !this.isRTL || "number" != typeof e || t.greedy && "" === t.placeholder || !i || (e = Math.abs(this._valueGet().length - e)),
                                    e;
                            }
                        },
                        4713: function(e, t, i) {
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            }), t.determineTestTemplate = u, t.getDecisionTaker = o, t.getMaskTemplate = function(e, t, i, a, n) {
                                var r = this, o = this.opts, c = this.maskset, f = o.greedy;
                                n && o.greedy && (o.greedy = !1, r.maskset.tests = {});
                                t = t || 0;
                                var p, h, v, m, g = [], k = 0;
                                do {
                                    if (!0 === e && c.validPositions[k]) v = n && c.validPositions[k].match.optionality && void 0 === c.validPositions[k + 1] && (!0 === c.validPositions[k].generatedInput || c.validPositions[k].input == o.skipOptionalPartCharacter && k > 0) ? u.call(r, k, d.call(r, k, p, k - 1)) : c.validPositions[k],
                                        h = v.match, p = v.locator.slice(), g.push(!0 === i ? v.input : !1 === i ? h.nativeDef : l.call(r, k, h)); else {
                                        v = s.call(r, k, p, k - 1), h = v.match, p = v.locator.slice();
                                        var y = !0 !== a && (!1 !== o.jitMasking ? o.jitMasking : h.jit);
                                        (m = (m && h.static && h.def !== o.groupSeparator && null === h.fn || c.validPositions[k - 1] && h.static && h.def !== o.groupSeparator && null === h.fn) && c.tests[k] && 1 === c.tests[k].length) || !1 === y || void 0 === y || "number" == typeof y && isFinite(y) && y > k ? g.push(!1 === i ? h.nativeDef : l.call(r, k, h)) : m = !1;
                                    }
                                    k++;
                                } while (!0 !== h.static || "" !== h.def || t > k);
                                "" === g[g.length - 1] && g.pop();
                                !1 === i && void 0 !== c.maskLength || (c.maskLength = k - 1);
                                return o.greedy = f, g;
                            }, t.getPlaceholder = l, t.getTest = c, t.getTestTemplate = s, t.getTests = d, t.isSubsetOf = f;
                            var a, n = (a = i(2394)) && a.__esModule ? a : {
                                default: a
                            };
                            function r(e, t) {
                                var i = (null != e.alternation ? e.mloc[o(e)] : e.locator).join("");
                                if ("" !== i) for (;i.length < t; ) i += "0";
                                return i;
                            }
                            function o(e) {
                                var t = e.locator[e.alternation];
                                return "string" == typeof t && t.length > 0 && (t = t.split(",")[0]), void 0 !== t ? t.toString() : "";
                            }
                            function l(e, t, i) {
                                var a = this.opts, n = this.maskset;
                                if (void 0 !== (t = t || c.call(this, e).match).placeholder || !0 === i) return "function" == typeof t.placeholder ? t.placeholder(a) : t.placeholder;
                                if (!0 === t.static) {
                                    if (e > -1 && void 0 === n.validPositions[e]) {
                                        var r, o = d.call(this, e), l = [];
                                        if (o.length > 1 + ("" === o[o.length - 1].match.def ? 1 : 0)) for (var s = 0; s < o.length; s++) if ("" !== o[s].match.def && !0 !== o[s].match.optionality && !0 !== o[s].match.optionalQuantifier && (!0 === o[s].match.static || void 0 === r || !1 !== o[s].match.fn.test(r.match.def, n, e, !0, a)) && (l.push(o[s]),
                                        !0 === o[s].match.static && (r = o[s]), l.length > 1 && /[0-9a-bA-Z]/.test(l[0].match.def))) return a.placeholder.charAt(e % a.placeholder.length);
                                    }
                                    return t.def;
                                }
                                return a.placeholder.charAt(e % a.placeholder.length);
                            }
                            function s(e, t, i) {
                                return this.maskset.validPositions[e] || u.call(this, e, d.call(this, e, t ? t.slice() : t, i));
                            }
                            function u(e, t) {
                                var i = this.opts, a = function(e, t) {
                                    var i = 0, a = !1;
                                    t.forEach((function(e) {
                                        e.match.optionality && (0 !== i && i !== e.match.optionality && (a = !0), (0 === i || i > e.match.optionality) && (i = e.match.optionality));
                                    })), i && (0 == e || 1 == t.length ? i = 0 : a || (i = 0));
                                    return i;
                                }(e, t);
                                e = e > 0 ? e - 1 : 0;
                                var n, o, l, s = r(c.call(this, e));
                                i.greedy && t.length > 1 && "" === t[t.length - 1].match.def && t.pop();
                                for (var u = 0; u < t.length; u++) {
                                    var f = t[u];
                                    n = r(f, s.length);
                                    var d = Math.abs(n - s);
                                    (void 0 === o || "" !== n && d < o || l && !i.greedy && l.match.optionality && l.match.optionality - a > 0 && "master" === l.match.newBlockMarker && (!f.match.optionality || f.match.optionality - a < 1 || !f.match.newBlockMarker) || l && !i.greedy && l.match.optionalQuantifier && !f.match.optionalQuantifier) && (o = d,
                                        l = f);
                                }
                                return l;
                            }
                            function c(e, t) {
                                var i = this.maskset;
                                return i.validPositions[e] ? i.validPositions[e] : (t || d.call(this, e))[0];
                            }
                            function f(e, t, i) {
                                function a(e) {
                                    for (var t, i = [], a = -1, n = 0, r = e.length; n < r; n++) if ("-" === e.charAt(n)) for (t = e.charCodeAt(n + 1); ++a < t; ) i.push(String.fromCharCode(a)); else a = e.charCodeAt(n),
                                        i.push(e.charAt(n));
                                    return i.join("");
                                }
                                return e.match.def === t.match.nativeDef || !(!(i.regex || e.match.fn instanceof RegExp && t.match.fn instanceof RegExp) || !0 === e.match.static || !0 === t.match.static) && -1 !== a(t.match.fn.toString().replace(/[[\]/]/g, "")).indexOf(a(e.match.fn.toString().replace(/[[\]/]/g, "")));
                            }
                            function d(e, t, i) {
                                var a, r, o = this, l = this.dependencyLib, s = this.maskset, c = this.opts, d = this.el, p = s.maskToken, h = t ? i : 0, v = t ? t.slice() : [ 0 ], m = [], g = !1, k = t ? t.join("") : "";
                                function y(t, i, r, o) {
                                    function l(r, o, u) {
                                        function p(e, t) {
                                            var i = 0 === t.matches.indexOf(e);
                                            return i || t.matches.every((function(a, n) {
                                                return !0 === a.isQuantifier ? i = p(e, t.matches[n - 1]) : Object.prototype.hasOwnProperty.call(a, "matches") && (i = p(e, a)),
                                                    !i;
                                            })), i;
                                        }
                                        function v(e, t, i) {
                                            var a, n;
                                            if ((s.tests[e] || s.validPositions[e]) && (s.tests[e] || [ s.validPositions[e] ]).every((function(e, r) {
                                                if (e.mloc[t]) return a = e, !1;
                                                var o = void 0 !== i ? i : e.alternation, l = void 0 !== e.locator[o] ? e.locator[o].toString().indexOf(t) : -1;
                                                return (void 0 === n || l < n) && -1 !== l && (a = e, n = l), !0;
                                            })), a) {
                                                var r = a.locator[a.alternation];
                                                return (a.mloc[t] || a.mloc[r] || a.locator).slice((void 0 !== i ? i : a.alternation) + 1);
                                            }
                                            return void 0 !== i ? v(e, t) : void 0;
                                        }
                                        function b(e, t) {
                                            var i = e.alternation, a = void 0 === t || i === t.alternation && -1 === e.locator[i].toString().indexOf(t.locator[i]);
                                            if (!a && i > t.alternation) for (var n = t.alternation; n < i; n++) if (e.locator[n] !== t.locator[n]) {
                                                i = n, a = !0;
                                                break;
                                            }
                                            if (a) {
                                                e.mloc = e.mloc || {};
                                                var r = e.locator[i];
                                                if (void 0 !== r) {
                                                    if ("string" == typeof r && (r = r.split(",")[0]), void 0 === e.mloc[r] && (e.mloc[r] = e.locator.slice()),
                                                    void 0 !== t) {
                                                        for (var o in t.mloc) "string" == typeof o && (o = o.split(",")[0]), void 0 === e.mloc[o] && (e.mloc[o] = t.mloc[o]);
                                                        e.locator[i] = Object.keys(e.mloc).join(",");
                                                    }
                                                    return !0;
                                                }
                                                e.alternation = void 0;
                                            }
                                            return !1;
                                        }
                                        function x(e, t) {
                                            if (e.locator.length !== t.locator.length) return !1;
                                            for (var i = e.alternation + 1; i < e.locator.length; i++) if (e.locator[i] !== t.locator[i]) return !1;
                                            return !0;
                                        }
                                        if (h > e + c._maxTestPos) throw "Inputmask: There is probably an error in your mask definition or in the code. Create an issue on github with an example of the mask you are using. " + s.mask;
                                        if (h === e && void 0 === r.matches) {
                                            if (m.push({
                                                match: r,
                                                locator: o.reverse(),
                                                cd: k,
                                                mloc: {}
                                            }), !r.optionality || void 0 !== u || !(c.definitions && c.definitions[r.nativeDef] && c.definitions[r.nativeDef].optional || n.default.prototype.definitions[r.nativeDef] && n.default.prototype.definitions[r.nativeDef].optional)) return !0;
                                            g = !0, h = e;
                                        } else if (void 0 !== r.matches) {
                                            if (r.isGroup && u !== r) {
                                                if (r = l(t.matches[t.matches.indexOf(r) + 1], o, u)) return !0;
                                            } else if (r.isOptional) {
                                                var P = r, E = m.length;
                                                if (r = y(r, i, o, u)) {
                                                    if (m.forEach((function(e, t) {
                                                        t >= E && (e.match.optionality = e.match.optionality ? e.match.optionality + 1 : 1);
                                                    })), a = m[m.length - 1].match, void 0 !== u || !p(a, P)) return !0;
                                                    g = !0, h = e;
                                                }
                                            } else if (r.isAlternator) {
                                                var S, _ = r, w = [], M = m.slice(), O = o.length, T = !1, C = i.length > 0 ? i.shift() : -1;
                                                if (-1 === C || "string" == typeof C) {
                                                    var A, D = h, j = i.slice(), B = [];
                                                    if ("string" == typeof C) B = C.split(","); else for (A = 0; A < _.matches.length; A++) B.push(A.toString());
                                                    if (void 0 !== s.excludes[e]) {
                                                        for (var R = B.slice(), L = 0, I = s.excludes[e].length; L < I; L++) {
                                                            var F = s.excludes[e][L].toString().split(":");
                                                            o.length == F[1] && B.splice(B.indexOf(F[0]), 1);
                                                        }
                                                        0 === B.length && (delete s.excludes[e], B = R);
                                                    }
                                                    (!0 === c.keepStatic || isFinite(parseInt(c.keepStatic)) && D >= c.keepStatic) && (B = B.slice(0, 1));
                                                    for (var N = 0; N < B.length; N++) {
                                                        A = parseInt(B[N]), m = [], i = "string" == typeof C && v(h, A, O) || j.slice();
                                                        var V = _.matches[A];
                                                        if (V && l(V, [ A ].concat(o), u)) r = !0; else if (0 === N && (T = !0), V && V.matches && V.matches.length > _.matches[0].matches.length) break;
                                                        S = m.slice(), h = D, m = [];
                                                        for (var G = 0; G < S.length; G++) {
                                                            var H = S[G], K = !1;
                                                            H.match.jit = H.match.jit || T, H.alternation = H.alternation || O, b(H);
                                                            for (var U = 0; U < w.length; U++) {
                                                                var $ = w[U];
                                                                if ("string" != typeof C || void 0 !== H.alternation && B.includes(H.locator[H.alternation].toString())) {
                                                                    if (H.match.nativeDef === $.match.nativeDef) {
                                                                        K = !0, b($, H);
                                                                        break;
                                                                    }
                                                                    if (f(H, $, c)) {
                                                                        b(H, $) && (K = !0, w.splice(w.indexOf($), 0, H));
                                                                        break;
                                                                    }
                                                                    if (f($, H, c)) {
                                                                        b($, H);
                                                                        break;
                                                                    }
                                                                    if (Z = $, !0 === (Q = H).match.static && !0 !== Z.match.static && Z.match.fn.test(Q.match.def, s, e, !1, c, !1)) {
                                                                        x(H, $) || void 0 !== d.inputmask.userOptions.keepStatic ? b(H, $) && (K = !0, w.splice(w.indexOf($), 0, H)) : c.keepStatic = !0;
                                                                        break;
                                                                    }
                                                                }
                                                            }
                                                            K || w.push(H);
                                                        }
                                                    }
                                                    m = M.concat(w), h = e, g = m.length > 0, r = w.length > 0, i = j.slice();
                                                } else r = l(_.matches[C] || t.matches[C], [ C ].concat(o), u);
                                                if (r) return !0;
                                            } else if (r.isQuantifier && u !== t.matches[t.matches.indexOf(r) - 1]) for (var q = r, z = i.length > 0 ? i.shift() : 0; z < (isNaN(q.quantifier.max) ? z + 1 : q.quantifier.max) && h <= e; z++) {
                                                var W = t.matches[t.matches.indexOf(q) - 1];
                                                if (r = l(W, [ z ].concat(o), W)) {
                                                    if ((a = m[m.length - 1].match).optionalQuantifier = z >= q.quantifier.min, a.jit = (z + 1) * (W.matches.indexOf(a) + 1) > q.quantifier.jit,
                                                    a.optionalQuantifier && p(a, W)) {
                                                        g = !0, h = e;
                                                        break;
                                                    }
                                                    return a.jit && (s.jitOffset[e] = W.matches.length - W.matches.indexOf(a)), !0;
                                                }
                                            } else if (r = y(r, i, o, u)) return !0;
                                        } else h++;
                                        var Q, Z;
                                    }
                                    for (var u = i.length > 0 ? i.shift() : 0; u < t.matches.length; u++) if (!0 !== t.matches[u].isQuantifier) {
                                        var p = l(t.matches[u], [ u ].concat(r), o);
                                        if (p && h === e) return p;
                                        if (h > e) break;
                                    }
                                }
                                if (e > -1) {
                                    if (void 0 === t) {
                                        for (var b, x = e - 1; void 0 === (b = s.validPositions[x] || s.tests[x]) && x > -1; ) x--;
                                        void 0 !== b && x > -1 && (v = function(e, t) {
                                            var i, a = [];
                                            return Array.isArray(t) || (t = [ t ]), t.length > 0 && (void 0 === t[0].alternation || !0 === c.keepStatic ? 0 === (a = u.call(o, e, t.slice()).locator.slice()).length && (a = t[0].locator.slice()) : t.forEach((function(e) {
                                                "" !== e.def && (0 === a.length ? (i = e.alternation, a = e.locator.slice()) : e.locator[i] && -1 === a[i].toString().indexOf(e.locator[i]) && (a[i] += "," + e.locator[i]));
                                            }))), a;
                                        }(x, b), k = v.join(""), h = x);
                                    }
                                    if (s.tests[e] && s.tests[e][0].cd === k) return s.tests[e];
                                    for (var P = v.shift(); P < p.length; P++) {
                                        if (y(p[P], v, [ P ]) && h === e || h > e) break;
                                    }
                                }
                                return (0 === m.length || g) && m.push({
                                    match: {
                                        fn: null,
                                        static: !0,
                                        optionality: !1,
                                        casing: null,
                                        def: "",
                                        placeholder: ""
                                    },
                                    locator: [],
                                    mloc: {},
                                    cd: k
                                }), void 0 !== t && s.tests[e] ? r = l.extend(!0, [], m) : (s.tests[e] = l.extend(!0, [], m),
                                    r = s.tests[e]), m.forEach((function(e) {
                                    e.match.optionality = !1;
                                })), r;
                            }
                        },
                        7215: function(e, t, i) {
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            }), t.alternate = s, t.checkAlternationMatch = function(e, t, i) {
                                for (var a, n = this.opts.greedy ? t : t.slice(0, 1), r = !1, o = void 0 !== i ? i.split(",") : [], l = 0; l < o.length; l++) -1 !== (a = e.indexOf(o[l])) && e.splice(a, 1);
                                for (var s = 0; s < e.length; s++) if (n.includes(e[s])) {
                                    r = !0;
                                    break;
                                }
                                return r;
                            }, t.handleRemove = function(e, t, i, a, l) {
                                var u = this, c = this.maskset, f = this.opts;
                                if ((f.numericInput || u.isRTL) && (t === r.default.BACKSPACE ? t = r.default.DELETE : t === r.default.DELETE && (t = r.default.BACKSPACE),
                                    u.isRTL)) {
                                    var d = i.end;
                                    i.end = i.begin, i.begin = d;
                                }
                                var p, h = o.getLastValidPosition.call(u, void 0, !0);
                                i.end >= o.getBuffer.call(u).length && h >= i.end && (i.end = h + 1);
                                t === r.default.BACKSPACE ? i.end - i.begin < 1 && (i.begin = o.seekPrevious.call(u, i.begin)) : t === r.default.DELETE && i.begin === i.end && (i.end = o.isMask.call(u, i.end, !0, !0) ? i.end + 1 : o.seekNext.call(u, i.end) + 1);
                                if (!1 !== (p = m.call(u, i))) {
                                    if (!0 !== a && !1 !== f.keepStatic || null !== f.regex && -1 !== n.getTest.call(u, i.begin).match.def.indexOf("|")) {
                                        var v = s.call(u, !0);
                                        if (v) {
                                            var g = void 0 !== v.caret ? v.caret : v.pos ? o.seekNext.call(u, v.pos.begin ? v.pos.begin : v.pos) : o.getLastValidPosition.call(u, -1, !0);
                                            (t !== r.default.DELETE || i.begin > g) && i.begin;
                                        }
                                    }
                                    !0 !== a && (c.p = t === r.default.DELETE ? i.begin + p : i.begin, c.p = o.determineNewCaretPosition.call(u, {
                                        begin: c.p,
                                        end: c.p
                                    }, !1, !1 === f.insertMode && t === r.default.BACKSPACE ? "none" : void 0).begin);
                                }
                            }, t.isComplete = c, t.isSelection = f, t.isValid = d, t.refreshFromBuffer = h,
                                t.revalidateMask = m;
                            var a, n = i(4713), r = (a = i(5581)) && a.__esModule ? a : {
                                default: a
                            }, o = i(8711), l = i(6030);
                            function s(e, t, i, a, r, l) {
                                var u, c, f, p, h, v, m, g, k, y, b, x = this, P = this.dependencyLib, E = this.opts, S = x.maskset, _ = P.extend(!0, {}, S.validPositions), w = P.extend(!0, {}, S.tests), M = !1, O = !1, T = void 0 !== r ? r : o.getLastValidPosition.call(x);
                                if (l && (y = l.begin, b = l.end, l.begin > l.end && (y = l.end, b = l.begin)),
                                -1 === T && void 0 === r) u = 0, c = (p = n.getTest.call(x, u)).alternation; else for (;T >= 0; T--) if ((f = S.validPositions[T]) && void 0 !== f.alternation) {
                                    if (p && p.locator[f.alternation] !== f.locator[f.alternation]) break;
                                    u = T, c = S.validPositions[u].alternation, p = f;
                                }
                                if (void 0 !== c) {
                                    m = parseInt(u), S.excludes[m] = S.excludes[m] || [], !0 !== e && S.excludes[m].push((0,
                                        n.getDecisionTaker)(p) + ":" + p.alternation);
                                    var C = [], A = -1;
                                    for (h = m; h < o.getLastValidPosition.call(x, void 0, !0) + 1; h++) -1 === A && e <= h && void 0 !== t && (C.push(t),
                                        A = C.length - 1), (v = S.validPositions[h]) && !0 !== v.generatedInput && (void 0 === l || h < y || h >= b) && C.push(v.input),
                                        delete S.validPositions[h];
                                    for (-1 === A && void 0 !== t && (C.push(t), A = C.length - 1); void 0 !== S.excludes[m] && S.excludes[m].length < 10; ) {
                                        for (S.tests = {}, o.resetMaskSet.call(x, !0), M = !0, h = 0; h < C.length && (g = M.caret || o.getLastValidPosition.call(x, void 0, !0) + 1,
                                            k = C[h], M = d.call(x, g, k, !1, a, !0)); h++) h === A && (O = M), 1 == e && M && (O = {
                                            caretPos: h
                                        });
                                        if (M) break;
                                        if (o.resetMaskSet.call(x), p = n.getTest.call(x, m), S.validPositions = P.extend(!0, {}, _),
                                            S.tests = P.extend(!0, {}, w), !S.excludes[m]) {
                                            O = s.call(x, e, t, i, a, m - 1, l);
                                            break;
                                        }
                                        var D = (0, n.getDecisionTaker)(p);
                                        if (-1 !== S.excludes[m].indexOf(D + ":" + p.alternation)) {
                                            O = s.call(x, e, t, i, a, m - 1, l);
                                            break;
                                        }
                                        for (S.excludes[m].push(D + ":" + p.alternation), h = m; h < o.getLastValidPosition.call(x, void 0, !0) + 1; h++) delete S.validPositions[h];
                                    }
                                }
                                return O && !1 === E.keepStatic || delete S.excludes[m], O;
                            }
                            function u(e, t, i) {
                                var a = this.opts, n = this.maskset;
                                switch (a.casing || t.casing) {
                                    case "upper":
                                        e = e.toUpperCase();
                                        break;

                                    case "lower":
                                        e = e.toLowerCase();
                                        break;

                                    case "title":
                                        var o = n.validPositions[i - 1];
                                        e = 0 === i || o && o.input === String.fromCharCode(r.default.SPACE) ? e.toUpperCase() : e.toLowerCase();
                                        break;

                                    default:
                                        if ("function" == typeof a.casing) {
                                            var l = Array.prototype.slice.call(arguments);
                                            l.push(n.validPositions), e = a.casing.apply(this, l);
                                        }
                                }
                                return e;
                            }
                            function c(e) {
                                var t = this, i = this.opts, a = this.maskset;
                                if ("function" == typeof i.isComplete) return i.isComplete(e, i);
                                if ("*" !== i.repeat) {
                                    var r = !1, l = o.determineLastRequiredPosition.call(t, !0), s = o.seekPrevious.call(t, l.l);
                                    if (void 0 === l.def || l.def.newBlockMarker || l.def.optionality || l.def.optionalQuantifier) {
                                        r = !0;
                                        for (var u = 0; u <= s; u++) {
                                            var c = n.getTestTemplate.call(t, u).match;
                                            if (!0 !== c.static && void 0 === a.validPositions[u] && !0 !== c.optionality && !0 !== c.optionalQuantifier || !0 === c.static && e[u] !== n.getPlaceholder.call(t, u, c)) {
                                                r = !1;
                                                break;
                                            }
                                        }
                                    }
                                    return r;
                                }
                            }
                            function f(e) {
                                var t = this.opts.insertMode ? 0 : 1;
                                return this.isRTL ? e.begin - e.end > t : e.end - e.begin > t;
                            }
                            function d(e, t, i, a, r, l, p) {
                                var g = this, k = this.dependencyLib, y = this.opts, b = g.maskset;
                                i = !0 === i;
                                var x = e;
                                function P(e) {
                                    if (void 0 !== e) {
                                        if (void 0 !== e.remove && (Array.isArray(e.remove) || (e.remove = [ e.remove ]),
                                            e.remove.sort((function(e, t) {
                                                return t.pos - e.pos;
                                            })).forEach((function(e) {
                                                m.call(g, {
                                                    begin: e,
                                                    end: e + 1
                                                });
                                            })), e.remove = void 0), void 0 !== e.insert && (Array.isArray(e.insert) || (e.insert = [ e.insert ]),
                                            e.insert.sort((function(e, t) {
                                                return e.pos - t.pos;
                                            })).forEach((function(e) {
                                                "" !== e.c && d.call(g, e.pos, e.c, void 0 === e.strict || e.strict, void 0 !== e.fromIsValid ? e.fromIsValid : a);
                                            })), e.insert = void 0), e.refreshFromBuffer && e.buffer) {
                                            var t = e.refreshFromBuffer;
                                            h.call(g, !0 === t ? t : t.start, t.end, e.buffer), e.refreshFromBuffer = void 0;
                                        }
                                        void 0 !== e.rewritePosition && (x = e.rewritePosition, e = !0);
                                    }
                                    return e;
                                }
                                function E(t, i, r) {
                                    var l = !1;
                                    return n.getTests.call(g, t).every((function(s, c) {
                                        var d = s.match;
                                        if (o.getBuffer.call(g, !0), !1 !== (l = (!d.jit || void 0 !== b.validPositions[o.seekPrevious.call(g, t)]) && (null != d.fn ? d.fn.test(i, b, t, r, y, f.call(g, e)) : (i === d.def || i === y.skipOptionalPartCharacter) && "" !== d.def && {
                                            c: n.getPlaceholder.call(g, t, d, !0) || d.def,
                                            pos: t
                                        }))) {
                                            var p = void 0 !== l.c ? l.c : i, h = t;
                                            return p = p === y.skipOptionalPartCharacter && !0 === d.static ? n.getPlaceholder.call(g, t, d, !0) || d.def : p,
                                            !0 !== (l = P(l)) && void 0 !== l.pos && l.pos !== t && (h = l.pos), !0 !== l && void 0 === l.pos && void 0 === l.c ? !1 : (!1 === m.call(g, e, k.extend({}, s, {
                                                input: u.call(g, p, d, h)
                                            }), a, h) && (l = !1), !1);
                                        }
                                        return !0;
                                    })), l;
                                }
                                void 0 !== e.begin && (x = g.isRTL ? e.end : e.begin);
                                var S = !0, _ = k.extend(!0, {}, b.validPositions);
                                if (!1 === y.keepStatic && void 0 !== b.excludes[x] && !0 !== r && !0 !== a) for (var w = x; w < (g.isRTL ? e.begin : e.end); w++) void 0 !== b.excludes[w] && (b.excludes[w] = void 0,
                                    delete b.tests[w]);
                                if ("function" == typeof y.preValidation && !0 !== a && !0 !== l && (S = P(S = y.preValidation.call(g, o.getBuffer.call(g), x, t, f.call(g, e), y, b, e, i || r))),
                                !0 === S) {
                                    if (S = E(x, t, i), (!i || !0 === a) && !1 === S && !0 !== l) {
                                        var M = b.validPositions[x];
                                        if (!M || !0 !== M.match.static || M.match.def !== t && t !== y.skipOptionalPartCharacter) {
                                            if (y.insertMode || void 0 === b.validPositions[o.seekNext.call(g, x)] || e.end > x) {
                                                var O = !1;
                                                if (b.jitOffset[x] && void 0 === b.validPositions[o.seekNext.call(g, x)] && !1 !== (S = d.call(g, x + b.jitOffset[x], t, !0, !0)) && (!0 !== r && (S.caret = x),
                                                    O = !0), e.end > x && (b.validPositions[x] = void 0), !O && !o.isMask.call(g, x, y.keepStatic && 0 === x)) for (var T = x + 1, C = o.seekNext.call(g, x, !1, 0 !== x); T <= C; T++) if (!1 !== (S = E(T, t, i))) {
                                                    S = v.call(g, x, void 0 !== S.pos ? S.pos : T) || S, x = T;
                                                    break;
                                                }
                                            }
                                        } else S = {
                                            caret: o.seekNext.call(g, x)
                                        };
                                    }
                                    !1 !== S || !y.keepStatic || !c.call(g, o.getBuffer.call(g)) && 0 !== x || i || !0 === r ? f.call(g, e) && b.tests[x] && b.tests[x].length > 1 && y.keepStatic && !i && !0 !== r && (S = s.call(g, !0)) : S = s.call(g, x, t, i, a, void 0, e),
                                    !0 === S && (S = {
                                        pos: x
                                    });
                                }
                                if ("function" == typeof y.postValidation && !0 !== a && !0 !== l) {
                                    var A = y.postValidation.call(g, o.getBuffer.call(g, !0), void 0 !== e.begin ? g.isRTL ? e.end : e.begin : e, t, S, y, b, i, p);
                                    void 0 !== A && (S = !0 === A ? S : A);
                                }
                                S && void 0 === S.pos && (S.pos = x), !1 === S || !0 === l ? (o.resetMaskSet.call(g, !0),
                                    b.validPositions = k.extend(!0, {}, _)) : v.call(g, void 0, x, !0);
                                var D = P(S);
                                void 0 !== g.maxLength && (o.getBuffer.call(g).length > g.maxLength && !a && (o.resetMaskSet.call(g, !0),
                                    b.validPositions = k.extend(!0, {}, _), D = !1));
                                return D;
                            }
                            function p(e, t, i) {
                                for (var a = this.maskset, r = !1, o = n.getTests.call(this, e), l = 0; l < o.length; l++) {
                                    if (o[l].match && (o[l].match.nativeDef === t.match[i.shiftPositions ? "def" : "nativeDef"] && (!i.shiftPositions || !t.match.static) || o[l].match.nativeDef === t.match.nativeDef || i.regex && !o[l].match.static && o[l].match.fn.test(t.input))) {
                                        r = !0;
                                        break;
                                    }
                                    if (o[l].match && o[l].match.def === t.match.nativeDef) {
                                        r = void 0;
                                        break;
                                    }
                                }
                                return !1 === r && void 0 !== a.jitOffset[e] && (r = p.call(this, e + a.jitOffset[e], t, i)),
                                    r;
                            }
                            function h(e, t, i) {
                                var a, n, r = this, s = this.maskset, u = this.opts, c = this.dependencyLib, f = u.skipOptionalPartCharacter, d = r.isRTL ? i.slice().reverse() : i;
                                if (u.skipOptionalPartCharacter = "", !0 === e) o.resetMaskSet.call(r), s.tests = {},
                                    e = 0, t = i.length, n = o.determineNewCaretPosition.call(r, {
                                    begin: 0,
                                    end: 0
                                }, !1).begin; else {
                                    for (a = e; a < t; a++) delete s.validPositions[a];
                                    n = e;
                                }
                                var p = new c.Event("keypress");
                                for (a = e; a < t; a++) {
                                    p.keyCode = d[a].toString().charCodeAt(0), r.ignorable = !1;
                                    var h = l.EventHandlers.keypressEvent.call(r, p, !0, !1, !1, n);
                                    !1 !== h && void 0 !== h && (n = h.forwardPosition);
                                }
                                u.skipOptionalPartCharacter = f;
                            }
                            function v(e, t, i) {
                                var a = this, r = this.maskset, l = this.dependencyLib;
                                if (void 0 === e) for (e = t - 1; e > 0 && !r.validPositions[e]; e--) ;
                                for (var s = e; s < t; s++) {
                                    if (void 0 === r.validPositions[s] && !o.isMask.call(a, s, !1)) if (0 == s ? n.getTest.call(a, s) : r.validPositions[s - 1]) {
                                        var u = n.getTests.call(a, s).slice();
                                        "" === u[u.length - 1].match.def && u.pop();
                                        var c, f = n.determineTestTemplate.call(a, s, u);
                                        if (f && (!0 !== f.match.jit || "master" === f.match.newBlockMarker && (c = r.validPositions[s + 1]) && !0 === c.match.optionalQuantifier) && ((f = l.extend({}, f, {
                                            input: n.getPlaceholder.call(a, s, f.match, !0) || f.match.def
                                        })).generatedInput = !0, m.call(a, s, f, !0), !0 !== i)) {
                                            var p = r.validPositions[t].input;
                                            return r.validPositions[t] = void 0, d.call(a, t, p, !0, !0);
                                        }
                                    }
                                }
                            }
                            function m(e, t, i, a) {
                                var r = this, l = this.maskset, s = this.opts, u = this.dependencyLib;
                                function c(e, t, i) {
                                    var a = t[e];
                                    if (void 0 !== a && !0 === a.match.static && !0 !== a.match.optionality && (void 0 === t[0] || void 0 === t[0].alternation)) {
                                        var n = i.begin <= e - 1 ? t[e - 1] && !0 === t[e - 1].match.static && t[e - 1] : t[e - 1], r = i.end > e + 1 ? t[e + 1] && !0 === t[e + 1].match.static && t[e + 1] : t[e + 1];
                                        return n && r;
                                    }
                                    return !1;
                                }
                                var f = 0, h = void 0 !== e.begin ? e.begin : e, v = void 0 !== e.end ? e.end : e, m = !0;
                                if (e.begin > e.end && (h = e.end, v = e.begin), a = void 0 !== a ? a : h, h !== v || s.insertMode && void 0 !== l.validPositions[a] && void 0 === i || void 0 === t || t.match.optionalQuantifier || t.match.optionality) {
                                    var g, k = u.extend(!0, {}, l.validPositions), y = o.getLastValidPosition.call(r, void 0, !0);
                                    for (l.p = h, g = y; g >= h; g--) delete l.validPositions[g], void 0 === t && delete l.tests[g + 1];
                                    var b, x, P = a, E = P;
                                    for (t && (l.validPositions[a] = u.extend(!0, {}, t), E++, P++), g = t ? v : v - 1; g <= y; g++) {
                                        if (void 0 !== (b = k[g]) && !0 !== b.generatedInput && (g >= v || g >= h && c(g, k, {
                                            begin: h,
                                            end: v
                                        }))) {
                                            for (;"" !== n.getTest.call(r, E).match.def; ) {
                                                if (!1 !== (x = p.call(r, E, b, s)) || "+" === b.match.def) {
                                                    "+" === b.match.def && o.getBuffer.call(r, !0);
                                                    var S = d.call(r, E, b.input, "+" !== b.match.def, !0);
                                                    if (m = !1 !== S, P = (S.pos || E) + 1, !m && x) break;
                                                } else m = !1;
                                                if (m) {
                                                    void 0 === t && b.match.static && g === e.begin && f++;
                                                    break;
                                                }
                                                if (!m && o.getBuffer.call(r), E > l.maskLength) break;
                                                E++;
                                            }
                                            "" == n.getTest.call(r, E).match.def && (m = !1), E = P;
                                        }
                                        if (!m) break;
                                    }
                                    if (!m) return l.validPositions = u.extend(!0, {}, k), o.resetMaskSet.call(r, !0),
                                        !1;
                                } else t && n.getTest.call(r, a).match.cd === t.match.cd && (l.validPositions[a] = u.extend(!0, {}, t));
                                return o.resetMaskSet.call(r, !0), f;
                            }
                        },
                        5581: function(e) {
                            e.exports = JSON.parse('{"BACKSPACE":8,"BACKSPACE_SAFARI":127,"DELETE":46,"DOWN":40,"END":35,"ENTER":13,"ESCAPE":27,"HOME":36,"INSERT":45,"LEFT":37,"PAGE_DOWN":34,"PAGE_UP":33,"RIGHT":39,"SPACE":32,"TAB":9,"UP":38,"X":88,"Z":90,"CONTROL":17,"PAUSE/BREAK":19,"WINDOWS_LEFT":91,"WINDOWS_RIGHT":92,"KEY_229":229}');
                        }
                    }, t = {};
                    function i(a) {
                        var n = t[a];
                        if (void 0 !== n) return n.exports;
                        var r = t[a] = {
                            exports: {}
                        };
                        return e[a](r, r.exports, i), r.exports;
                    }
                    var a = {};
                    return function() {
                        var e, t = a;
                        Object.defineProperty(t, "__esModule", {
                            value: !0
                        }), t.default = void 0, i(3851), i(219), i(207), i(5296);
                        var n = ((e = i(2394)) && e.__esModule ? e : {
                            default: e
                        }).default;
                        t.default = n;
                    }(), a;
                }();
            }));

            /***/ }),

        /***/ "./node_modules/ion-rangeslider/js/ion.rangeSlider.js":
        /*!************************************************************!*\
  !*** ./node_modules/ion-rangeslider/js/ion.rangeSlider.js ***!
  \************************************************************/
        /*! no static exports found */
        /***/ (function(module, exports, __webpack_require__) {

            /* WEBPACK VAR INJECTION */(function(jQuery) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Ion.RangeSlider
// version 2.3.1 Build: 382
// © Denis Ineshin, 2019
// https://github.com/IonDen
//
// Project page:    http://ionden.com/a/plugins/ion.rangeSlider/en.html
// GitHub page:     https://github.com/IonDen/ion.rangeSlider
//
// Released under MIT licence:
// http://ionden.com/a/plugins/licence-en.html
// =====================================================================================================================

                ;(function(factory) {
                    if ((typeof jQuery === 'undefined' || !jQuery) && "function" === "function" && __webpack_require__(/*! !webpack amd options */ "./node_modules/webpack/buildin/amd-options.js")) {
                        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery) {
                            return factory(jQuery, document, window, navigator);
                        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
                        __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                    } else if ((typeof jQuery === 'undefined' || !jQuery) && typeof exports === "object") {
                        factory(__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js"), document, window, navigator);
                    } else {
                        factory(jQuery, document, window, navigator);
                    }
                } (function ($, document, window, navigator, undefined) {
                    "use strict";

                    // =================================================================================================================
                    // Service

                    var plugin_count = 0;

                    // IE8 fix
                    var is_old_ie = (function () {
                        var n = navigator.userAgent,
                            r = /msie\s\d+/i,
                            v;
                        if (n.search(r) > 0) {
                            v = r.exec(n).toString();
                            v = v.split(" ")[1];
                            if (v < 9) {
                                $("html").addClass("lt-ie9");
                                return true;
                            }
                        }
                        return false;
                    } ());
                    if (!Function.prototype.bind) {
                        Function.prototype.bind = function bind(that) {

                            var target = this;
                            var slice = [].slice;

                            if (typeof target != "function") {
                                throw new TypeError();
                            }

                            var args = slice.call(arguments, 1),
                                bound = function () {

                                    if (this instanceof bound) {

                                        var F = function(){};
                                        F.prototype = target.prototype;
                                        var self = new F();

                                        var result = target.apply(
                                            self,
                                            args.concat(slice.call(arguments))
                                        );
                                        if (Object(result) === result) {
                                            return result;
                                        }
                                        return self;

                                    } else {

                                        return target.apply(
                                            that,
                                            args.concat(slice.call(arguments))
                                        );

                                    }

                                };

                            return bound;
                        };
                    }
                    if (!Array.prototype.indexOf) {
                        Array.prototype.indexOf = function(searchElement, fromIndex) {
                            var k;
                            if (this == null) {
                                throw new TypeError('"this" is null or not defined');
                            }
                            var O = Object(this);
                            var len = O.length >>> 0;
                            if (len === 0) {
                                return -1;
                            }
                            var n = +fromIndex || 0;
                            if (Math.abs(n) === Infinity) {
                                n = 0;
                            }
                            if (n >= len) {
                                return -1;
                            }
                            k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);
                            while (k < len) {
                                if (k in O && O[k] === searchElement) {
                                    return k;
                                }
                                k++;
                            }
                            return -1;
                        };
                    }



                    // =================================================================================================================
                    // Template

                    var base_html =
                        '<span class="irs">' +
                        '<span class="irs-line" tabindex="0"></span>' +
                        '<span class="irs-min">0</span><span class="irs-max">1</span>' +
                        '<span class="irs-from">0</span><span class="irs-to">0</span><span class="irs-single">0</span>' +
                        '</span>' +
                        '<span class="irs-grid"></span>';

                    var single_html =
                        '<span class="irs-bar irs-bar--single"></span>' +
                        '<span class="irs-shadow shadow-single"></span>' +
                        '<span class="irs-handle single"><i></i><i></i><i></i></span>';

                    var double_html =
                        '<span class="irs-bar"></span>' +
                        '<span class="irs-shadow shadow-from"></span>' +
                        '<span class="irs-shadow shadow-to"></span>' +
                        '<span class="irs-handle from"><i></i><i></i><i></i></span>' +
                        '<span class="irs-handle to"><i></i><i></i><i></i></span>';

                    var disable_html =
                        '<span class="irs-disable-mask"></span>';



                    // =================================================================================================================
                    // Core

                    /**
                     * Main plugin constructor
                     *
                     * @param input {Object} link to base input element
                     * @param options {Object} slider config
                     * @param plugin_count {Number}
                     * @constructor
                     */
                    var IonRangeSlider = function (input, options, plugin_count) {
                        this.VERSION = "2.3.1";
                        this.input = input;
                        this.plugin_count = plugin_count;
                        this.current_plugin = 0;
                        this.calc_count = 0;
                        this.update_tm = 0;
                        this.old_from = 0;
                        this.old_to = 0;
                        this.old_min_interval = null;
                        this.raf_id = null;
                        this.dragging = false;
                        this.force_redraw = false;
                        this.no_diapason = false;
                        this.has_tab_index = true;
                        this.is_key = false;
                        this.is_update = false;
                        this.is_start = true;
                        this.is_finish = false;
                        this.is_active = false;
                        this.is_resize = false;
                        this.is_click = false;

                        options = options || {};

                        // cache for links to all DOM elements
                        this.$cache = {
                            win: $(window),
                            body: $(document.body),
                            input: $(input),
                            cont: null,
                            rs: null,
                            min: null,
                            max: null,
                            from: null,
                            to: null,
                            single: null,
                            bar: null,
                            line: null,
                            s_single: null,
                            s_from: null,
                            s_to: null,
                            shad_single: null,
                            shad_from: null,
                            shad_to: null,
                            edge: null,
                            grid: null,
                            grid_labels: []
                        };

                        // storage for measure variables
                        this.coords = {
                            // left
                            x_gap: 0,
                            x_pointer: 0,

                            // width
                            w_rs: 0,
                            w_rs_old: 0,
                            w_handle: 0,

                            // percents
                            p_gap: 0,
                            p_gap_left: 0,
                            p_gap_right: 0,
                            p_step: 0,
                            p_pointer: 0,
                            p_handle: 0,
                            p_single_fake: 0,
                            p_single_real: 0,
                            p_from_fake: 0,
                            p_from_real: 0,
                            p_to_fake: 0,
                            p_to_real: 0,
                            p_bar_x: 0,
                            p_bar_w: 0,

                            // grid
                            grid_gap: 0,
                            big_num: 0,
                            big: [],
                            big_w: [],
                            big_p: [],
                            big_x: []
                        };

                        // storage for labels measure variables
                        this.labels = {
                            // width
                            w_min: 0,
                            w_max: 0,
                            w_from: 0,
                            w_to: 0,
                            w_single: 0,

                            // percents
                            p_min: 0,
                            p_max: 0,
                            p_from_fake: 0,
                            p_from_left: 0,
                            p_to_fake: 0,
                            p_to_left: 0,
                            p_single_fake: 0,
                            p_single_left: 0
                        };



                        /**
                         * get and validate config
                         */
                        var $inp = this.$cache.input,
                            val = $inp.prop("value"),
                            config, config_from_data, prop;

                        // default config
                        config = {
                            skin: "flat",
                            type: "single",

                            min: 10,
                            max: 100,
                            from: null,
                            to: null,
                            step: 1,

                            min_interval: 0,
                            max_interval: 0,
                            drag_interval: false,

                            values: [],
                            p_values: [],

                            from_fixed: false,
                            from_min: null,
                            from_max: null,
                            from_shadow: false,

                            to_fixed: false,
                            to_min: null,
                            to_max: null,
                            to_shadow: false,

                            prettify_enabled: true,
                            prettify_separator: " ",
                            prettify: null,

                            force_edges: false,

                            keyboard: true,

                            grid: false,
                            grid_margin: true,
                            grid_num: 4,
                            grid_snap: false,

                            hide_min_max: false,
                            hide_from_to: false,

                            prefix: "",
                            postfix: "",
                            max_postfix: "",
                            decorate_both: true,
                            values_separator: " — ",

                            input_values_separator: ";",

                            disable: false,
                            block: false,

                            extra_classes: "",

                            scope: null,
                            onStart: null,
                            onChange: null,
                            onFinish: null,
                            onUpdate: null
                        };


                        // check if base element is input
                        if ($inp[0].nodeName !== "INPUT") {
                            console && console.warn && console.warn("Base element should be <input>!", $inp[0]);
                        }


                        // config from data-attributes extends js config
                        config_from_data = {
                            skin: $inp.data("skin"),
                            type: $inp.data("type"),

                            min: $inp.data("min"),
                            max: $inp.data("max"),
                            from: $inp.data("from"),
                            to: $inp.data("to"),
                            step: $inp.data("step"),

                            min_interval: $inp.data("minInterval"),
                            max_interval: $inp.data("maxInterval"),
                            drag_interval: $inp.data("dragInterval"),

                            values: $inp.data("values"),

                            from_fixed: $inp.data("fromFixed"),
                            from_min: $inp.data("fromMin"),
                            from_max: $inp.data("fromMax"),
                            from_shadow: $inp.data("fromShadow"),

                            to_fixed: $inp.data("toFixed"),
                            to_min: $inp.data("toMin"),
                            to_max: $inp.data("toMax"),
                            to_shadow: $inp.data("toShadow"),

                            prettify_enabled: $inp.data("prettifyEnabled"),
                            prettify_separator: $inp.data("prettifySeparator"),

                            force_edges: $inp.data("forceEdges"),

                            keyboard: $inp.data("keyboard"),

                            grid: $inp.data("grid"),
                            grid_margin: $inp.data("gridMargin"),
                            grid_num: $inp.data("gridNum"),
                            grid_snap: $inp.data("gridSnap"),

                            hide_min_max: $inp.data("hideMinMax"),
                            hide_from_to: $inp.data("hideFromTo"),

                            prefix: $inp.data("prefix"),
                            postfix: $inp.data("postfix"),
                            max_postfix: $inp.data("maxPostfix"),
                            decorate_both: $inp.data("decorateBoth"),
                            values_separator: $inp.data("valuesSeparator"),

                            input_values_separator: $inp.data("inputValuesSeparator"),

                            disable: $inp.data("disable"),
                            block: $inp.data("block"),

                            extra_classes: $inp.data("extraClasses"),
                        };
                        config_from_data.values = config_from_data.values && config_from_data.values.split(",");

                        for (prop in config_from_data) {
                            if (config_from_data.hasOwnProperty(prop)) {
                                if (config_from_data[prop] === undefined || config_from_data[prop] === "") {
                                    delete config_from_data[prop];
                                }
                            }
                        }


                        // input value extends default config
                        if (val !== undefined && val !== "") {
                            val = val.split(config_from_data.input_values_separator || options.input_values_separator || ";");

                            if (val[0] && val[0] == +val[0]) {
                                val[0] = +val[0];
                            }
                            if (val[1] && val[1] == +val[1]) {
                                val[1] = +val[1];
                            }

                            if (options && options.values && options.values.length) {
                                config.from = val[0] && options.values.indexOf(val[0]);
                                config.to = val[1] && options.values.indexOf(val[1]);
                            } else {
                                config.from = val[0] && +val[0];
                                config.to = val[1] && +val[1];
                            }
                        }



                        // js config extends default config
                        $.extend(config, options);


                        // data config extends config
                        $.extend(config, config_from_data);
                        this.options = config;



                        // validate config, to be sure that all data types are correct
                        this.update_check = {};
                        this.validate();



                        // default result object, returned to callbacks
                        this.result = {
                            input: this.$cache.input,
                            slider: null,

                            min: this.options.min,
                            max: this.options.max,

                            from: this.options.from,
                            from_percent: 0,
                            from_value: null,

                            to: this.options.to,
                            to_percent: 0,
                            to_value: null
                        };



                        this.init();
                    };

                    IonRangeSlider.prototype = {

                        /**
                         * Starts or updates the plugin instance
                         *
                         * @param [is_update] {boolean}
                         */
                        init: function (is_update) {
                            this.no_diapason = false;
                            this.coords.p_step = this.convertToPercent(this.options.step, true);

                            this.target = "base";

                            this.toggleInput();
                            this.append();
                            this.setMinMax();

                            if (is_update) {
                                this.force_redraw = true;
                                this.calc(true);

                                // callbacks called
                                this.callOnUpdate();
                            } else {
                                this.force_redraw = true;
                                this.calc(true);

                                // callbacks called
                                this.callOnStart();
                            }

                            this.updateScene();
                        },

                        /**
                         * Appends slider template to a DOM
                         */
                        append: function () {
                            var container_html = '<span class="irs irs--' + this.options.skin + ' js-irs-' + this.plugin_count + ' ' + this.options.extra_classes + '"></span>';
                            this.$cache.input.before(container_html);
                            this.$cache.input.prop("readonly", true);
                            this.$cache.cont = this.$cache.input.prev();
                            this.result.slider = this.$cache.cont;

                            this.$cache.cont.html(base_html);
                            this.$cache.rs = this.$cache.cont.find(".irs");
                            this.$cache.min = this.$cache.cont.find(".irs-min");
                            this.$cache.max = this.$cache.cont.find(".irs-max");
                            this.$cache.from = this.$cache.cont.find(".irs-from");
                            this.$cache.to = this.$cache.cont.find(".irs-to");
                            this.$cache.single = this.$cache.cont.find(".irs-single");
                            this.$cache.line = this.$cache.cont.find(".irs-line");
                            this.$cache.grid = this.$cache.cont.find(".irs-grid");

                            if (this.options.type === "single") {
                                this.$cache.cont.append(single_html);
                                this.$cache.bar = this.$cache.cont.find(".irs-bar");
                                this.$cache.edge = this.$cache.cont.find(".irs-bar-edge");
                                this.$cache.s_single = this.$cache.cont.find(".single");
                                this.$cache.from[0].style.visibility = "hidden";
                                this.$cache.to[0].style.visibility = "hidden";
                                this.$cache.shad_single = this.$cache.cont.find(".shadow-single");
                            } else {
                                this.$cache.cont.append(double_html);
                                this.$cache.bar = this.$cache.cont.find(".irs-bar");
                                this.$cache.s_from = this.$cache.cont.find(".from");
                                this.$cache.s_to = this.$cache.cont.find(".to");
                                this.$cache.shad_from = this.$cache.cont.find(".shadow-from");
                                this.$cache.shad_to = this.$cache.cont.find(".shadow-to");

                                this.setTopHandler();
                            }

                            if (this.options.hide_from_to) {
                                this.$cache.from[0].style.display = "none";
                                this.$cache.to[0].style.display = "none";
                                this.$cache.single[0].style.display = "none";
                            }

                            this.appendGrid();

                            if (this.options.disable) {
                                this.appendDisableMask();
                                this.$cache.input[0].disabled = true;
                            } else {
                                this.$cache.input[0].disabled = false;
                                this.removeDisableMask();
                                this.bindEvents();
                            }

                            // block only if not disabled
                            if (!this.options.disable) {
                                if (this.options.block) {
                                    this.appendDisableMask();
                                } else {
                                    this.removeDisableMask();
                                }
                            }

                            if (this.options.drag_interval) {
                                this.$cache.bar[0].style.cursor = "ew-resize";
                            }
                        },

                        /**
                         * Determine which handler has a priority
                         * works only for double slider type
                         */
                        setTopHandler: function () {
                            var min = this.options.min,
                                max = this.options.max,
                                from = this.options.from,
                                to = this.options.to;

                            if (from > min && to === max) {
                                this.$cache.s_from.addClass("type_last");
                            } else if (to < max) {
                                this.$cache.s_to.addClass("type_last");
                            }
                        },

                        /**
                         * Determine which handles was clicked last
                         * and which handler should have hover effect
                         *
                         * @param target {String}
                         */
                        changeLevel: function (target) {
                            switch (target) {
                                case "single":
                                    this.coords.p_gap = this.toFixed(this.coords.p_pointer - this.coords.p_single_fake);
                                    this.$cache.s_single.addClass("state_hover");
                                    break;
                                case "from":
                                    this.coords.p_gap = this.toFixed(this.coords.p_pointer - this.coords.p_from_fake);
                                    this.$cache.s_from.addClass("state_hover");
                                    this.$cache.s_from.addClass("type_last");
                                    this.$cache.s_to.removeClass("type_last");
                                    break;
                                case "to":
                                    this.coords.p_gap = this.toFixed(this.coords.p_pointer - this.coords.p_to_fake);
                                    this.$cache.s_to.addClass("state_hover");
                                    this.$cache.s_to.addClass("type_last");
                                    this.$cache.s_from.removeClass("type_last");
                                    break;
                                case "both":
                                    this.coords.p_gap_left = this.toFixed(this.coords.p_pointer - this.coords.p_from_fake);
                                    this.coords.p_gap_right = this.toFixed(this.coords.p_to_fake - this.coords.p_pointer);
                                    this.$cache.s_to.removeClass("type_last");
                                    this.$cache.s_from.removeClass("type_last");
                                    break;
                            }
                        },

                        /**
                         * Then slider is disabled
                         * appends extra layer with opacity
                         */
                        appendDisableMask: function () {
                            this.$cache.cont.append(disable_html);
                            this.$cache.cont.addClass("irs-disabled");
                        },

                        /**
                         * Then slider is not disabled
                         * remove disable mask
                         */
                        removeDisableMask: function () {
                            this.$cache.cont.remove(".irs-disable-mask");
                            this.$cache.cont.removeClass("irs-disabled");
                        },

                        /**
                         * Remove slider instance
                         * and unbind all events
                         */
                        remove: function () {
                            this.$cache.cont.remove();
                            this.$cache.cont = null;

                            this.$cache.line.off("keydown.irs_" + this.plugin_count);

                            this.$cache.body.off("touchmove.irs_" + this.plugin_count);
                            this.$cache.body.off("mousemove.irs_" + this.plugin_count);

                            this.$cache.win.off("touchend.irs_" + this.plugin_count);
                            this.$cache.win.off("mouseup.irs_" + this.plugin_count);

                            if (is_old_ie) {
                                this.$cache.body.off("mouseup.irs_" + this.plugin_count);
                                this.$cache.body.off("mouseleave.irs_" + this.plugin_count);
                            }

                            this.$cache.grid_labels = [];
                            this.coords.big = [];
                            this.coords.big_w = [];
                            this.coords.big_p = [];
                            this.coords.big_x = [];

                            cancelAnimationFrame(this.raf_id);
                        },

                        /**
                         * bind all slider events
                         */
                        bindEvents: function () {
                            if (this.no_diapason) {
                                return;
                            }

                            this.$cache.body.on("touchmove.irs_" + this.plugin_count, this.pointerMove.bind(this));
                            this.$cache.body.on("mousemove.irs_" + this.plugin_count, this.pointerMove.bind(this));

                            this.$cache.win.on("touchend.irs_" + this.plugin_count, this.pointerUp.bind(this));
                            this.$cache.win.on("mouseup.irs_" + this.plugin_count, this.pointerUp.bind(this));

                            this.$cache.line.on("touchstart.irs_" + this.plugin_count, this.pointerClick.bind(this, "click"));
                            this.$cache.line.on("mousedown.irs_" + this.plugin_count, this.pointerClick.bind(this, "click"));

                            this.$cache.line.on("focus.irs_" + this.plugin_count, this.pointerFocus.bind(this));

                            if (this.options.drag_interval && this.options.type === "double") {
                                this.$cache.bar.on("touchstart.irs_" + this.plugin_count, this.pointerDown.bind(this, "both"));
                                this.$cache.bar.on("mousedown.irs_" + this.plugin_count, this.pointerDown.bind(this, "both"));
                            } else {
                                this.$cache.bar.on("touchstart.irs_" + this.plugin_count, this.pointerClick.bind(this, "click"));
                                this.$cache.bar.on("mousedown.irs_" + this.plugin_count, this.pointerClick.bind(this, "click"));
                            }

                            if (this.options.type === "single") {
                                this.$cache.single.on("touchstart.irs_" + this.plugin_count, this.pointerDown.bind(this, "single"));
                                this.$cache.s_single.on("touchstart.irs_" + this.plugin_count, this.pointerDown.bind(this, "single"));
                                this.$cache.shad_single.on("touchstart.irs_" + this.plugin_count, this.pointerClick.bind(this, "click"));

                                this.$cache.single.on("mousedown.irs_" + this.plugin_count, this.pointerDown.bind(this, "single"));
                                this.$cache.s_single.on("mousedown.irs_" + this.plugin_count, this.pointerDown.bind(this, "single"));
                                this.$cache.edge.on("mousedown.irs_" + this.plugin_count, this.pointerClick.bind(this, "click"));
                                this.$cache.shad_single.on("mousedown.irs_" + this.plugin_count, this.pointerClick.bind(this, "click"));
                            } else {
                                this.$cache.single.on("touchstart.irs_" + this.plugin_count, this.pointerDown.bind(this, null));
                                this.$cache.single.on("mousedown.irs_" + this.plugin_count, this.pointerDown.bind(this, null));

                                this.$cache.from.on("touchstart.irs_" + this.plugin_count, this.pointerDown.bind(this, "from"));
                                this.$cache.s_from.on("touchstart.irs_" + this.plugin_count, this.pointerDown.bind(this, "from"));
                                this.$cache.to.on("touchstart.irs_" + this.plugin_count, this.pointerDown.bind(this, "to"));
                                this.$cache.s_to.on("touchstart.irs_" + this.plugin_count, this.pointerDown.bind(this, "to"));
                                this.$cache.shad_from.on("touchstart.irs_" + this.plugin_count, this.pointerClick.bind(this, "click"));
                                this.$cache.shad_to.on("touchstart.irs_" + this.plugin_count, this.pointerClick.bind(this, "click"));

                                this.$cache.from.on("mousedown.irs_" + this.plugin_count, this.pointerDown.bind(this, "from"));
                                this.$cache.s_from.on("mousedown.irs_" + this.plugin_count, this.pointerDown.bind(this, "from"));
                                this.$cache.to.on("mousedown.irs_" + this.plugin_count, this.pointerDown.bind(this, "to"));
                                this.$cache.s_to.on("mousedown.irs_" + this.plugin_count, this.pointerDown.bind(this, "to"));
                                this.$cache.shad_from.on("mousedown.irs_" + this.plugin_count, this.pointerClick.bind(this, "click"));
                                this.$cache.shad_to.on("mousedown.irs_" + this.plugin_count, this.pointerClick.bind(this, "click"));
                            }

                            if (this.options.keyboard) {
                                this.$cache.line.on("keydown.irs_" + this.plugin_count, this.key.bind(this, "keyboard"));
                            }

                            if (is_old_ie) {
                                this.$cache.body.on("mouseup.irs_" + this.plugin_count, this.pointerUp.bind(this));
                                this.$cache.body.on("mouseleave.irs_" + this.plugin_count, this.pointerUp.bind(this));
                            }
                        },

                        /**
                         * Focus with tabIndex
                         *
                         * @param e {Object} event object
                         */
                        pointerFocus: function (e) {
                            if (!this.target) {
                                var x;
                                var $handle;

                                if (this.options.type === "single") {
                                    $handle = this.$cache.single;
                                } else {
                                    $handle = this.$cache.from;
                                }

                                x = $handle.offset().left;
                                x += ($handle.width() / 2) - 1;

                                this.pointerClick("single", {preventDefault: function () {}, pageX: x});
                            }
                        },

                        /**
                         * Mousemove or touchmove
                         * only for handlers
                         *
                         * @param e {Object} event object
                         */
                        pointerMove: function (e) {
                            if (!this.dragging) {
                                return;
                            }

                            var x = e.pageX || e.originalEvent.touches && e.originalEvent.touches[0].pageX;
                            this.coords.x_pointer = x - this.coords.x_gap;

                            this.calc();
                        },

                        /**
                         * Mouseup or touchend
                         * only for handlers
                         *
                         * @param e {Object} event object
                         */
                        pointerUp: function (e) {
                            if (this.current_plugin !== this.plugin_count) {
                                return;
                            }

                            if (this.is_active) {
                                this.is_active = false;
                            } else {
                                return;
                            }

                            this.$cache.cont.find(".state_hover").removeClass("state_hover");

                            this.force_redraw = true;

                            if (is_old_ie) {
                                $("*").prop("unselectable", false);
                            }

                            this.updateScene();
                            this.restoreOriginalMinInterval();

                            // callbacks call
                            if ($.contains(this.$cache.cont[0], e.target) || this.dragging) {
                                this.callOnFinish();
                            }

                            this.dragging = false;
                        },

                        /**
                         * Mousedown or touchstart
                         * only for handlers
                         *
                         * @param target {String|null}
                         * @param e {Object} event object
                         */
                        pointerDown: function (target, e) {
                            e.preventDefault();
                            var x = e.pageX || e.originalEvent.touches && e.originalEvent.touches[0].pageX;
                            if (e.button === 2) {
                                return;
                            }

                            if (target === "both") {
                                this.setTempMinInterval();
                            }

                            if (!target) {
                                target = this.target || "from";
                            }

                            this.current_plugin = this.plugin_count;
                            this.target = target;

                            this.is_active = true;
                            this.dragging = true;

                            this.coords.x_gap = this.$cache.rs.offset().left;
                            this.coords.x_pointer = x - this.coords.x_gap;

                            this.calcPointerPercent();
                            this.changeLevel(target);

                            if (is_old_ie) {
                                $("*").prop("unselectable", true);
                            }

                            this.$cache.line.trigger("focus");

                            this.updateScene();
                        },

                        /**
                         * Mousedown or touchstart
                         * for other slider elements, like diapason line
                         *
                         * @param target {String}
                         * @param e {Object} event object
                         */
                        pointerClick: function (target, e) {
                            e.preventDefault();
                            var x = e.pageX || e.originalEvent.touches && e.originalEvent.touches[0].pageX;
                            if (e.button === 2) {
                                return;
                            }

                            this.current_plugin = this.plugin_count;
                            this.target = target;

                            this.is_click = true;
                            this.coords.x_gap = this.$cache.rs.offset().left;
                            this.coords.x_pointer = +(x - this.coords.x_gap).toFixed();

                            this.force_redraw = true;
                            this.calc();

                            this.$cache.line.trigger("focus");
                        },

                        /**
                         * Keyborard controls for focused slider
                         *
                         * @param target {String}
                         * @param e {Object} event object
                         * @returns {boolean|undefined}
                         */
                        key: function (target, e) {
                            if (this.current_plugin !== this.plugin_count || e.altKey || e.ctrlKey || e.shiftKey || e.metaKey) {
                                return;
                            }

                            switch (e.which) {
                                case 83: // W
                                case 65: // A
                                case 40: // DOWN
                                case 37: // LEFT
                                    e.preventDefault();
                                    this.moveByKey(false);
                                    break;

                                case 87: // S
                                case 68: // D
                                case 38: // UP
                                case 39: // RIGHT
                                    e.preventDefault();
                                    this.moveByKey(true);
                                    break;
                            }

                            return true;
                        },

                        /**
                         * Move by key
                         *
                         * @param right {boolean} direction to move
                         */
                        moveByKey: function (right) {
                            var p = this.coords.p_pointer;
                            var p_step = (this.options.max - this.options.min) / 100;
                            p_step = this.options.step / p_step;

                            if (right) {
                                p += p_step;
                            } else {
                                p -= p_step;
                            }

                            this.coords.x_pointer = this.toFixed(this.coords.w_rs / 100 * p);
                            this.is_key = true;
                            this.calc();
                        },

                        /**
                         * Set visibility and content
                         * of Min and Max labels
                         */
                        setMinMax: function () {
                            if (!this.options) {
                                return;
                            }

                            if (this.options.hide_min_max) {
                                this.$cache.min[0].style.display = "none";
                                this.$cache.max[0].style.display = "none";
                                return;
                            }

                            if (this.options.values.length) {
                                this.$cache.min.html(this.decorate(this.options.p_values[this.options.min]));
                                this.$cache.max.html(this.decorate(this.options.p_values[this.options.max]));
                            } else {
                                var min_pretty = this._prettify(this.options.min);
                                var max_pretty = this._prettify(this.options.max);

                                this.result.min_pretty = min_pretty;
                                this.result.max_pretty = max_pretty;

                                this.$cache.min.html(this.decorate(min_pretty, this.options.min));
                                this.$cache.max.html(this.decorate(max_pretty, this.options.max));
                            }

                            this.labels.w_min = this.$cache.min.outerWidth(false);
                            this.labels.w_max = this.$cache.max.outerWidth(false);
                        },

                        /**
                         * Then dragging interval, prevent interval collapsing
                         * using min_interval option
                         */
                        setTempMinInterval: function () {
                            var interval = this.result.to - this.result.from;

                            if (this.old_min_interval === null) {
                                this.old_min_interval = this.options.min_interval;
                            }

                            this.options.min_interval = interval;
                        },

                        /**
                         * Restore min_interval option to original
                         */
                        restoreOriginalMinInterval: function () {
                            if (this.old_min_interval !== null) {
                                this.options.min_interval = this.old_min_interval;
                                this.old_min_interval = null;
                            }
                        },



                        // =============================================================================================================
                        // Calculations

                        /**
                         * All calculations and measures start here
                         *
                         * @param update {boolean=}
                         */
                        calc: function (update) {
                            if (!this.options) {
                                return;
                            }

                            this.calc_count++;

                            if (this.calc_count === 10 || update) {
                                this.calc_count = 0;
                                this.coords.w_rs = this.$cache.rs.outerWidth(false);

                                this.calcHandlePercent();
                            }

                            if (!this.coords.w_rs) {
                                return;
                            }

                            this.calcPointerPercent();
                            var handle_x = this.getHandleX();


                            if (this.target === "both") {
                                this.coords.p_gap = 0;
                                handle_x = this.getHandleX();
                            }

                            if (this.target === "click") {
                                this.coords.p_gap = this.coords.p_handle / 2;
                                handle_x = this.getHandleX();

                                if (this.options.drag_interval) {
                                    this.target = "both_one";
                                } else {
                                    this.target = this.chooseHandle(handle_x);
                                }
                            }

                            switch (this.target) {
                                case "base":
                                    var w = (this.options.max - this.options.min) / 100,
                                        f = (this.result.from - this.options.min) / w,
                                        t = (this.result.to - this.options.min) / w;

                                    this.coords.p_single_real = this.toFixed(f);
                                    this.coords.p_from_real = this.toFixed(f);
                                    this.coords.p_to_real = this.toFixed(t);

                                    this.coords.p_single_real = this.checkDiapason(this.coords.p_single_real, this.options.from_min, this.options.from_max);
                                    this.coords.p_from_real = this.checkDiapason(this.coords.p_from_real, this.options.from_min, this.options.from_max);
                                    this.coords.p_to_real = this.checkDiapason(this.coords.p_to_real, this.options.to_min, this.options.to_max);

                                    this.coords.p_single_fake = this.convertToFakePercent(this.coords.p_single_real);
                                    this.coords.p_from_fake = this.convertToFakePercent(this.coords.p_from_real);
                                    this.coords.p_to_fake = this.convertToFakePercent(this.coords.p_to_real);

                                    this.target = null;

                                    break;

                                case "single":
                                    if (this.options.from_fixed) {
                                        break;
                                    }

                                    this.coords.p_single_real = this.convertToRealPercent(handle_x);
                                    this.coords.p_single_real = this.calcWithStep(this.coords.p_single_real);
                                    this.coords.p_single_real = this.checkDiapason(this.coords.p_single_real, this.options.from_min, this.options.from_max);

                                    this.coords.p_single_fake = this.convertToFakePercent(this.coords.p_single_real);

                                    break;

                                case "from":
                                    if (this.options.from_fixed) {
                                        break;
                                    }

                                    this.coords.p_from_real = this.convertToRealPercent(handle_x);
                                    this.coords.p_from_real = this.calcWithStep(this.coords.p_from_real);
                                    if (this.coords.p_from_real > this.coords.p_to_real) {
                                        this.coords.p_from_real = this.coords.p_to_real;
                                    }
                                    this.coords.p_from_real = this.checkDiapason(this.coords.p_from_real, this.options.from_min, this.options.from_max);
                                    this.coords.p_from_real = this.checkMinInterval(this.coords.p_from_real, this.coords.p_to_real, "from");
                                    this.coords.p_from_real = this.checkMaxInterval(this.coords.p_from_real, this.coords.p_to_real, "from");

                                    this.coords.p_from_fake = this.convertToFakePercent(this.coords.p_from_real);

                                    break;

                                case "to":
                                    if (this.options.to_fixed) {
                                        break;
                                    }

                                    this.coords.p_to_real = this.convertToRealPercent(handle_x);
                                    this.coords.p_to_real = this.calcWithStep(this.coords.p_to_real);
                                    if (this.coords.p_to_real < this.coords.p_from_real) {
                                        this.coords.p_to_real = this.coords.p_from_real;
                                    }
                                    this.coords.p_to_real = this.checkDiapason(this.coords.p_to_real, this.options.to_min, this.options.to_max);
                                    this.coords.p_to_real = this.checkMinInterval(this.coords.p_to_real, this.coords.p_from_real, "to");
                                    this.coords.p_to_real = this.checkMaxInterval(this.coords.p_to_real, this.coords.p_from_real, "to");

                                    this.coords.p_to_fake = this.convertToFakePercent(this.coords.p_to_real);

                                    break;

                                case "both":
                                    if (this.options.from_fixed || this.options.to_fixed) {
                                        break;
                                    }

                                    handle_x = this.toFixed(handle_x + (this.coords.p_handle * 0.001));

                                    this.coords.p_from_real = this.convertToRealPercent(handle_x) - this.coords.p_gap_left;
                                    this.coords.p_from_real = this.calcWithStep(this.coords.p_from_real);
                                    this.coords.p_from_real = this.checkDiapason(this.coords.p_from_real, this.options.from_min, this.options.from_max);
                                    this.coords.p_from_real = this.checkMinInterval(this.coords.p_from_real, this.coords.p_to_real, "from");
                                    this.coords.p_from_fake = this.convertToFakePercent(this.coords.p_from_real);

                                    this.coords.p_to_real = this.convertToRealPercent(handle_x) + this.coords.p_gap_right;
                                    this.coords.p_to_real = this.calcWithStep(this.coords.p_to_real);
                                    this.coords.p_to_real = this.checkDiapason(this.coords.p_to_real, this.options.to_min, this.options.to_max);
                                    this.coords.p_to_real = this.checkMinInterval(this.coords.p_to_real, this.coords.p_from_real, "to");
                                    this.coords.p_to_fake = this.convertToFakePercent(this.coords.p_to_real);

                                    break;

                                case "both_one":
                                    if (this.options.from_fixed || this.options.to_fixed) {
                                        break;
                                    }

                                    var real_x = this.convertToRealPercent(handle_x),
                                        from = this.result.from_percent,
                                        to = this.result.to_percent,
                                        full = to - from,
                                        half = full / 2,
                                        new_from = real_x - half,
                                        new_to = real_x + half;

                                    if (new_from < 0) {
                                        new_from = 0;
                                        new_to = new_from + full;
                                    }

                                    if (new_to > 100) {
                                        new_to = 100;
                                        new_from = new_to - full;
                                    }

                                    this.coords.p_from_real = this.calcWithStep(new_from);
                                    this.coords.p_from_real = this.checkDiapason(this.coords.p_from_real, this.options.from_min, this.options.from_max);
                                    this.coords.p_from_fake = this.convertToFakePercent(this.coords.p_from_real);

                                    this.coords.p_to_real = this.calcWithStep(new_to);
                                    this.coords.p_to_real = this.checkDiapason(this.coords.p_to_real, this.options.to_min, this.options.to_max);
                                    this.coords.p_to_fake = this.convertToFakePercent(this.coords.p_to_real);

                                    break;
                            }

                            if (this.options.type === "single") {
                                this.coords.p_bar_x = (this.coords.p_handle / 2);
                                this.coords.p_bar_w = this.coords.p_single_fake;

                                this.result.from_percent = this.coords.p_single_real;
                                this.result.from = this.convertToValue(this.coords.p_single_real);
                                this.result.from_pretty = this._prettify(this.result.from);

                                if (this.options.values.length) {
                                    this.result.from_value = this.options.values[this.result.from];
                                }
                            } else {
                                this.coords.p_bar_x = this.toFixed(this.coords.p_from_fake + (this.coords.p_handle / 2));
                                this.coords.p_bar_w = this.toFixed(this.coords.p_to_fake - this.coords.p_from_fake);

                                this.result.from_percent = this.coords.p_from_real;
                                this.result.from = this.convertToValue(this.coords.p_from_real);
                                this.result.from_pretty = this._prettify(this.result.from);
                                this.result.to_percent = this.coords.p_to_real;
                                this.result.to = this.convertToValue(this.coords.p_to_real);
                                this.result.to_pretty = this._prettify(this.result.to);

                                if (this.options.values.length) {
                                    this.result.from_value = this.options.values[this.result.from];
                                    this.result.to_value = this.options.values[this.result.to];
                                }
                            }

                            this.calcMinMax();
                            this.calcLabels();
                        },


                        /**
                         * calculates pointer X in percent
                         */
                        calcPointerPercent: function () {
                            if (!this.coords.w_rs) {
                                this.coords.p_pointer = 0;
                                return;
                            }

                            if (this.coords.x_pointer < 0 || isNaN(this.coords.x_pointer)  ) {
                                this.coords.x_pointer = 0;
                            } else if (this.coords.x_pointer > this.coords.w_rs) {
                                this.coords.x_pointer = this.coords.w_rs;
                            }

                            this.coords.p_pointer = this.toFixed(this.coords.x_pointer / this.coords.w_rs * 100);
                        },

                        convertToRealPercent: function (fake) {
                            var full = 100 - this.coords.p_handle;
                            return fake / full * 100;
                        },

                        convertToFakePercent: function (real) {
                            var full = 100 - this.coords.p_handle;
                            return real / 100 * full;
                        },

                        getHandleX: function () {
                            var max = 100 - this.coords.p_handle,
                                x = this.toFixed(this.coords.p_pointer - this.coords.p_gap);

                            if (x < 0) {
                                x = 0;
                            } else if (x > max) {
                                x = max;
                            }

                            return x;
                        },

                        calcHandlePercent: function () {
                            if (this.options.type === "single") {
                                this.coords.w_handle = this.$cache.s_single.outerWidth(false);
                            } else {
                                this.coords.w_handle = this.$cache.s_from.outerWidth(false);
                            }

                            this.coords.p_handle = this.toFixed(this.coords.w_handle / this.coords.w_rs * 100);
                        },

                        /**
                         * Find closest handle to pointer click
                         *
                         * @param real_x {Number}
                         * @returns {String}
                         */
                        chooseHandle: function (real_x) {
                            if (this.options.type === "single") {
                                return "single";
                            } else {
                                var m_point = this.coords.p_from_real + ((this.coords.p_to_real - this.coords.p_from_real) / 2);
                                if (real_x >= m_point) {
                                    return this.options.to_fixed ? "from" : "to";
                                } else {
                                    return this.options.from_fixed ? "to" : "from";
                                }
                            }
                        },

                        /**
                         * Measure Min and Max labels width in percent
                         */
                        calcMinMax: function () {
                            if (!this.coords.w_rs) {
                                return;
                            }

                            this.labels.p_min = this.labels.w_min / this.coords.w_rs * 100;
                            this.labels.p_max = this.labels.w_max / this.coords.w_rs * 100;
                        },

                        /**
                         * Measure labels width and X in percent
                         */
                        calcLabels: function () {
                            if (!this.coords.w_rs || this.options.hide_from_to) {
                                return;
                            }

                            if (this.options.type === "single") {

                                this.labels.w_single = this.$cache.single.outerWidth(false);
                                this.labels.p_single_fake = this.labels.w_single / this.coords.w_rs * 100;
                                this.labels.p_single_left = this.coords.p_single_fake + (this.coords.p_handle / 2) - (this.labels.p_single_fake / 2);
                                this.labels.p_single_left = this.checkEdges(this.labels.p_single_left, this.labels.p_single_fake);

                            } else {

                                this.labels.w_from = this.$cache.from.outerWidth(false);
                                this.labels.p_from_fake = this.labels.w_from / this.coords.w_rs * 100;
                                this.labels.p_from_left = this.coords.p_from_fake + (this.coords.p_handle / 2) - (this.labels.p_from_fake / 2);
                                this.labels.p_from_left = this.toFixed(this.labels.p_from_left);
                                this.labels.p_from_left = this.checkEdges(this.labels.p_from_left, this.labels.p_from_fake);

                                this.labels.w_to = this.$cache.to.outerWidth(false);
                                this.labels.p_to_fake = this.labels.w_to / this.coords.w_rs * 100;
                                this.labels.p_to_left = this.coords.p_to_fake + (this.coords.p_handle / 2) - (this.labels.p_to_fake / 2);
                                this.labels.p_to_left = this.toFixed(this.labels.p_to_left);
                                this.labels.p_to_left = this.checkEdges(this.labels.p_to_left, this.labels.p_to_fake);

                                this.labels.w_single = this.$cache.single.outerWidth(false);
                                this.labels.p_single_fake = this.labels.w_single / this.coords.w_rs * 100;
                                this.labels.p_single_left = ((this.labels.p_from_left + this.labels.p_to_left + this.labels.p_to_fake) / 2) - (this.labels.p_single_fake / 2);
                                this.labels.p_single_left = this.toFixed(this.labels.p_single_left);
                                this.labels.p_single_left = this.checkEdges(this.labels.p_single_left, this.labels.p_single_fake);

                            }
                        },



                        // =============================================================================================================
                        // Drawings

                        /**
                         * Main function called in request animation frame
                         * to update everything
                         */
                        updateScene: function () {
                            if (this.raf_id) {
                                cancelAnimationFrame(this.raf_id);
                                this.raf_id = null;
                            }

                            clearTimeout(this.update_tm);
                            this.update_tm = null;

                            if (!this.options) {
                                return;
                            }

                            this.drawHandles();

                            if (this.is_active) {
                                this.raf_id = requestAnimationFrame(this.updateScene.bind(this));
                            } else {
                                this.update_tm = setTimeout(this.updateScene.bind(this), 300);
                            }
                        },

                        /**
                         * Draw handles
                         */
                        drawHandles: function () {
                            this.coords.w_rs = this.$cache.rs.outerWidth(false);

                            if (!this.coords.w_rs) {
                                return;
                            }

                            if (this.coords.w_rs !== this.coords.w_rs_old) {
                                this.target = "base";
                                this.is_resize = true;
                            }

                            if (this.coords.w_rs !== this.coords.w_rs_old || this.force_redraw) {
                                this.setMinMax();
                                this.calc(true);
                                this.drawLabels();
                                if (this.options.grid) {
                                    this.calcGridMargin();
                                    this.calcGridLabels();
                                }
                                this.force_redraw = true;
                                this.coords.w_rs_old = this.coords.w_rs;
                                this.drawShadow();
                            }

                            if (!this.coords.w_rs) {
                                return;
                            }

                            if (!this.dragging && !this.force_redraw && !this.is_key) {
                                return;
                            }

                            if (this.old_from !== this.result.from || this.old_to !== this.result.to || this.force_redraw || this.is_key) {

                                this.drawLabels();

                                this.$cache.bar[0].style.left = this.coords.p_bar_x + "%";
                                this.$cache.bar[0].style.width = this.coords.p_bar_w + "%";

                                if (this.options.type === "single") {
                                    this.$cache.bar[0].style.left = 0;
                                    this.$cache.bar[0].style.width = this.coords.p_bar_w + this.coords.p_bar_x + "%";

                                    this.$cache.s_single[0].style.left = this.coords.p_single_fake + "%";

                                    this.$cache.single[0].style.left = this.labels.p_single_left + "%";
                                } else {
                                    this.$cache.s_from[0].style.left = this.coords.p_from_fake + "%";
                                    this.$cache.s_to[0].style.left = this.coords.p_to_fake + "%";

                                    if (this.old_from !== this.result.from || this.force_redraw) {
                                        this.$cache.from[0].style.left = this.labels.p_from_left + "%";
                                    }
                                    if (this.old_to !== this.result.to || this.force_redraw) {
                                        this.$cache.to[0].style.left = this.labels.p_to_left + "%";
                                    }

                                    this.$cache.single[0].style.left = this.labels.p_single_left + "%";
                                }

                                this.writeToInput();

                                if ((this.old_from !== this.result.from || this.old_to !== this.result.to) && !this.is_start) {
                                    this.$cache.input.trigger("change");
                                    this.$cache.input.trigger("input");
                                }

                                this.old_from = this.result.from;
                                this.old_to = this.result.to;

                                // callbacks call
                                if (!this.is_resize && !this.is_update && !this.is_start && !this.is_finish) {
                                    this.callOnChange();
                                }
                                if (this.is_key || this.is_click) {
                                    this.is_key = false;
                                    this.is_click = false;
                                    this.callOnFinish();
                                }

                                this.is_update = false;
                                this.is_resize = false;
                                this.is_finish = false;
                            }

                            this.is_start = false;
                            this.is_key = false;
                            this.is_click = false;
                            this.force_redraw = false;
                        },

                        /**
                         * Draw labels
                         * measure labels collisions
                         * collapse close labels
                         */
                        drawLabels: function () {
                            if (!this.options) {
                                return;
                            }

                            var values_num = this.options.values.length;
                            var p_values = this.options.p_values;
                            var text_single;
                            var text_from;
                            var text_to;
                            var from_pretty;
                            var to_pretty;

                            if (this.options.hide_from_to) {
                                return;
                            }

                            if (this.options.type === "single") {

                                if (values_num) {
                                    text_single = this.decorate(p_values[this.result.from]);
                                    this.$cache.single.html(text_single);
                                } else {
                                    from_pretty = this._prettify(this.result.from);

                                    text_single = this.decorate(from_pretty, this.result.from);
                                    this.$cache.single.html(text_single);
                                }

                                this.calcLabels();

                                if (this.labels.p_single_left < this.labels.p_min + 1) {
                                    this.$cache.min[0].style.visibility = "hidden";
                                } else {
                                    this.$cache.min[0].style.visibility = "visible";
                                }

                                if (this.labels.p_single_left + this.labels.p_single_fake > 100 - this.labels.p_max - 1) {
                                    this.$cache.max[0].style.visibility = "hidden";
                                } else {
                                    this.$cache.max[0].style.visibility = "visible";
                                }

                            } else {

                                if (values_num) {

                                    if (this.options.decorate_both) {
                                        text_single = this.decorate(p_values[this.result.from]);
                                        text_single += this.options.values_separator;
                                        text_single += this.decorate(p_values[this.result.to]);
                                    } else {
                                        text_single = this.decorate(p_values[this.result.from] + this.options.values_separator + p_values[this.result.to]);
                                    }
                                    text_from = this.decorate(p_values[this.result.from]);
                                    text_to = this.decorate(p_values[this.result.to]);

                                    this.$cache.single.html(text_single);
                                    this.$cache.from.html(text_from);
                                    this.$cache.to.html(text_to);

                                } else {
                                    from_pretty = this._prettify(this.result.from);
                                    to_pretty = this._prettify(this.result.to);

                                    if (this.options.decorate_both) {
                                        text_single = this.decorate(from_pretty, this.result.from);
                                        text_single += this.options.values_separator;
                                        text_single += this.decorate(to_pretty, this.result.to);
                                    } else {
                                        text_single = this.decorate(from_pretty + this.options.values_separator + to_pretty, this.result.to);
                                    }
                                    text_from = this.decorate(from_pretty, this.result.from);
                                    text_to = this.decorate(to_pretty, this.result.to);

                                    this.$cache.single.html(text_single);
                                    this.$cache.from.html(text_from);
                                    this.$cache.to.html(text_to);

                                }

                                this.calcLabels();

                                var min = Math.min(this.labels.p_single_left, this.labels.p_from_left),
                                    single_left = this.labels.p_single_left + this.labels.p_single_fake,
                                    to_left = this.labels.p_to_left + this.labels.p_to_fake,
                                    max = Math.max(single_left, to_left);

                                if (this.labels.p_from_left + this.labels.p_from_fake >= this.labels.p_to_left) {
                                    this.$cache.from[0].style.visibility = "hidden";
                                    this.$cache.to[0].style.visibility = "hidden";
                                    this.$cache.single[0].style.visibility = "visible";

                                    if (this.result.from === this.result.to) {
                                        if (this.target === "from") {
                                            this.$cache.from[0].style.visibility = "visible";
                                        } else if (this.target === "to") {
                                            this.$cache.to[0].style.visibility = "visible";
                                        } else if (!this.target) {
                                            this.$cache.from[0].style.visibility = "visible";
                                        }
                                        this.$cache.single[0].style.visibility = "hidden";
                                        max = to_left;
                                    } else {
                                        this.$cache.from[0].style.visibility = "hidden";
                                        this.$cache.to[0].style.visibility = "hidden";
                                        this.$cache.single[0].style.visibility = "visible";
                                        max = Math.max(single_left, to_left);
                                    }
                                } else {
                                    this.$cache.from[0].style.visibility = "visible";
                                    this.$cache.to[0].style.visibility = "visible";
                                    this.$cache.single[0].style.visibility = "hidden";
                                }

                                if (min < this.labels.p_min + 1) {
                                    this.$cache.min[0].style.visibility = "hidden";
                                } else {
                                    this.$cache.min[0].style.visibility = "visible";
                                }

                                if (max > 100 - this.labels.p_max - 1) {
                                    this.$cache.max[0].style.visibility = "hidden";
                                } else {
                                    this.$cache.max[0].style.visibility = "visible";
                                }

                            }
                        },

                        /**
                         * Draw shadow intervals
                         */
                        drawShadow: function () {
                            var o = this.options,
                                c = this.$cache,

                                is_from_min = typeof o.from_min === "number" && !isNaN(o.from_min),
                                is_from_max = typeof o.from_max === "number" && !isNaN(o.from_max),
                                is_to_min = typeof o.to_min === "number" && !isNaN(o.to_min),
                                is_to_max = typeof o.to_max === "number" && !isNaN(o.to_max),

                                from_min,
                                from_max,
                                to_min,
                                to_max;

                            if (o.type === "single") {
                                if (o.from_shadow && (is_from_min || is_from_max)) {
                                    from_min = this.convertToPercent(is_from_min ? o.from_min : o.min);
                                    from_max = this.convertToPercent(is_from_max ? o.from_max : o.max) - from_min;
                                    from_min = this.toFixed(from_min - (this.coords.p_handle / 100 * from_min));
                                    from_max = this.toFixed(from_max - (this.coords.p_handle / 100 * from_max));
                                    from_min = from_min + (this.coords.p_handle / 2);

                                    c.shad_single[0].style.display = "block";
                                    c.shad_single[0].style.left = from_min + "%";
                                    c.shad_single[0].style.width = from_max + "%";
                                } else {
                                    c.shad_single[0].style.display = "none";
                                }
                            } else {
                                if (o.from_shadow && (is_from_min || is_from_max)) {
                                    from_min = this.convertToPercent(is_from_min ? o.from_min : o.min);
                                    from_max = this.convertToPercent(is_from_max ? o.from_max : o.max) - from_min;
                                    from_min = this.toFixed(from_min - (this.coords.p_handle / 100 * from_min));
                                    from_max = this.toFixed(from_max - (this.coords.p_handle / 100 * from_max));
                                    from_min = from_min + (this.coords.p_handle / 2);

                                    c.shad_from[0].style.display = "block";
                                    c.shad_from[0].style.left = from_min + "%";
                                    c.shad_from[0].style.width = from_max + "%";
                                } else {
                                    c.shad_from[0].style.display = "none";
                                }

                                if (o.to_shadow && (is_to_min || is_to_max)) {
                                    to_min = this.convertToPercent(is_to_min ? o.to_min : o.min);
                                    to_max = this.convertToPercent(is_to_max ? o.to_max : o.max) - to_min;
                                    to_min = this.toFixed(to_min - (this.coords.p_handle / 100 * to_min));
                                    to_max = this.toFixed(to_max - (this.coords.p_handle / 100 * to_max));
                                    to_min = to_min + (this.coords.p_handle / 2);

                                    c.shad_to[0].style.display = "block";
                                    c.shad_to[0].style.left = to_min + "%";
                                    c.shad_to[0].style.width = to_max + "%";
                                } else {
                                    c.shad_to[0].style.display = "none";
                                }
                            }
                        },



                        /**
                         * Write values to input element
                         */
                        writeToInput: function () {
                            if (this.options.type === "single") {
                                if (this.options.values.length) {
                                    this.$cache.input.prop("value", this.result.from_value);
                                } else {
                                    this.$cache.input.prop("value", this.result.from);
                                }
                                this.$cache.input.data("from", this.result.from);
                            } else {
                                if (this.options.values.length) {
                                    this.$cache.input.prop("value", this.result.from_value + this.options.input_values_separator + this.result.to_value);
                                } else {
                                    this.$cache.input.prop("value", this.result.from + this.options.input_values_separator + this.result.to);
                                }
                                this.$cache.input.data("from", this.result.from);
                                this.$cache.input.data("to", this.result.to);
                            }
                        },



                        // =============================================================================================================
                        // Callbacks

                        callOnStart: function () {
                            this.writeToInput();

                            if (this.options.onStart && typeof this.options.onStart === "function") {
                                if (this.options.scope) {
                                    this.options.onStart.call(this.options.scope, this.result);
                                } else {
                                    this.options.onStart(this.result);
                                }
                            }
                        },
                        callOnChange: function () {
                            this.writeToInput();

                            if (this.options.onChange && typeof this.options.onChange === "function") {
                                if (this.options.scope) {
                                    this.options.onChange.call(this.options.scope, this.result);
                                } else {
                                    this.options.onChange(this.result);
                                }
                            }
                        },
                        callOnFinish: function () {
                            this.writeToInput();

                            if (this.options.onFinish && typeof this.options.onFinish === "function") {
                                if (this.options.scope) {
                                    this.options.onFinish.call(this.options.scope, this.result);
                                } else {
                                    this.options.onFinish(this.result);
                                }
                            }
                        },
                        callOnUpdate: function () {
                            this.writeToInput();

                            if (this.options.onUpdate && typeof this.options.onUpdate === "function") {
                                if (this.options.scope) {
                                    this.options.onUpdate.call(this.options.scope, this.result);
                                } else {
                                    this.options.onUpdate(this.result);
                                }
                            }
                        },




                        // =============================================================================================================
                        // Service methods

                        toggleInput: function () {
                            this.$cache.input.toggleClass("irs-hidden-input");

                            if (this.has_tab_index) {
                                this.$cache.input.prop("tabindex", -1);
                            } else {
                                this.$cache.input.removeProp("tabindex");
                            }

                            this.has_tab_index = !this.has_tab_index;
                        },

                        /**
                         * Convert real value to percent
                         *
                         * @param value {Number} X in real
                         * @param no_min {boolean=} don't use min value
                         * @returns {Number} X in percent
                         */
                        convertToPercent: function (value, no_min) {
                            var diapason = this.options.max - this.options.min,
                                one_percent = diapason / 100,
                                val, percent;

                            if (!diapason) {
                                this.no_diapason = true;
                                return 0;
                            }

                            if (no_min) {
                                val = value;
                            } else {
                                val = value - this.options.min;
                            }

                            percent = val / one_percent;

                            return this.toFixed(percent);
                        },

                        /**
                         * Convert percent to real values
                         *
                         * @param percent {Number} X in percent
                         * @returns {Number} X in real
                         */
                        convertToValue: function (percent) {
                            var min = this.options.min,
                                max = this.options.max,
                                min_decimals = min.toString().split(".")[1],
                                max_decimals = max.toString().split(".")[1],
                                min_length, max_length,
                                avg_decimals = 0,
                                abs = 0;

                            if (percent === 0) {
                                return this.options.min;
                            }
                            if (percent === 100) {
                                return this.options.max;
                            }


                            if (min_decimals) {
                                min_length = min_decimals.length;
                                avg_decimals = min_length;
                            }
                            if (max_decimals) {
                                max_length = max_decimals.length;
                                avg_decimals = max_length;
                            }
                            if (min_length && max_length) {
                                avg_decimals = (min_length >= max_length) ? min_length : max_length;
                            }

                            if (min < 0) {
                                abs = Math.abs(min);
                                min = +(min + abs).toFixed(avg_decimals);
                                max = +(max + abs).toFixed(avg_decimals);
                            }

                            var number = ((max - min) / 100 * percent) + min,
                                string = this.options.step.toString().split(".")[1],
                                result;

                            if (string) {
                                number = +number.toFixed(string.length);
                            } else {
                                number = number / this.options.step;
                                number = number * this.options.step;

                                number = +number.toFixed(0);
                            }

                            if (abs) {
                                number -= abs;
                            }

                            if (string) {
                                result = +number.toFixed(string.length);
                            } else {
                                result = this.toFixed(number);
                            }

                            if (result < this.options.min) {
                                result = this.options.min;
                            } else if (result > this.options.max) {
                                result = this.options.max;
                            }

                            return result;
                        },

                        /**
                         * Round percent value with step
                         *
                         * @param percent {Number}
                         * @returns percent {Number} rounded
                         */
                        calcWithStep: function (percent) {
                            var rounded = Math.round(percent / this.coords.p_step) * this.coords.p_step;

                            if (rounded > 100) {
                                rounded = 100;
                            }
                            if (percent === 100) {
                                rounded = 100;
                            }

                            return this.toFixed(rounded);
                        },

                        checkMinInterval: function (p_current, p_next, type) {
                            var o = this.options,
                                current,
                                next;

                            if (!o.min_interval) {
                                return p_current;
                            }

                            current = this.convertToValue(p_current);
                            next = this.convertToValue(p_next);

                            if (type === "from") {

                                if (next - current < o.min_interval) {
                                    current = next - o.min_interval;
                                }

                            } else {

                                if (current - next < o.min_interval) {
                                    current = next + o.min_interval;
                                }

                            }

                            return this.convertToPercent(current);
                        },

                        checkMaxInterval: function (p_current, p_next, type) {
                            var o = this.options,
                                current,
                                next;

                            if (!o.max_interval) {
                                return p_current;
                            }

                            current = this.convertToValue(p_current);
                            next = this.convertToValue(p_next);

                            if (type === "from") {

                                if (next - current > o.max_interval) {
                                    current = next - o.max_interval;
                                }

                            } else {

                                if (current - next > o.max_interval) {
                                    current = next + o.max_interval;
                                }

                            }

                            return this.convertToPercent(current);
                        },

                        checkDiapason: function (p_num, min, max) {
                            var num = this.convertToValue(p_num),
                                o = this.options;

                            if (typeof min !== "number") {
                                min = o.min;
                            }

                            if (typeof max !== "number") {
                                max = o.max;
                            }

                            if (num < min) {
                                num = min;
                            }

                            if (num > max) {
                                num = max;
                            }

                            return this.convertToPercent(num);
                        },

                        toFixed: function (num) {
                            num = num.toFixed(20);
                            return +num;
                        },

                        _prettify: function (num) {
                            if (!this.options.prettify_enabled) {
                                return num;
                            }

                            if (this.options.prettify && typeof this.options.prettify === "function") {
                                return this.options.prettify(num);
                            } else {
                                return this.prettify(num);
                            }
                        },

                        prettify: function (num) {
                            var n = num.toString();
                            return n.replace(/(\d{1,3}(?=(?:\d\d\d)+(?!\d)))/g, "$1" + this.options.prettify_separator);
                        },

                        checkEdges: function (left, width) {
                            if (!this.options.force_edges) {
                                return this.toFixed(left);
                            }

                            if (left < 0) {
                                left = 0;
                            } else if (left > 100 - width) {
                                left = 100 - width;
                            }

                            return this.toFixed(left);
                        },

                        validate: function () {
                            var o = this.options,
                                r = this.result,
                                v = o.values,
                                vl = v.length,
                                value,
                                i;

                            if (typeof o.min === "string") o.min = +o.min;
                            if (typeof o.max === "string") o.max = +o.max;
                            if (typeof o.from === "string") o.from = +o.from;
                            if (typeof o.to === "string") o.to = +o.to;
                            if (typeof o.step === "string") o.step = +o.step;

                            if (typeof o.from_min === "string") o.from_min = +o.from_min;
                            if (typeof o.from_max === "string") o.from_max = +o.from_max;
                            if (typeof o.to_min === "string") o.to_min = +o.to_min;
                            if (typeof o.to_max === "string") o.to_max = +o.to_max;

                            if (typeof o.grid_num === "string") o.grid_num = +o.grid_num;

                            if (o.max < o.min) {
                                o.max = o.min;
                            }

                            if (vl) {
                                o.p_values = [];
                                o.min = 0;
                                o.max = vl - 1;
                                o.step = 1;
                                o.grid_num = o.max;
                                o.grid_snap = true;

                                for (i = 0; i < vl; i++) {
                                    value = +v[i];

                                    if (!isNaN(value)) {
                                        v[i] = value;
                                        value = this._prettify(value);
                                    } else {
                                        value = v[i];
                                    }

                                    o.p_values.push(value);
                                }
                            }

                            if (typeof o.from !== "number" || isNaN(o.from)) {
                                o.from = o.min;
                            }

                            if (typeof o.to !== "number" || isNaN(o.to)) {
                                o.to = o.max;
                            }

                            if (o.type === "single") {

                                if (o.from < o.min) o.from = o.min;
                                if (o.from > o.max) o.from = o.max;

                            } else {

                                if (o.from < o.min) o.from = o.min;
                                if (o.from > o.max) o.from = o.max;

                                if (o.to < o.min) o.to = o.min;
                                if (o.to > o.max) o.to = o.max;

                                if (this.update_check.from) {

                                    if (this.update_check.from !== o.from) {
                                        if (o.from > o.to) o.from = o.to;
                                    }
                                    if (this.update_check.to !== o.to) {
                                        if (o.to < o.from) o.to = o.from;
                                    }

                                }

                                if (o.from > o.to) o.from = o.to;
                                if (o.to < o.from) o.to = o.from;

                            }

                            if (typeof o.step !== "number" || isNaN(o.step) || !o.step || o.step < 0) {
                                o.step = 1;
                            }

                            if (typeof o.from_min === "number" && o.from < o.from_min) {
                                o.from = o.from_min;
                            }

                            if (typeof o.from_max === "number" && o.from > o.from_max) {
                                o.from = o.from_max;
                            }

                            if (typeof o.to_min === "number" && o.to < o.to_min) {
                                o.to = o.to_min;
                            }

                            if (typeof o.to_max === "number" && o.from > o.to_max) {
                                o.to = o.to_max;
                            }

                            if (r) {
                                if (r.min !== o.min) {
                                    r.min = o.min;
                                }

                                if (r.max !== o.max) {
                                    r.max = o.max;
                                }

                                if (r.from < r.min || r.from > r.max) {
                                    r.from = o.from;
                                }

                                if (r.to < r.min || r.to > r.max) {
                                    r.to = o.to;
                                }
                            }

                            if (typeof o.min_interval !== "number" || isNaN(o.min_interval) || !o.min_interval || o.min_interval < 0) {
                                o.min_interval = 0;
                            }

                            if (typeof o.max_interval !== "number" || isNaN(o.max_interval) || !o.max_interval || o.max_interval < 0) {
                                o.max_interval = 0;
                            }

                            if (o.min_interval && o.min_interval > o.max - o.min) {
                                o.min_interval = o.max - o.min;
                            }

                            if (o.max_interval && o.max_interval > o.max - o.min) {
                                o.max_interval = o.max - o.min;
                            }
                        },

                        decorate: function (num, original) {
                            var decorated = "",
                                o = this.options;

                            if (o.prefix) {
                                decorated += o.prefix;
                            }

                            decorated += num;

                            if (o.max_postfix) {
                                if (o.values.length && num === o.p_values[o.max]) {
                                    decorated += o.max_postfix;
                                    if (o.postfix) {
                                        decorated += " ";
                                    }
                                } else if (original === o.max) {
                                    decorated += o.max_postfix;
                                    if (o.postfix) {
                                        decorated += " ";
                                    }
                                }
                            }

                            if (o.postfix) {
                                decorated += o.postfix;
                            }

                            return decorated;
                        },

                        updateFrom: function () {
                            this.result.from = this.options.from;
                            this.result.from_percent = this.convertToPercent(this.result.from);
                            this.result.from_pretty = this._prettify(this.result.from);
                            if (this.options.values) {
                                this.result.from_value = this.options.values[this.result.from];
                            }
                        },

                        updateTo: function () {
                            this.result.to = this.options.to;
                            this.result.to_percent = this.convertToPercent(this.result.to);
                            this.result.to_pretty = this._prettify(this.result.to);
                            if (this.options.values) {
                                this.result.to_value = this.options.values[this.result.to];
                            }
                        },

                        updateResult: function () {
                            this.result.min = this.options.min;
                            this.result.max = this.options.max;
                            this.updateFrom();
                            this.updateTo();
                        },


                        // =============================================================================================================
                        // Grid

                        appendGrid: function () {
                            if (!this.options.grid) {
                                return;
                            }

                            var o = this.options,
                                i, z,

                                total = o.max - o.min,
                                big_num = o.grid_num,
                                big_p = 0,
                                big_w = 0,

                                small_max = 4,
                                local_small_max,
                                small_p,
                                small_w = 0,

                                result,
                                html = '';



                            this.calcGridMargin();

                            if (o.grid_snap) {
                                big_num = total / o.step;
                            }

                            if (big_num > 50) big_num = 50;
                            big_p = this.toFixed(100 / big_num);

                            if (big_num > 4) {
                                small_max = 3;
                            }
                            if (big_num > 7) {
                                small_max = 2;
                            }
                            if (big_num > 14) {
                                small_max = 1;
                            }
                            if (big_num > 28) {
                                small_max = 0;
                            }

                            for (i = 0; i < big_num + 1; i++) {
                                local_small_max = small_max;

                                big_w = this.toFixed(big_p * i);

                                if (big_w > 100) {
                                    big_w = 100;
                                }
                                this.coords.big[i] = big_w;

                                small_p = (big_w - (big_p * (i - 1))) / (local_small_max + 1);

                                for (z = 1; z <= local_small_max; z++) {
                                    if (big_w === 0) {
                                        break;
                                    }

                                    small_w = this.toFixed(big_w - (small_p * z));

                                    html += '<span class="irs-grid-pol small" style="left: ' + small_w + '%"></span>';
                                }

                                html += '<span class="irs-grid-pol" style="left: ' + big_w + '%"></span>';

                                result = this.convertToValue(big_w);
                                if (o.values.length) {
                                    result = o.p_values[result];
                                } else {
                                    result = this._prettify(result);
                                }

                                html += '<span class="irs-grid-text js-grid-text-' + i + '" style="left: ' + big_w + '%">' + result + '</span>';
                            }
                            this.coords.big_num = Math.ceil(big_num + 1);



                            this.$cache.cont.addClass("irs-with-grid");
                            this.$cache.grid.html(html);
                            this.cacheGridLabels();
                        },

                        cacheGridLabels: function () {
                            var $label, i,
                                num = this.coords.big_num;

                            for (i = 0; i < num; i++) {
                                $label = this.$cache.grid.find(".js-grid-text-" + i);
                                this.$cache.grid_labels.push($label);
                            }

                            this.calcGridLabels();
                        },

                        calcGridLabels: function () {
                            var i, label, start = [], finish = [],
                                num = this.coords.big_num;

                            for (i = 0; i < num; i++) {
                                this.coords.big_w[i] = this.$cache.grid_labels[i].outerWidth(false);
                                this.coords.big_p[i] = this.toFixed(this.coords.big_w[i] / this.coords.w_rs * 100);
                                this.coords.big_x[i] = this.toFixed(this.coords.big_p[i] / 2);

                                start[i] = this.toFixed(this.coords.big[i] - this.coords.big_x[i]);
                                finish[i] = this.toFixed(start[i] + this.coords.big_p[i]);
                            }

                            if (this.options.force_edges) {
                                if (start[0] < -this.coords.grid_gap) {
                                    start[0] = -this.coords.grid_gap;
                                    finish[0] = this.toFixed(start[0] + this.coords.big_p[0]);

                                    this.coords.big_x[0] = this.coords.grid_gap;
                                }

                                if (finish[num - 1] > 100 + this.coords.grid_gap) {
                                    finish[num - 1] = 100 + this.coords.grid_gap;
                                    start[num - 1] = this.toFixed(finish[num - 1] - this.coords.big_p[num - 1]);

                                    this.coords.big_x[num - 1] = this.toFixed(this.coords.big_p[num - 1] - this.coords.grid_gap);
                                }
                            }

                            this.calcGridCollision(2, start, finish);
                            this.calcGridCollision(4, start, finish);

                            for (i = 0; i < num; i++) {
                                label = this.$cache.grid_labels[i][0];

                                if (this.coords.big_x[i] !== Number.POSITIVE_INFINITY) {
                                    label.style.marginLeft = -this.coords.big_x[i] + "%";
                                }
                            }
                        },

                        // Collisions Calc Beta
                        // TODO: Refactor then have plenty of time
                        calcGridCollision: function (step, start, finish) {
                            var i, next_i, label,
                                num = this.coords.big_num;

                            for (i = 0; i < num; i += step) {
                                next_i = i + (step / 2);
                                if (next_i >= num) {
                                    break;
                                }

                                label = this.$cache.grid_labels[next_i][0];

                                if (finish[i] <= start[next_i]) {
                                    label.style.visibility = "visible";
                                } else {
                                    label.style.visibility = "hidden";
                                }
                            }
                        },

                        calcGridMargin: function () {
                            if (!this.options.grid_margin) {
                                return;
                            }

                            this.coords.w_rs = this.$cache.rs.outerWidth(false);
                            if (!this.coords.w_rs) {
                                return;
                            }

                            if (this.options.type === "single") {
                                this.coords.w_handle = this.$cache.s_single.outerWidth(false);
                            } else {
                                this.coords.w_handle = this.$cache.s_from.outerWidth(false);
                            }
                            this.coords.p_handle = this.toFixed(this.coords.w_handle  / this.coords.w_rs * 100);
                            this.coords.grid_gap = this.toFixed((this.coords.p_handle / 2) - 0.1);

                            this.$cache.grid[0].style.width = this.toFixed(100 - this.coords.p_handle) + "%";
                            this.$cache.grid[0].style.left = this.coords.grid_gap + "%";
                        },



                        // =============================================================================================================
                        // Public methods

                        update: function (options) {
                            if (!this.input) {
                                return;
                            }

                            this.is_update = true;

                            this.options.from = this.result.from;
                            this.options.to = this.result.to;
                            this.update_check.from = this.result.from;
                            this.update_check.to = this.result.to;

                            this.options = $.extend(this.options, options);
                            this.validate();
                            this.updateResult(options);

                            this.toggleInput();
                            this.remove();
                            this.init(true);
                        },

                        reset: function () {
                            if (!this.input) {
                                return;
                            }

                            this.updateResult();
                            this.update();
                        },

                        destroy: function () {
                            if (!this.input) {
                                return;
                            }

                            this.toggleInput();
                            this.$cache.input.prop("readonly", false);
                            $.data(this.input, "ionRangeSlider", null);

                            this.remove();
                            this.input = null;
                            this.options = null;
                        }
                    };

                    $.fn.ionRangeSlider = function (options) {
                        return this.each(function() {
                            if (!$.data(this, "ionRangeSlider")) {
                                $.data(this, "ionRangeSlider", new IonRangeSlider(this, options, plugin_count++));
                            }
                        });
                    };



                    // =================================================================================================================
                    // http://paulirish.com/2011/requestanimationframe-for-smart-animating/
                    // http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating

                    // requestAnimationFrame polyfill by Erik Möller. fixes from Paul Irish and Tino Zijdel

                    // MIT license

                    (function() {
                        var lastTime = 0;
                        var vendors = ['ms', 'moz', 'webkit', 'o'];
                        for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
                            window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
                            window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame']
                                || window[vendors[x]+'CancelRequestAnimationFrame'];
                        }

                        if (!window.requestAnimationFrame)
                            window.requestAnimationFrame = function(callback, element) {
                                var currTime = new Date().getTime();
                                var timeToCall = Math.max(0, 16 - (currTime - lastTime));
                                var id = window.setTimeout(function() { callback(currTime + timeToCall); },
                                    timeToCall);
                                lastTime = currTime + timeToCall;
                                return id;
                            };

                        if (!window.cancelAnimationFrame)
                            window.cancelAnimationFrame = function(id) {
                                clearTimeout(id);
                            };
                    }());

                }));

                /* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

            /***/ }),

        /***/ "./node_modules/jquery-inview/jquery.inview.js":
        /*!*****************************************************!*\
  !*** ./node_modules/jquery-inview/jquery.inview.js ***!
  \*****************************************************/
        /*! no static exports found */
        /***/ (function(module, exports, __webpack_require__) {

            var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
             * author Christopher Blum
             *    - based on the idea of Remy Sharp, http://remysharp.com/2009/01/26/element-in-view-event-plugin/
             *    - forked from http://github.com/zuk/jquery.inview/
             */
            (function (factory) {
                if (true) {
                    // AMD
                    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                        __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                            (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                } else {}
            }(function ($) {

                var inviewObjects = [], viewportSize, viewportOffset,
                    d = document, w = window, documentElement = d.documentElement, timer;

                $.event.special.inview = {
                    add: function(data) {
                        inviewObjects.push({ data: data, $element: $(this), element: this });
                        // Use setInterval in order to also make sure this captures elements within
                        // "overflow:scroll" elements or elements that appeared in the dom tree due to
                        // dom manipulation and reflow
                        // old: $(window).scroll(checkInView);
                        //
                        // By the way, iOS (iPad, iPhone, ...) seems to not execute, or at least delays
                        // intervals while the user scrolls. Therefore the inview event might fire a bit late there
                        //
                        // Don't waste cycles with an interval until we get at least one element that
                        // has bound to the inview event.
                        if (!timer && inviewObjects.length) {
                            timer = setInterval(checkInView, 250);
                        }
                    },

                    remove: function(data) {
                        for (var i=0; i<inviewObjects.length; i++) {
                            var inviewObject = inviewObjects[i];
                            if (inviewObject.element === this && inviewObject.data.guid === data.guid) {
                                inviewObjects.splice(i, 1);
                                break;
                            }
                        }

                        // Clear interval when we no longer have any elements listening
                        if (!inviewObjects.length) {
                            clearInterval(timer);
                            timer = null;
                        }
                    }
                };

                function getViewportSize() {
                    var mode, domObject, size = { height: w.innerHeight, width: w.innerWidth };

                    // if this is correct then return it. iPad has compat Mode, so will
                    // go into check clientHeight/clientWidth (which has the wrong value).
                    if (!size.height) {
                        mode = d.compatMode;
                        if (mode || !$.support.boxModel) { // IE, Gecko
                            domObject = mode === 'CSS1Compat' ?
                                documentElement : // Standards
                                d.body; // Quirks
                            size = {
                                height: domObject.clientHeight,
                                width:  domObject.clientWidth
                            };
                        }
                    }

                    return size;
                }

                function getViewportOffset() {
                    return {
                        top:  w.pageYOffset || documentElement.scrollTop   || d.body.scrollTop,
                        left: w.pageXOffset || documentElement.scrollLeft  || d.body.scrollLeft
                    };
                }

                function checkInView() {
                    if (!inviewObjects.length) {
                        return;
                    }

                    var i = 0, $elements = $.map(inviewObjects, function(inviewObject) {
                        var selector  = inviewObject.data.selector,
                            $element  = inviewObject.$element;
                        return selector ? $element.find(selector) : $element;
                    });

                    viewportSize   = viewportSize   || getViewportSize();
                    viewportOffset = viewportOffset || getViewportOffset();

                    for (; i<inviewObjects.length; i++) {
                        // Ignore elements that are not in the DOM tree
                        if (!$.contains(documentElement, $elements[i][0])) {
                            continue;
                        }

                        var $element      = $($elements[i]),
                            elementSize   = { height: $element[0].offsetHeight, width: $element[0].offsetWidth },
                            elementOffset = $element.offset(),
                            inView        = $element.data('inview');

                        // Don't ask me why because I haven't figured out yet:
                        // viewportOffset and viewportSize are sometimes suddenly null in Firefox 5.
                        // Even though it sounds weird:
                        // It seems that the execution of this function is interferred by the onresize/onscroll event
                        // where viewportOffset and viewportSize are unset
                        if (!viewportOffset || !viewportSize) {
                            return;
                        }

                        if (elementOffset.top + elementSize.height > viewportOffset.top &&
                            elementOffset.top < viewportOffset.top + viewportSize.height &&
                            elementOffset.left + elementSize.width > viewportOffset.left &&
                            elementOffset.left < viewportOffset.left + viewportSize.width) {
                            if (!inView) {
                                $element.data('inview', true).trigger('inview', [true]);
                            }
                        } else if (inView) {
                            $element.data('inview', false).trigger('inview', [false]);
                        }
                    }
                }

                $(w).bind("scroll resize scrollstop", function() {
                    viewportSize = viewportOffset = null;
                });

                // IE < 9 scrolls to focused elements without firing the "scroll" event
                if (!documentElement.addEventListener && documentElement.attachEvent) {
                    documentElement.attachEvent("onfocusin", function() {
                        viewportOffset = null;
                    });
                }
            }));


            /***/ }),

        /***/ "./node_modules/jquery-lazy/jquery.lazy.js":
        /*!*************************************************!*\
  !*** ./node_modules/jquery-lazy/jquery.lazy.js ***!
  \*************************************************/
        /*! no static exports found */
        /***/ (function(module, exports, __webpack_require__) {

            /* WEBPACK VAR INJECTION */(function(__webpack_provided_window_dot_jQuery) {/*!
 * jQuery & Zepto Lazy - v1.7.10
 * http://jquery.eisbehr.de/lazy/
 *
 * Copyright 2012 - 2018, Daniel 'Eisbehr' Kern
 *
 * Dual licensed under the MIT and GPL-2.0 licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl-2.0.html
 *
 * $("img.lazy").lazy();
 */

                ;(function(window, undefined) {
                    "use strict";

                    // noinspection JSUnresolvedVariable
                    /**
                     * library instance - here and not in construct to be shorter in minimization
                     * @return void
                     */
                    var $ = __webpack_provided_window_dot_jQuery || window.Zepto,

                        /**
                         * unique plugin instance id counter
                         * @type {number}
                         */
                        lazyInstanceId = 0,

                        /**
                         * helper to register window load for jQuery 3
                         * @type {boolean}
                         */
                        windowLoaded = false;

                    /**
                     * make lazy available to jquery - and make it a bit more case-insensitive :)
                     * @access public
                     * @type {function}
                     * @param {object} settings
                     * @return {LazyPlugin}
                     */
                    $.fn.Lazy = $.fn.lazy = function(settings) {
                        return new LazyPlugin(this, settings);
                    };

                    /**
                     * helper to add plugins to lazy prototype configuration
                     * @access public
                     * @type {function}
                     * @param {string|Array} names
                     * @param {string|Array|function} [elements]
                     * @param {function} loader
                     * @return void
                     */
                    $.Lazy = $.lazy = function(names, elements, loader) {
                        // make second parameter optional
                        if ($.isFunction(elements)) {
                            loader = elements;
                            elements = [];
                        }

                        // exit here if parameter is not a callable function
                        if (!$.isFunction(loader)) {
                            return;
                        }

                        // make parameters an array of names to be sure
                        names = $.isArray(names) ? names : [names];
                        elements = $.isArray(elements) ? elements : [elements];

                        var config = LazyPlugin.prototype.config,
                            forced = config._f || (config._f = {});

                        // add the loader plugin for every name
                        for (var i = 0, l = names.length; i < l; i++) {
                            if (config[names[i]] === undefined || $.isFunction(config[names[i]])) {
                                config[names[i]] = loader;
                            }
                        }

                        // add forced elements loader
                        for (var c = 0, a = elements.length; c < a; c++) {
                            forced[elements[c]] = names[0];
                        }
                    };

                    /**
                     * contains all logic and the whole element handling
                     * is packed in a private function outside class to reduce memory usage, because it will not be created on every plugin instance
                     * @access private
                     * @type {function}
                     * @param {LazyPlugin} instance
                     * @param {object} config
                     * @param {object|Array} items
                     * @param {object} events
                     * @param {string} namespace
                     * @return void
                     */
                    function _executeLazy(instance, config, items, events, namespace) {
                        /**
                         * a helper to trigger the 'onFinishedAll' callback after all other events
                         * @access private
                         * @type {number}
                         */
                        var _awaitingAfterLoad = 0,

                            /**
                             * visible content width
                             * @access private
                             * @type {number}
                             */
                            _actualWidth = -1,

                            /**
                             * visible content height
                             * @access private
                             * @type {number}
                             */
                            _actualHeight = -1,

                            /**
                             * determine possibly detected high pixel density
                             * @access private
                             * @type {boolean}
                             */
                            _isRetinaDisplay = false,

                            /**
                             * dictionary entry for better minimization
                             * @access private
                             * @type {string}
                             */
                            _afterLoad = 'afterLoad',

                            /**
                             * dictionary entry for better minimization
                             * @access private
                             * @type {string}
                             */
                            _load = 'load',

                            /**
                             * dictionary entry for better minimization
                             * @access private
                             * @type {string}
                             */
                            _error = 'error',

                            /**
                             * dictionary entry for better minimization
                             * @access private
                             * @type {string}
                             */
                            _img = 'img',

                            /**
                             * dictionary entry for better minimization
                             * @access private
                             * @type {string}
                             */
                            _src = 'src',

                            /**
                             * dictionary entry for better minimization
                             * @access private
                             * @type {string}
                             */
                            _srcset = 'srcset',

                            /**
                             * dictionary entry for better minimization
                             * @access private
                             * @type {string}
                             */
                            _sizes = 'sizes',

                            /**
                             * dictionary entry for better minimization
                             * @access private
                             * @type {string}
                             */
                            _backgroundImage = 'background-image';

                        /**
                         * initialize plugin
                         * bind loading to events or set delay time to load all items at once
                         * @access private
                         * @return void
                         */
                        function _initialize() {
                            // detect actual device pixel ratio
                            // noinspection JSUnresolvedVariable
                            _isRetinaDisplay = window.devicePixelRatio > 1;

                            // prepare all initial items
                            items = _prepareItems(items);

                            // if delay time is set load all items at once after delay time
                            if (config.delay >= 0) {
                                setTimeout(function() {
                                    _lazyLoadItems(true);
                                }, config.delay);
                            }

                            // if no delay is set or combine usage is active bind events
                            if (config.delay < 0 || config.combined) {
                                // create unique event function
                                events.e = _throttle(config.throttle, function(event) {
                                    // reset detected window size on resize event
                                    if (event.type === 'resize') {
                                        _actualWidth = _actualHeight = -1;
                                    }

                                    // execute 'lazy magic'
                                    _lazyLoadItems(event.all);
                                });

                                // create function to add new items to instance
                                events.a = function(additionalItems) {
                                    additionalItems = _prepareItems(additionalItems);
                                    items.push.apply(items, additionalItems);
                                };

                                // create function to get all instance items left
                                events.g = function() {
                                    // filter loaded items before return in case internal filter was not running until now
                                    return (items = $(items).filter(function() {
                                        return !$(this).data(config.loadedName);
                                    }));
                                };

                                // create function to force loading elements
                                events.f = function(forcedItems) {
                                    for (var i = 0; i < forcedItems.length; i++) {
                                        // only handle item if available in current instance
                                        // use a compare function, because Zepto can't handle object parameter for filter
                                        // var item = items.filter(forcedItems[i]);
                                        /* jshint loopfunc: true */
                                        var item = items.filter(function() {
                                            return this === forcedItems[i];
                                        });

                                        if (item.length) {
                                            _lazyLoadItems(false, item);
                                        }
                                    }
                                };

                                // load initial items
                                _lazyLoadItems();

                                // bind lazy load functions to scroll and resize event
                                // noinspection JSUnresolvedVariable
                                $(config.appendScroll).on('scroll.' + namespace + ' resize.' + namespace, events.e);
                            }
                        }

                        /**
                         * prepare items before handle them
                         * @access private
                         * @param {Array|object|jQuery} items
                         * @return {Array|object|jQuery}
                         */
                        function _prepareItems(items) {
                            // fetch used configurations before loops
                            var defaultImage = config.defaultImage,
                                placeholder = config.placeholder,
                                imageBase = config.imageBase,
                                srcsetAttribute = config.srcsetAttribute,
                                loaderAttribute = config.loaderAttribute,
                                forcedTags = config._f || {};

                            // filter items and only add those who not handled yet and got needed attributes available
                            items = $(items).filter(function() {
                                var element = $(this),
                                    tag = _getElementTagName(this);

                                return !element.data(config.handledName) &&
                                    (element.attr(config.attribute) || element.attr(srcsetAttribute) || element.attr(loaderAttribute) || forcedTags[tag] !== undefined);
                            })

                                // append plugin instance to all elements
                                .data('plugin_' + config.name, instance);

                            for (var i = 0, l = items.length; i < l; i++) {
                                var element = $(items[i]),
                                    tag = _getElementTagName(items[i]),
                                    elementImageBase = element.attr(config.imageBaseAttribute) || imageBase;

                                // generate and update source set if an image base is set
                                if (tag === _img && elementImageBase && element.attr(srcsetAttribute)) {
                                    element.attr(srcsetAttribute, _getCorrectedSrcSet(element.attr(srcsetAttribute), elementImageBase));
                                }

                                // add loader to forced element types
                                if (forcedTags[tag] !== undefined && !element.attr(loaderAttribute)) {
                                    element.attr(loaderAttribute, forcedTags[tag]);
                                }

                                // set default image on every element without source
                                if (tag === _img && defaultImage && !element.attr(_src)) {
                                    element.attr(_src, defaultImage);
                                }

                                // set placeholder on every element without background image
                                else if (tag !== _img && placeholder && (!element.css(_backgroundImage) || element.css(_backgroundImage) === 'none')) {
                                    element.css(_backgroundImage, "url('" + placeholder + "')");
                                }
                            }

                            return items;
                        }

                        /**
                         * the 'lazy magic' - check all items
                         * @access private
                         * @param {boolean} [allItems]
                         * @param {object} [forced]
                         * @return void
                         */
                        function _lazyLoadItems(allItems, forced) {
                            // skip if no items where left
                            if (!items.length) {
                                // destroy instance if option is enabled
                                if (config.autoDestroy) {
                                    // noinspection JSUnresolvedFunction
                                    instance.destroy();
                                }

                                return;
                            }

                            var elements = forced || items,
                                loadTriggered = false,
                                imageBase = config.imageBase || '',
                                srcsetAttribute = config.srcsetAttribute,
                                handledName = config.handledName;

                            // loop all available items
                            for (var i = 0; i < elements.length; i++) {
                                // item is at least in loadable area
                                if (allItems || forced || _isInLoadableArea(elements[i])) {
                                    var element = $(elements[i]),
                                        tag = _getElementTagName(elements[i]),
                                        attribute = element.attr(config.attribute),
                                        elementImageBase = element.attr(config.imageBaseAttribute) || imageBase,
                                        customLoader = element.attr(config.loaderAttribute);

                                    // is not already handled
                                    if (!element.data(handledName) &&
                                        // and is visible or visibility doesn't matter
                                        (!config.visibleOnly || element.is(':visible')) && (
                                            // and image source or source set attribute is available
                                            (attribute || element.attr(srcsetAttribute)) && (
                                                // and is image tag where attribute is not equal source or source set
                                                (tag === _img && (elementImageBase + attribute !== element.attr(_src) || element.attr(srcsetAttribute) !== element.attr(_srcset))) ||
                                                // or is non image tag where attribute is not equal background
                                                (tag !== _img && elementImageBase + attribute !== element.css(_backgroundImage))
                                            ) ||
                                            // or custom loader is available
                                            customLoader))
                                    {
                                        // mark element always as handled as this point to prevent double handling
                                        loadTriggered = true;
                                        element.data(handledName, true);

                                        // load item
                                        _handleItem(element, tag, elementImageBase, customLoader);
                                    }
                                }
                            }

                            // when something was loaded remove them from remaining items
                            if (loadTriggered) {
                                items = $(items).filter(function() {
                                    return !$(this).data(handledName);
                                });
                            }
                        }

                        /**
                         * load the given element the lazy way
                         * @access private
                         * @param {object} element
                         * @param {string} tag
                         * @param {string} imageBase
                         * @param {function} [customLoader]
                         * @return void
                         */
                        function _handleItem(element, tag, imageBase, customLoader) {
                            // increment count of items waiting for after load
                            ++_awaitingAfterLoad;

                            // extended error callback for correct 'onFinishedAll' handling
                            var errorCallback = function() {
                                _triggerCallback('onError', element);
                                _reduceAwaiting();

                                // prevent further callback calls
                                errorCallback = $.noop;
                            };

                            // trigger function before loading image
                            _triggerCallback('beforeLoad', element);

                            // fetch all double used data here for better code minimization
                            var srcAttribute = config.attribute,
                                srcsetAttribute = config.srcsetAttribute,
                                sizesAttribute = config.sizesAttribute,
                                retinaAttribute = config.retinaAttribute,
                                removeAttribute = config.removeAttribute,
                                loadedName = config.loadedName,
                                elementRetina = element.attr(retinaAttribute);

                            // handle custom loader
                            if (customLoader) {
                                // on load callback
                                var loadCallback = function() {
                                    // remove attribute from element
                                    if (removeAttribute) {
                                        element.removeAttr(config.loaderAttribute);
                                    }

                                    // mark element as loaded
                                    element.data(loadedName, true);

                                    // call after load event
                                    _triggerCallback(_afterLoad, element);

                                    // remove item from waiting queue and possibly trigger finished event
                                    // it's needed to be asynchronous to run after filter was in _lazyLoadItems
                                    setTimeout(_reduceAwaiting, 1);

                                    // prevent further callback calls
                                    loadCallback = $.noop;
                                };

                                // bind error event to trigger callback and reduce waiting amount
                                element.off(_error).one(_error, errorCallback)

                                    // bind after load callback to element
                                    .one(_load, loadCallback);

                                // trigger custom loader and handle response
                                if (!_triggerCallback(customLoader, element, function(response) {
                                    if(response) {
                                        element.off(_load);
                                        loadCallback();
                                    }
                                    else {
                                        element.off(_error);
                                        errorCallback();
                                    }
                                })) {
                                    element.trigger(_error);
                                }
                            }

                            // handle images
                            else {
                                // create image object
                                var imageObj = $(new Image());

                                // bind error event to trigger callback and reduce waiting amount
                                imageObj.one(_error, errorCallback)

                                    // bind after load callback to image
                                    .one(_load, function() {
                                        // remove element from view
                                        element.hide();

                                        // set image back to element
                                        // do it as single 'attr' calls, to be sure 'src' is set after 'srcset'
                                        if (tag === _img) {
                                            element.attr(_sizes, imageObj.attr(_sizes))
                                                .attr(_srcset, imageObj.attr(_srcset))
                                                .attr(_src, imageObj.attr(_src));
                                        }
                                        else {
                                            element.css(_backgroundImage, "url('" + imageObj.attr(_src) + "')");
                                        }

                                        // bring it back with some effect!
                                        element[config.effect](config.effectTime);

                                        // remove attribute from element
                                        if (removeAttribute) {
                                            element.removeAttr(srcAttribute + ' ' + srcsetAttribute + ' ' + retinaAttribute + ' ' + config.imageBaseAttribute);

                                            // only remove 'sizes' attribute, if it was a custom one
                                            if (sizesAttribute !== _sizes) {
                                                element.removeAttr(sizesAttribute);
                                            }
                                        }

                                        // mark element as loaded
                                        element.data(loadedName, true);

                                        // call after load event
                                        _triggerCallback(_afterLoad, element);

                                        // cleanup image object
                                        imageObj.remove();

                                        // remove item from waiting queue and possibly trigger finished event
                                        _reduceAwaiting();
                                    });

                                // set sources
                                // do it as single 'attr' calls, to be sure 'src' is set after 'srcset'
                                var imageSrc = (_isRetinaDisplay && elementRetina ? elementRetina : element.attr(srcAttribute)) || '';
                                imageObj.attr(_sizes, element.attr(sizesAttribute))
                                    .attr(_srcset, element.attr(srcsetAttribute))
                                    .attr(_src, imageSrc ? imageBase + imageSrc : null);

                                // call after load even on cached image
                                imageObj.complete && imageObj.trigger(_load); // jshint ignore : line
                            }
                        }

                        /**
                         * check if the given element is inside the current viewport or threshold
                         * @access private
                         * @param {object} element
                         * @return {boolean}
                         */
                        function _isInLoadableArea(element) {
                            var elementBound = element.getBoundingClientRect(),
                                direction    = config.scrollDirection,
                                threshold    = config.threshold,
                                vertical     = // check if element is in loadable area from top
                                    ((_getActualHeight() + threshold) > elementBound.top) &&
                                    // check if element is even in loadable are from bottom
                                    (-threshold < elementBound.bottom),
                                horizontal   = // check if element is in loadable area from left
                                    ((_getActualWidth() + threshold) > elementBound.left) &&
                                    // check if element is even in loadable area from right
                                    (-threshold < elementBound.right);

                            if (direction === 'vertical') {
                                return vertical;
                            }
                            else if (direction === 'horizontal') {
                                return horizontal;
                            }

                            return vertical && horizontal;
                        }

                        /**
                         * receive the current viewed width of the browser
                         * @access private
                         * @return {number}
                         */
                        function _getActualWidth() {
                            return _actualWidth >= 0 ? _actualWidth : (_actualWidth = $(window).width());
                        }

                        /**
                         * receive the current viewed height of the browser
                         * @access private
                         * @return {number}
                         */
                        function _getActualHeight() {
                            return _actualHeight >= 0 ? _actualHeight : (_actualHeight = $(window).height());
                        }

                        /**
                         * get lowercase tag name of an element
                         * @access private
                         * @param {object} element
                         * @returns {string}
                         */
                        function _getElementTagName(element) {
                            return element.tagName.toLowerCase();
                        }

                        /**
                         * prepend image base to all srcset entries
                         * @access private
                         * @param {string} srcset
                         * @param {string} imageBase
                         * @returns {string}
                         */
                        function _getCorrectedSrcSet(srcset, imageBase) {
                            if (imageBase) {
                                // trim, remove unnecessary spaces and split entries
                                var entries = srcset.split(',');
                                srcset = '';

                                for (var i = 0, l = entries.length; i < l; i++) {
                                    srcset += imageBase + entries[i].trim() + (i !== l - 1 ? ',' : '');
                                }
                            }

                            return srcset;
                        }

                        /**
                         * helper function to throttle down event triggering
                         * @access private
                         * @param {number} delay
                         * @param {function} callback
                         * @return {function}
                         */
                        function _throttle(delay, callback) {
                            var timeout,
                                lastExecute = 0;

                            return function(event, ignoreThrottle) {
                                var elapsed = +new Date() - lastExecute;

                                function run() {
                                    lastExecute = +new Date();
                                    // noinspection JSUnresolvedFunction
                                    callback.call(instance, event);
                                }

                                timeout && clearTimeout(timeout); // jshint ignore : line

                                if (elapsed > delay || !config.enableThrottle || ignoreThrottle) {
                                    run();
                                }
                                else {
                                    timeout = setTimeout(run, delay - elapsed);
                                }
                            };
                        }

                        /**
                         * reduce count of awaiting elements to 'afterLoad' event and fire 'onFinishedAll' if reached zero
                         * @access private
                         * @return void
                         */
                        function _reduceAwaiting() {
                            --_awaitingAfterLoad;

                            // if no items were left trigger finished event
                            if (!items.length && !_awaitingAfterLoad) {
                                _triggerCallback('onFinishedAll');
                            }
                        }

                        /**
                         * single implementation to handle callbacks, pass element and set 'this' to current instance
                         * @access private
                         * @param {string|function} callback
                         * @param {object} [element]
                         * @param {*} [args]
                         * @return {boolean}
                         */
                        function _triggerCallback(callback, element, args) {
                            if ((callback = config[callback])) {
                                // jQuery's internal '$(arguments).slice(1)' are causing problems at least on old iPads
                                // below is shorthand of 'Array.prototype.slice.call(arguments, 1)'
                                callback.apply(instance, [].slice.call(arguments, 1));
                                return true;
                            }

                            return false;
                        }

                        // if event driven or window is already loaded don't wait for page loading
                        if (config.bind === 'event' || windowLoaded) {
                            _initialize();
                        }

                        // otherwise load initial items and start lazy after page load
                        else {
                            // noinspection JSUnresolvedVariable
                            $(window).on(_load + '.' + namespace, _initialize);
                        }
                    }

                    /**
                     * lazy plugin class constructor
                     * @constructor
                     * @access private
                     * @param {object} elements
                     * @param {object} settings
                     * @return {object|LazyPlugin}
                     */
                    function LazyPlugin(elements, settings) {
                        /**
                         * this lazy plugin instance
                         * @access private
                         * @type {object|LazyPlugin|LazyPlugin.prototype}
                         */
                        var _instance = this,

                            /**
                             * this lazy plugin instance configuration
                             * @access private
                             * @type {object}
                             */
                            _config = $.extend({}, _instance.config, settings),

                            /**
                             * instance generated event executed on container scroll or resize
                             * packed in an object to be referenceable and short named because properties will not be minified
                             * @access private
                             * @type {object}
                             */
                            _events = {},

                            /**
                             * unique namespace for instance related events
                             * @access private
                             * @type {string}
                             */
                            _namespace = _config.name + '-' + (++lazyInstanceId);

                        // noinspection JSUndefinedPropertyAssignment
                        /**
                         * wrapper to get or set an entry from plugin instance configuration
                         * much smaller on minify as direct access
                         * @access public
                         * @type {function}
                         * @param {string} entryName
                         * @param {*} [value]
                         * @return {LazyPlugin|*}
                         */
                        _instance.config = function(entryName, value) {
                            if (value === undefined) {
                                return _config[entryName];
                            }

                            _config[entryName] = value;
                            return _instance;
                        };

                        // noinspection JSUndefinedPropertyAssignment
                        /**
                         * add additional items to current instance
                         * @access public
                         * @param {Array|object|string} items
                         * @return {LazyPlugin}
                         */
                        _instance.addItems = function(items) {
                            _events.a && _events.a($.type(items) === 'string' ? $(items) : items); // jshint ignore : line
                            return _instance;
                        };

                        // noinspection JSUndefinedPropertyAssignment
                        /**
                         * get all left items of this instance
                         * @access public
                         * @returns {object}
                         */
                        _instance.getItems = function() {
                            return _events.g ? _events.g() : {};
                        };

                        // noinspection JSUndefinedPropertyAssignment
                        /**
                         * force lazy to load all items in loadable area right now
                         * by default without throttle
                         * @access public
                         * @type {function}
                         * @param {boolean} [useThrottle]
                         * @return {LazyPlugin}
                         */
                        _instance.update = function(useThrottle) {
                            _events.e && _events.e({}, !useThrottle); // jshint ignore : line
                            return _instance;
                        };

                        // noinspection JSUndefinedPropertyAssignment
                        /**
                         * force element(s) to load directly, ignoring the viewport
                         * @access public
                         * @param {Array|object|string} items
                         * @return {LazyPlugin}
                         */
                        _instance.force = function(items) {
                            _events.f && _events.f($.type(items) === 'string' ? $(items) : items); // jshint ignore : line
                            return _instance;
                        };

                        // noinspection JSUndefinedPropertyAssignment
                        /**
                         * force lazy to load all available items right now
                         * this call ignores throttling
                         * @access public
                         * @type {function}
                         * @return {LazyPlugin}
                         */
                        _instance.loadAll = function() {
                            _events.e && _events.e({all: true}, true); // jshint ignore : line
                            return _instance;
                        };

                        // noinspection JSUndefinedPropertyAssignment
                        /**
                         * destroy this plugin instance
                         * @access public
                         * @type {function}
                         * @return undefined
                         */
                        _instance.destroy = function() {
                            // unbind instance generated events
                            // noinspection JSUnresolvedFunction, JSUnresolvedVariable
                            $(_config.appendScroll).off('.' + _namespace, _events.e);
                            // noinspection JSUnresolvedVariable
                            $(window).off('.' + _namespace);

                            // clear events
                            _events = {};

                            return undefined;
                        };

                        // start using lazy and return all elements to be chainable or instance for further use
                        // noinspection JSUnresolvedVariable
                        _executeLazy(_instance, _config, elements, _events, _namespace);
                        return _config.chainable ? elements : _instance;
                    }

                    /**
                     * settings and configuration data
                     * @access public
                     * @type {object|*}
                     */
                    LazyPlugin.prototype.config = {
                        // general
                        name               : 'lazy',
                        chainable          : true,
                        autoDestroy        : true,
                        bind               : 'load',
                        threshold          : 500,
                        visibleOnly        : false,
                        appendScroll       : window,
                        scrollDirection    : 'both',
                        imageBase          : null,
                        defaultImage       : 'data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==',
                        placeholder        : null,
                        delay              : -1,
                        combined           : false,

                        // attributes
                        attribute          : 'data-src',
                        srcsetAttribute    : 'data-srcset',
                        sizesAttribute     : 'data-sizes',
                        retinaAttribute    : 'data-retina',
                        loaderAttribute    : 'data-loader',
                        imageBaseAttribute : 'data-imagebase',
                        removeAttribute    : true,
                        handledName        : 'handled',
                        loadedName         : 'loaded',

                        // effect
                        effect             : 'show',
                        effectTime         : 0,

                        // throttle
                        enableThrottle     : true,
                        throttle           : 250,

                        // callbacks
                        beforeLoad         : undefined,
                        afterLoad          : undefined,
                        onError            : undefined,
                        onFinishedAll      : undefined
                    };

                    // register window load event globally to prevent not loading elements
                    // since jQuery 3.X ready state is fully async and may be executed after 'load'
                    $(window).on('load', function() {
                        windowLoaded = true;
                    });
                })(window);
                /* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

            /***/ }),

        /***/ "./node_modules/jquery/dist/jquery.js":
        /*!********************************************!*\
  !*** ./node_modules/jquery/dist/jquery.js ***!
  \********************************************/
        /*! no static exports found */
        /***/ (function(module, exports, __webpack_require__) {

            var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery JavaScript Library v3.5.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2020-05-04T22:49Z
 */
            ( function( global, factory ) {

                "use strict";

                if (  true && typeof module.exports === "object" ) {

                    // For CommonJS and CommonJS-like environments where a proper `window`
                    // is present, execute the factory and get jQuery.
                    // For environments that do not have a `window` with a `document`
                    // (such as Node.js), expose a factory as module.exports.
                    // This accentuates the need for the creation of a real `window`.
                    // e.g. var jQuery = require("jquery")(window);
                    // See ticket #14549 for more info.
                    module.exports = global.document ?
                        factory( global, true ) :
                        function( w ) {
                            if ( !w.document ) {
                                throw new Error( "jQuery requires a window with a document" );
                            }
                            return factory( w );
                        };
                } else {
                    factory( global );
                }

// Pass this if window is not defined yet
            } )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
                "use strict";

                var arr = [];

                var getProto = Object.getPrototypeOf;

                var slice = arr.slice;

                var flat = arr.flat ? function( array ) {
                    return arr.flat.call( array );
                } : function( array ) {
                    return arr.concat.apply( [], array );
                };


                var push = arr.push;

                var indexOf = arr.indexOf;

                var class2type = {};

                var toString = class2type.toString;

                var hasOwn = class2type.hasOwnProperty;

                var fnToString = hasOwn.toString;

                var ObjectFunctionString = fnToString.call( Object );

                var support = {};

                var isFunction = function isFunction( obj ) {

                    // Support: Chrome <=57, Firefox <=52
                    // In some browsers, typeof returns "function" for HTML <object> elements
                    // (i.e., `typeof document.createElement( "object" ) === "function"`).
                    // We don't want to classify *any* DOM node as a function.
                    return typeof obj === "function" && typeof obj.nodeType !== "number";
                };


                var isWindow = function isWindow( obj ) {
                    return obj != null && obj === obj.window;
                };


                var document = window.document;



                var preservedScriptAttributes = {
                    type: true,
                    src: true,
                    nonce: true,
                    noModule: true
                };

                function DOMEval( code, node, doc ) {
                    doc = doc || document;

                    var i, val,
                        script = doc.createElement( "script" );

                    script.text = code;
                    if ( node ) {
                        for ( i in preservedScriptAttributes ) {

                            // Support: Firefox 64+, Edge 18+
                            // Some browsers don't support the "nonce" property on scripts.
                            // On the other hand, just using `getAttribute` is not enough as
                            // the `nonce` attribute is reset to an empty string whenever it
                            // becomes browsing-context connected.
                            // See https://github.com/whatwg/html/issues/2369
                            // See https://html.spec.whatwg.org/#nonce-attributes
                            // The `node.getAttribute` check was added for the sake of
                            // `jQuery.globalEval` so that it can fake a nonce-containing node
                            // via an object.
                            val = node[ i ] || node.getAttribute && node.getAttribute( i );
                            if ( val ) {
                                script.setAttribute( i, val );
                            }
                        }
                    }
                    doc.head.appendChild( script ).parentNode.removeChild( script );
                }


                function toType( obj ) {
                    if ( obj == null ) {
                        return obj + "";
                    }

                    // Support: Android <=2.3 only (functionish RegExp)
                    return typeof obj === "object" || typeof obj === "function" ?
                        class2type[ toString.call( obj ) ] || "object" :
                        typeof obj;
                }
                /* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



                var
                    version = "3.5.1",

                    // Define a local copy of jQuery
                    jQuery = function( selector, context ) {

                        // The jQuery object is actually just the init constructor 'enhanced'
                        // Need init if jQuery is called (just allow error to be thrown if not included)
                        return new jQuery.fn.init( selector, context );
                    };

                jQuery.fn = jQuery.prototype = {

                    // The current version of jQuery being used
                    jquery: version,

                    constructor: jQuery,

                    // The default length of a jQuery object is 0
                    length: 0,

                    toArray: function() {
                        return slice.call( this );
                    },

                    // Get the Nth element in the matched element set OR
                    // Get the whole matched element set as a clean array
                    get: function( num ) {

                        // Return all the elements in a clean array
                        if ( num == null ) {
                            return slice.call( this );
                        }

                        // Return just the one element from the set
                        return num < 0 ? this[ num + this.length ] : this[ num ];
                    },

                    // Take an array of elements and push it onto the stack
                    // (returning the new matched element set)
                    pushStack: function( elems ) {

                        // Build a new jQuery matched element set
                        var ret = jQuery.merge( this.constructor(), elems );

                        // Add the old object onto the stack (as a reference)
                        ret.prevObject = this;

                        // Return the newly-formed element set
                        return ret;
                    },

                    // Execute a callback for every element in the matched set.
                    each: function( callback ) {
                        return jQuery.each( this, callback );
                    },

                    map: function( callback ) {
                        return this.pushStack( jQuery.map( this, function( elem, i ) {
                            return callback.call( elem, i, elem );
                        } ) );
                    },

                    slice: function() {
                        return this.pushStack( slice.apply( this, arguments ) );
                    },

                    first: function() {
                        return this.eq( 0 );
                    },

                    last: function() {
                        return this.eq( -1 );
                    },

                    even: function() {
                        return this.pushStack( jQuery.grep( this, function( _elem, i ) {
                            return ( i + 1 ) % 2;
                        } ) );
                    },

                    odd: function() {
                        return this.pushStack( jQuery.grep( this, function( _elem, i ) {
                            return i % 2;
                        } ) );
                    },

                    eq: function( i ) {
                        var len = this.length,
                            j = +i + ( i < 0 ? len : 0 );
                        return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
                    },

                    end: function() {
                        return this.prevObject || this.constructor();
                    },

                    // For internal use only.
                    // Behaves like an Array's method, not like a jQuery method.
                    push: push,
                    sort: arr.sort,
                    splice: arr.splice
                };

                jQuery.extend = jQuery.fn.extend = function() {
                    var options, name, src, copy, copyIsArray, clone,
                        target = arguments[ 0 ] || {},
                        i = 1,
                        length = arguments.length,
                        deep = false;

                    // Handle a deep copy situation
                    if ( typeof target === "boolean" ) {
                        deep = target;

                        // Skip the boolean and the target
                        target = arguments[ i ] || {};
                        i++;
                    }

                    // Handle case when target is a string or something (possible in deep copy)
                    if ( typeof target !== "object" && !isFunction( target ) ) {
                        target = {};
                    }

                    // Extend jQuery itself if only one argument is passed
                    if ( i === length ) {
                        target = this;
                        i--;
                    }

                    for ( ; i < length; i++ ) {

                        // Only deal with non-null/undefined values
                        if ( ( options = arguments[ i ] ) != null ) {

                            // Extend the base object
                            for ( name in options ) {
                                copy = options[ name ];

                                // Prevent Object.prototype pollution
                                // Prevent never-ending loop
                                if ( name === "__proto__" || target === copy ) {
                                    continue;
                                }

                                // Recurse if we're merging plain objects or arrays
                                if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
                                    ( copyIsArray = Array.isArray( copy ) ) ) ) {
                                    src = target[ name ];

                                    // Ensure proper type for the source value
                                    if ( copyIsArray && !Array.isArray( src ) ) {
                                        clone = [];
                                    } else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
                                        clone = {};
                                    } else {
                                        clone = src;
                                    }
                                    copyIsArray = false;

                                    // Never move original objects, clone them
                                    target[ name ] = jQuery.extend( deep, clone, copy );

                                    // Don't bring in undefined values
                                } else if ( copy !== undefined ) {
                                    target[ name ] = copy;
                                }
                            }
                        }
                    }

                    // Return the modified object
                    return target;
                };

                jQuery.extend( {

                    // Unique for each copy of jQuery on the page
                    expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

                    // Assume jQuery is ready without the ready module
                    isReady: true,

                    error: function( msg ) {
                        throw new Error( msg );
                    },

                    noop: function() {},

                    isPlainObject: function( obj ) {
                        var proto, Ctor;

                        // Detect obvious negatives
                        // Use toString instead of jQuery.type to catch host objects
                        if ( !obj || toString.call( obj ) !== "[object Object]" ) {
                            return false;
                        }

                        proto = getProto( obj );

                        // Objects with no prototype (e.g., `Object.create( null )`) are plain
                        if ( !proto ) {
                            return true;
                        }

                        // Objects with prototype are plain iff they were constructed by a global Object function
                        Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
                        return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
                    },

                    isEmptyObject: function( obj ) {
                        var name;

                        for ( name in obj ) {
                            return false;
                        }
                        return true;
                    },

                    // Evaluates a script in a provided context; falls back to the global one
                    // if not specified.
                    globalEval: function( code, options, doc ) {
                        DOMEval( code, { nonce: options && options.nonce }, doc );
                    },

                    each: function( obj, callback ) {
                        var length, i = 0;

                        if ( isArrayLike( obj ) ) {
                            length = obj.length;
                            for ( ; i < length; i++ ) {
                                if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
                                    break;
                                }
                            }
                        } else {
                            for ( i in obj ) {
                                if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
                                    break;
                                }
                            }
                        }

                        return obj;
                    },

                    // results is for internal usage only
                    makeArray: function( arr, results ) {
                        var ret = results || [];

                        if ( arr != null ) {
                            if ( isArrayLike( Object( arr ) ) ) {
                                jQuery.merge( ret,
                                    typeof arr === "string" ?
                                        [ arr ] : arr
                                );
                            } else {
                                push.call( ret, arr );
                            }
                        }

                        return ret;
                    },

                    inArray: function( elem, arr, i ) {
                        return arr == null ? -1 : indexOf.call( arr, elem, i );
                    },

                    // Support: Android <=4.0 only, PhantomJS 1 only
                    // push.apply(_, arraylike) throws on ancient WebKit
                    merge: function( first, second ) {
                        var len = +second.length,
                            j = 0,
                            i = first.length;

                        for ( ; j < len; j++ ) {
                            first[ i++ ] = second[ j ];
                        }

                        first.length = i;

                        return first;
                    },

                    grep: function( elems, callback, invert ) {
                        var callbackInverse,
                            matches = [],
                            i = 0,
                            length = elems.length,
                            callbackExpect = !invert;

                        // Go through the array, only saving the items
                        // that pass the validator function
                        for ( ; i < length; i++ ) {
                            callbackInverse = !callback( elems[ i ], i );
                            if ( callbackInverse !== callbackExpect ) {
                                matches.push( elems[ i ] );
                            }
                        }

                        return matches;
                    },

                    // arg is for internal usage only
                    map: function( elems, callback, arg ) {
                        var length, value,
                            i = 0,
                            ret = [];

                        // Go through the array, translating each of the items to their new values
                        if ( isArrayLike( elems ) ) {
                            length = elems.length;
                            for ( ; i < length; i++ ) {
                                value = callback( elems[ i ], i, arg );

                                if ( value != null ) {
                                    ret.push( value );
                                }
                            }

                            // Go through every key on the object,
                        } else {
                            for ( i in elems ) {
                                value = callback( elems[ i ], i, arg );

                                if ( value != null ) {
                                    ret.push( value );
                                }
                            }
                        }

                        // Flatten any nested arrays
                        return flat( ret );
                    },

                    // A global GUID counter for objects
                    guid: 1,

                    // jQuery.support is not used in Core but other projects attach their
                    // properties to it so it needs to exist.
                    support: support
                } );

                if ( typeof Symbol === "function" ) {
                    jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
                }

// Populate the class2type map
                jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
                    function( _i, name ) {
                        class2type[ "[object " + name + "]" ] = name.toLowerCase();
                    } );

                function isArrayLike( obj ) {

                    // Support: real iOS 8.2 only (not reproducible in simulator)
                    // `in` check used to prevent JIT error (gh-2145)
                    // hasOwn isn't used here due to false negatives
                    // regarding Nodelist length in IE
                    var length = !!obj && "length" in obj && obj.length,
                        type = toType( obj );

                    if ( isFunction( obj ) || isWindow( obj ) ) {
                        return false;
                    }

                    return type === "array" || length === 0 ||
                        typeof length === "number" && length > 0 && ( length - 1 ) in obj;
                }
                var Sizzle =
                    /*!
 * Sizzle CSS Selector Engine v2.3.5
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://js.foundation/
 *
 * Date: 2020-03-14
 */
                    ( function( window ) {
                        var i,
                            support,
                            Expr,
                            getText,
                            isXML,
                            tokenize,
                            compile,
                            select,
                            outermostContext,
                            sortInput,
                            hasDuplicate,

                            // Local document vars
                            setDocument,
                            document,
                            docElem,
                            documentIsHTML,
                            rbuggyQSA,
                            rbuggyMatches,
                            matches,
                            contains,

                            // Instance-specific data
                            expando = "sizzle" + 1 * new Date(),
                            preferredDoc = window.document,
                            dirruns = 0,
                            done = 0,
                            classCache = createCache(),
                            tokenCache = createCache(),
                            compilerCache = createCache(),
                            nonnativeSelectorCache = createCache(),
                            sortOrder = function( a, b ) {
                                if ( a === b ) {
                                    hasDuplicate = true;
                                }
                                return 0;
                            },

                            // Instance methods
                            hasOwn = ( {} ).hasOwnProperty,
                            arr = [],
                            pop = arr.pop,
                            pushNative = arr.push,
                            push = arr.push,
                            slice = arr.slice,

                            // Use a stripped-down indexOf as it's faster than native
                            // https://jsperf.com/thor-indexof-vs-for/5
                            indexOf = function( list, elem ) {
                                var i = 0,
                                    len = list.length;
                                for ( ; i < len; i++ ) {
                                    if ( list[ i ] === elem ) {
                                        return i;
                                    }
                                }
                                return -1;
                            },

                            booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|" +
                                "ismap|loop|multiple|open|readonly|required|scoped",

                            // Regular expressions

                            // http://www.w3.org/TR/css3-selectors/#whitespace
                            whitespace = "[\\x20\\t\\r\\n\\f]",

                            // https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
                            identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace +
                                "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",

                            // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
                            attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +

                                // Operator (capture 2)
                                "*([*^$|!~]?=)" + whitespace +

                                // "Attribute values must be CSS identifiers [capture 5]
                                // or strings [capture 3 or capture 4]"
                                "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" +
                                whitespace + "*\\]",

                            pseudos = ":(" + identifier + ")(?:\\((" +

                                // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
                                // 1. quoted (capture 3; capture 4 or capture 5)
                                "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +

                                // 2. simple (capture 6)
                                "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +

                                // 3. anything else (capture 2)
                                ".*" +
                                ")\\)|)",

                            // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
                            rwhitespace = new RegExp( whitespace + "+", "g" ),
                            rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" +
                                whitespace + "+$", "g" ),

                            rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
                            rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace +
                                "*" ),
                            rdescend = new RegExp( whitespace + "|>" ),

                            rpseudo = new RegExp( pseudos ),
                            ridentifier = new RegExp( "^" + identifier + "$" ),

                            matchExpr = {
                                "ID": new RegExp( "^#(" + identifier + ")" ),
                                "CLASS": new RegExp( "^\\.(" + identifier + ")" ),
                                "TAG": new RegExp( "^(" + identifier + "|[*])" ),
                                "ATTR": new RegExp( "^" + attributes ),
                                "PSEUDO": new RegExp( "^" + pseudos ),
                                "CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" +
                                    whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" +
                                    whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
                                "bool": new RegExp( "^(?:" + booleans + ")$", "i" ),

                                // For use in libraries implementing .is()
                                // We use this for POS matching in `select`
                                "needsContext": new RegExp( "^" + whitespace +
                                    "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace +
                                    "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
                            },

                            rhtml = /HTML$/i,
                            rinputs = /^(?:input|select|textarea|button)$/i,
                            rheader = /^h\d$/i,

                            rnative = /^[^{]+\{\s*\[native \w/,

                            // Easily-parseable/retrievable ID or TAG or CLASS selectors
                            rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

                            rsibling = /[+~]/,

                            // CSS escapes
                            // http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
                            runescape = new RegExp( "\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])", "g" ),
                            funescape = function( escape, nonHex ) {
                                var high = "0x" + escape.slice( 1 ) - 0x10000;

                                return nonHex ?

                                    // Strip the backslash prefix from a non-hex escape sequence
                                    nonHex :

                                    // Replace a hexadecimal escape sequence with the encoded Unicode code point
                                    // Support: IE <=11+
                                    // For values outside the Basic Multilingual Plane (BMP), manually construct a
                                    // surrogate pair
                                    high < 0 ?
                                        String.fromCharCode( high + 0x10000 ) :
                                        String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
                            },

                            // CSS string/identifier serialization
                            // https://drafts.csswg.org/cssom/#common-serializing-idioms
                            rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
                            fcssescape = function( ch, asCodePoint ) {
                                if ( asCodePoint ) {

                                    // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
                                    if ( ch === "\0" ) {
                                        return "\uFFFD";
                                    }

                                    // Control characters and (dependent upon position) numbers get escaped as code points
                                    return ch.slice( 0, -1 ) + "\\" +
                                        ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
                                }

                                // Other potentially-special ASCII characters get backslash-escaped
                                return "\\" + ch;
                            },

                            // Used for iframes
                            // See setDocument()
                            // Removing the function wrapper causes a "Permission Denied"
                            // error in IE
                            unloadHandler = function() {
                                setDocument();
                            },

                            inDisabledFieldset = addCombinator(
                                function( elem ) {
                                    return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
                                },
                                { dir: "parentNode", next: "legend" }
                            );

// Optimize for push.apply( _, NodeList )
                        try {
                            push.apply(
                                ( arr = slice.call( preferredDoc.childNodes ) ),
                                preferredDoc.childNodes
                            );

                            // Support: Android<4.0
                            // Detect silently failing push.apply
                            // eslint-disable-next-line no-unused-expressions
                            arr[ preferredDoc.childNodes.length ].nodeType;
                        } catch ( e ) {
                            push = { apply: arr.length ?

                                    // Leverage slice if possible
                                    function( target, els ) {
                                        pushNative.apply( target, slice.call( els ) );
                                    } :

                                    // Support: IE<9
                                    // Otherwise append directly
                                    function( target, els ) {
                                        var j = target.length,
                                            i = 0;

                                        // Can't trust NodeList.length
                                        while ( ( target[ j++ ] = els[ i++ ] ) ) {}
                                        target.length = j - 1;
                                    }
                            };
                        }

                        function Sizzle( selector, context, results, seed ) {
                            var m, i, elem, nid, match, groups, newSelector,
                                newContext = context && context.ownerDocument,

                                // nodeType defaults to 9, since context defaults to document
                                nodeType = context ? context.nodeType : 9;

                            results = results || [];

                            // Return early from calls with invalid selector or context
                            if ( typeof selector !== "string" || !selector ||
                                nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

                                return results;
                            }

                            // Try to shortcut find operations (as opposed to filters) in HTML documents
                            if ( !seed ) {
                                setDocument( context );
                                context = context || document;

                                if ( documentIsHTML ) {

                                    // If the selector is sufficiently simple, try using a "get*By*" DOM method
                                    // (excepting DocumentFragment context, where the methods don't exist)
                                    if ( nodeType !== 11 && ( match = rquickExpr.exec( selector ) ) ) {

                                        // ID selector
                                        if ( ( m = match[ 1 ] ) ) {

                                            // Document context
                                            if ( nodeType === 9 ) {
                                                if ( ( elem = context.getElementById( m ) ) ) {

                                                    // Support: IE, Opera, Webkit
                                                    // TODO: identify versions
                                                    // getElementById can match elements by name instead of ID
                                                    if ( elem.id === m ) {
                                                        results.push( elem );
                                                        return results;
                                                    }
                                                } else {
                                                    return results;
                                                }

                                                // Element context
                                            } else {

                                                // Support: IE, Opera, Webkit
                                                // TODO: identify versions
                                                // getElementById can match elements by name instead of ID
                                                if ( newContext && ( elem = newContext.getElementById( m ) ) &&
                                                    contains( context, elem ) &&
                                                    elem.id === m ) {

                                                    results.push( elem );
                                                    return results;
                                                }
                                            }

                                            // Type selector
                                        } else if ( match[ 2 ] ) {
                                            push.apply( results, context.getElementsByTagName( selector ) );
                                            return results;

                                            // Class selector
                                        } else if ( ( m = match[ 3 ] ) && support.getElementsByClassName &&
                                            context.getElementsByClassName ) {

                                            push.apply( results, context.getElementsByClassName( m ) );
                                            return results;
                                        }
                                    }

                                    // Take advantage of querySelectorAll
                                    if ( support.qsa &&
                                        !nonnativeSelectorCache[ selector + " " ] &&
                                        ( !rbuggyQSA || !rbuggyQSA.test( selector ) ) &&

                                        // Support: IE 8 only
                                        // Exclude object elements
                                        ( nodeType !== 1 || context.nodeName.toLowerCase() !== "object" ) ) {

                                        newSelector = selector;
                                        newContext = context;

                                        // qSA considers elements outside a scoping root when evaluating child or
                                        // descendant combinators, which is not what we want.
                                        // In such cases, we work around the behavior by prefixing every selector in the
                                        // list with an ID selector referencing the scope context.
                                        // The technique has to be used as well when a leading combinator is used
                                        // as such selectors are not recognized by querySelectorAll.
                                        // Thanks to Andrew Dupont for this technique.
                                        if ( nodeType === 1 &&
                                            ( rdescend.test( selector ) || rcombinators.test( selector ) ) ) {

                                            // Expand context for sibling selectors
                                            newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
                                                context;

                                            // We can use :scope instead of the ID hack if the browser
                                            // supports it & if we're not changing the context.
                                            if ( newContext !== context || !support.scope ) {

                                                // Capture the context ID, setting it first if necessary
                                                if ( ( nid = context.getAttribute( "id" ) ) ) {
                                                    nid = nid.replace( rcssescape, fcssescape );
                                                } else {
                                                    context.setAttribute( "id", ( nid = expando ) );
                                                }
                                            }

                                            // Prefix every selector in the list
                                            groups = tokenize( selector );
                                            i = groups.length;
                                            while ( i-- ) {
                                                groups[ i ] = ( nid ? "#" + nid : ":scope" ) + " " +
                                                    toSelector( groups[ i ] );
                                            }
                                            newSelector = groups.join( "," );
                                        }

                                        try {
                                            push.apply( results,
                                                newContext.querySelectorAll( newSelector )
                                            );
                                            return results;
                                        } catch ( qsaError ) {
                                            nonnativeSelectorCache( selector, true );
                                        } finally {
                                            if ( nid === expando ) {
                                                context.removeAttribute( "id" );
                                            }
                                        }
                                    }
                                }
                            }

                            // All others
                            return select( selector.replace( rtrim, "$1" ), context, results, seed );
                        }

                        /**
                         * Create key-value caches of limited size
                         * @returns {function(string, object)} Returns the Object data after storing it on itself with
                         *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
                         *	deleting the oldest entry
                         */
                        function createCache() {
                            var keys = [];

                            function cache( key, value ) {

                                // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
                                if ( keys.push( key + " " ) > Expr.cacheLength ) {

                                    // Only keep the most recent entries
                                    delete cache[ keys.shift() ];
                                }
                                return ( cache[ key + " " ] = value );
                            }
                            return cache;
                        }

                        /**
                         * Mark a function for special use by Sizzle
                         * @param {Function} fn The function to mark
                         */
                        function markFunction( fn ) {
                            fn[ expando ] = true;
                            return fn;
                        }

                        /**
                         * Support testing using an element
                         * @param {Function} fn Passed the created element and returns a boolean result
                         */
                        function assert( fn ) {
                            var el = document.createElement( "fieldset" );

                            try {
                                return !!fn( el );
                            } catch ( e ) {
                                return false;
                            } finally {

                                // Remove from its parent by default
                                if ( el.parentNode ) {
                                    el.parentNode.removeChild( el );
                                }

                                // release memory in IE
                                el = null;
                            }
                        }

                        /**
                         * Adds the same handler for all of the specified attrs
                         * @param {String} attrs Pipe-separated list of attributes
                         * @param {Function} handler The method that will be applied
                         */
                        function addHandle( attrs, handler ) {
                            var arr = attrs.split( "|" ),
                                i = arr.length;

                            while ( i-- ) {
                                Expr.attrHandle[ arr[ i ] ] = handler;
                            }
                        }

                        /**
                         * Checks document order of two siblings
                         * @param {Element} a
                         * @param {Element} b
                         * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
                         */
                        function siblingCheck( a, b ) {
                            var cur = b && a,
                                diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
                                    a.sourceIndex - b.sourceIndex;

                            // Use IE sourceIndex if available on both nodes
                            if ( diff ) {
                                return diff;
                            }

                            // Check if b follows a
                            if ( cur ) {
                                while ( ( cur = cur.nextSibling ) ) {
                                    if ( cur === b ) {
                                        return -1;
                                    }
                                }
                            }

                            return a ? 1 : -1;
                        }

                        /**
                         * Returns a function to use in pseudos for input types
                         * @param {String} type
                         */
                        function createInputPseudo( type ) {
                            return function( elem ) {
                                var name = elem.nodeName.toLowerCase();
                                return name === "input" && elem.type === type;
                            };
                        }

                        /**
                         * Returns a function to use in pseudos for buttons
                         * @param {String} type
                         */
                        function createButtonPseudo( type ) {
                            return function( elem ) {
                                var name = elem.nodeName.toLowerCase();
                                return ( name === "input" || name === "button" ) && elem.type === type;
                            };
                        }

                        /**
                         * Returns a function to use in pseudos for :enabled/:disabled
                         * @param {Boolean} disabled true for :disabled; false for :enabled
                         */
                        function createDisabledPseudo( disabled ) {

                            // Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
                            return function( elem ) {

                                // Only certain elements can match :enabled or :disabled
                                // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
                                // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
                                if ( "form" in elem ) {

                                    // Check for inherited disabledness on relevant non-disabled elements:
                                    // * listed form-associated elements in a disabled fieldset
                                    //   https://html.spec.whatwg.org/multipage/forms.html#category-listed
                                    //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
                                    // * option elements in a disabled optgroup
                                    //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
                                    // All such elements have a "form" property.
                                    if ( elem.parentNode && elem.disabled === false ) {

                                        // Option elements defer to a parent optgroup if present
                                        if ( "label" in elem ) {
                                            if ( "label" in elem.parentNode ) {
                                                return elem.parentNode.disabled === disabled;
                                            } else {
                                                return elem.disabled === disabled;
                                            }
                                        }

                                        // Support: IE 6 - 11
                                        // Use the isDisabled shortcut property to check for disabled fieldset ancestors
                                        return elem.isDisabled === disabled ||

                                            // Where there is no isDisabled, check manually
                                            /* jshint -W018 */
                                            elem.isDisabled !== !disabled &&
                                            inDisabledFieldset( elem ) === disabled;
                                    }

                                    return elem.disabled === disabled;

                                    // Try to winnow out elements that can't be disabled before trusting the disabled property.
                                    // Some victims get caught in our net (label, legend, menu, track), but it shouldn't
                                    // even exist on them, let alone have a boolean value.
                                } else if ( "label" in elem ) {
                                    return elem.disabled === disabled;
                                }

                                // Remaining elements are neither :enabled nor :disabled
                                return false;
                            };
                        }

                        /**
                         * Returns a function to use in pseudos for positionals
                         * @param {Function} fn
                         */
                        function createPositionalPseudo( fn ) {
                            return markFunction( function( argument ) {
                                argument = +argument;
                                return markFunction( function( seed, matches ) {
                                    var j,
                                        matchIndexes = fn( [], seed.length, argument ),
                                        i = matchIndexes.length;

                                    // Match elements found at the specified indexes
                                    while ( i-- ) {
                                        if ( seed[ ( j = matchIndexes[ i ] ) ] ) {
                                            seed[ j ] = !( matches[ j ] = seed[ j ] );
                                        }
                                    }
                                } );
                            } );
                        }

                        /**
                         * Checks a node for validity as a Sizzle context
                         * @param {Element|Object=} context
                         * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
                         */
                        function testContext( context ) {
                            return context && typeof context.getElementsByTagName !== "undefined" && context;
                        }

// Expose support vars for convenience
                        support = Sizzle.support = {};

                        /**
                         * Detects XML nodes
                         * @param {Element|Object} elem An element or a document
                         * @returns {Boolean} True iff elem is a non-HTML XML node
                         */
                        isXML = Sizzle.isXML = function( elem ) {
                            var namespace = elem.namespaceURI,
                                docElem = ( elem.ownerDocument || elem ).documentElement;

                            // Support: IE <=8
                            // Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
                            // https://bugs.jquery.com/ticket/4833
                            return !rhtml.test( namespace || docElem && docElem.nodeName || "HTML" );
                        };

                        /**
                         * Sets document-related variables once based on the current document
                         * @param {Element|Object} [doc] An element or document object to use to set the document
                         * @returns {Object} Returns the current document
                         */
                        setDocument = Sizzle.setDocument = function( node ) {
                            var hasCompare, subWindow,
                                doc = node ? node.ownerDocument || node : preferredDoc;

                            // Return early if doc is invalid or already selected
                            // Support: IE 11+, Edge 17 - 18+
                            // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                            // two documents; shallow comparisons work.
                            // eslint-disable-next-line eqeqeq
                            if ( doc == document || doc.nodeType !== 9 || !doc.documentElement ) {
                                return document;
                            }

                            // Update global variables
                            document = doc;
                            docElem = document.documentElement;
                            documentIsHTML = !isXML( document );

                            // Support: IE 9 - 11+, Edge 12 - 18+
                            // Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
                            // Support: IE 11+, Edge 17 - 18+
                            // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                            // two documents; shallow comparisons work.
                            // eslint-disable-next-line eqeqeq
                            if ( preferredDoc != document &&
                                ( subWindow = document.defaultView ) && subWindow.top !== subWindow ) {

                                // Support: IE 11, Edge
                                if ( subWindow.addEventListener ) {
                                    subWindow.addEventListener( "unload", unloadHandler, false );

                                    // Support: IE 9 - 10 only
                                } else if ( subWindow.attachEvent ) {
                                    subWindow.attachEvent( "onunload", unloadHandler );
                                }
                            }

                            // Support: IE 8 - 11+, Edge 12 - 18+, Chrome <=16 - 25 only, Firefox <=3.6 - 31 only,
                            // Safari 4 - 5 only, Opera <=11.6 - 12.x only
                            // IE/Edge & older browsers don't support the :scope pseudo-class.
                            // Support: Safari 6.0 only
                            // Safari 6.0 supports :scope but it's an alias of :root there.
                            support.scope = assert( function( el ) {
                                docElem.appendChild( el ).appendChild( document.createElement( "div" ) );
                                return typeof el.querySelectorAll !== "undefined" &&
                                    !el.querySelectorAll( ":scope fieldset div" ).length;
                            } );

                            /* Attributes
	---------------------------------------------------------------------- */

                            // Support: IE<8
                            // Verify that getAttribute really returns attributes and not properties
                            // (excepting IE8 booleans)
                            support.attributes = assert( function( el ) {
                                el.className = "i";
                                return !el.getAttribute( "className" );
                            } );

                            /* getElement(s)By*
	---------------------------------------------------------------------- */

                            // Check if getElementsByTagName("*") returns only elements
                            support.getElementsByTagName = assert( function( el ) {
                                el.appendChild( document.createComment( "" ) );
                                return !el.getElementsByTagName( "*" ).length;
                            } );

                            // Support: IE<9
                            support.getElementsByClassName = rnative.test( document.getElementsByClassName );

                            // Support: IE<10
                            // Check if getElementById returns elements by name
                            // The broken getElementById methods don't pick up programmatically-set names,
                            // so use a roundabout getElementsByName test
                            support.getById = assert( function( el ) {
                                docElem.appendChild( el ).id = expando;
                                return !document.getElementsByName || !document.getElementsByName( expando ).length;
                            } );

                            // ID filter and find
                            if ( support.getById ) {
                                Expr.filter[ "ID" ] = function( id ) {
                                    var attrId = id.replace( runescape, funescape );
                                    return function( elem ) {
                                        return elem.getAttribute( "id" ) === attrId;
                                    };
                                };
                                Expr.find[ "ID" ] = function( id, context ) {
                                    if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
                                        var elem = context.getElementById( id );
                                        return elem ? [ elem ] : [];
                                    }
                                };
                            } else {
                                Expr.filter[ "ID" ] =  function( id ) {
                                    var attrId = id.replace( runescape, funescape );
                                    return function( elem ) {
                                        var node = typeof elem.getAttributeNode !== "undefined" &&
                                            elem.getAttributeNode( "id" );
                                        return node && node.value === attrId;
                                    };
                                };

                                // Support: IE 6 - 7 only
                                // getElementById is not reliable as a find shortcut
                                Expr.find[ "ID" ] = function( id, context ) {
                                    if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
                                        var node, i, elems,
                                            elem = context.getElementById( id );

                                        if ( elem ) {

                                            // Verify the id attribute
                                            node = elem.getAttributeNode( "id" );
                                            if ( node && node.value === id ) {
                                                return [ elem ];
                                            }

                                            // Fall back on getElementsByName
                                            elems = context.getElementsByName( id );
                                            i = 0;
                                            while ( ( elem = elems[ i++ ] ) ) {
                                                node = elem.getAttributeNode( "id" );
                                                if ( node && node.value === id ) {
                                                    return [ elem ];
                                                }
                                            }
                                        }

                                        return [];
                                    }
                                };
                            }

                            // Tag
                            Expr.find[ "TAG" ] = support.getElementsByTagName ?
                                function( tag, context ) {
                                    if ( typeof context.getElementsByTagName !== "undefined" ) {
                                        return context.getElementsByTagName( tag );

                                        // DocumentFragment nodes don't have gEBTN
                                    } else if ( support.qsa ) {
                                        return context.querySelectorAll( tag );
                                    }
                                } :

                                function( tag, context ) {
                                    var elem,
                                        tmp = [],
                                        i = 0,

                                        // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
                                        results = context.getElementsByTagName( tag );

                                    // Filter out possible comments
                                    if ( tag === "*" ) {
                                        while ( ( elem = results[ i++ ] ) ) {
                                            if ( elem.nodeType === 1 ) {
                                                tmp.push( elem );
                                            }
                                        }

                                        return tmp;
                                    }
                                    return results;
                                };

                            // Class
                            Expr.find[ "CLASS" ] = support.getElementsByClassName && function( className, context ) {
                                if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
                                    return context.getElementsByClassName( className );
                                }
                            };

                            /* QSA/matchesSelector
	---------------------------------------------------------------------- */

                            // QSA and matchesSelector support

                            // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
                            rbuggyMatches = [];

                            // qSa(:focus) reports false when true (Chrome 21)
                            // We allow this because of a bug in IE8/9 that throws an error
                            // whenever `document.activeElement` is accessed on an iframe
                            // So, we allow :focus to pass through QSA all the time to avoid the IE error
                            // See https://bugs.jquery.com/ticket/13378
                            rbuggyQSA = [];

                            if ( ( support.qsa = rnative.test( document.querySelectorAll ) ) ) {

                                // Build QSA regex
                                // Regex strategy adopted from Diego Perini
                                assert( function( el ) {

                                    var input;

                                    // Select is set to empty string on purpose
                                    // This is to test IE's treatment of not explicitly
                                    // setting a boolean content attribute,
                                    // since its presence should be enough
                                    // https://bugs.jquery.com/ticket/12359
                                    docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
                                        "<select id='" + expando + "-\r\\' msallowcapture=''>" +
                                        "<option selected=''></option></select>";

                                    // Support: IE8, Opera 11-12.16
                                    // Nothing should be selected when empty strings follow ^= or $= or *=
                                    // The test attribute must be unknown in Opera but "safe" for WinRT
                                    // https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
                                    if ( el.querySelectorAll( "[msallowcapture^='']" ).length ) {
                                        rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
                                    }

                                    // Support: IE8
                                    // Boolean attributes and "value" are not treated correctly
                                    if ( !el.querySelectorAll( "[selected]" ).length ) {
                                        rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
                                    }

                                    // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
                                    if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
                                        rbuggyQSA.push( "~=" );
                                    }

                                    // Support: IE 11+, Edge 15 - 18+
                                    // IE 11/Edge don't find elements on a `[name='']` query in some cases.
                                    // Adding a temporary attribute to the document before the selection works
                                    // around the issue.
                                    // Interestingly, IE 10 & older don't seem to have the issue.
                                    input = document.createElement( "input" );
                                    input.setAttribute( "name", "" );
                                    el.appendChild( input );
                                    if ( !el.querySelectorAll( "[name='']" ).length ) {
                                        rbuggyQSA.push( "\\[" + whitespace + "*name" + whitespace + "*=" +
                                            whitespace + "*(?:''|\"\")" );
                                    }

                                    // Webkit/Opera - :checked should return selected option elements
                                    // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                                    // IE8 throws error here and will not see later tests
                                    if ( !el.querySelectorAll( ":checked" ).length ) {
                                        rbuggyQSA.push( ":checked" );
                                    }

                                    // Support: Safari 8+, iOS 8+
                                    // https://bugs.webkit.org/show_bug.cgi?id=136851
                                    // In-page `selector#id sibling-combinator selector` fails
                                    if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
                                        rbuggyQSA.push( ".#.+[+~]" );
                                    }

                                    // Support: Firefox <=3.6 - 5 only
                                    // Old Firefox doesn't throw on a badly-escaped identifier.
                                    el.querySelectorAll( "\\\f" );
                                    rbuggyQSA.push( "[\\r\\n\\f]" );
                                } );

                                assert( function( el ) {
                                    el.innerHTML = "<a href='' disabled='disabled'></a>" +
                                        "<select disabled='disabled'><option/></select>";

                                    // Support: Windows 8 Native Apps
                                    // The type and name attributes are restricted during .innerHTML assignment
                                    var input = document.createElement( "input" );
                                    input.setAttribute( "type", "hidden" );
                                    el.appendChild( input ).setAttribute( "name", "D" );

                                    // Support: IE8
                                    // Enforce case-sensitivity of name attribute
                                    if ( el.querySelectorAll( "[name=d]" ).length ) {
                                        rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
                                    }

                                    // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
                                    // IE8 throws error here and will not see later tests
                                    if ( el.querySelectorAll( ":enabled" ).length !== 2 ) {
                                        rbuggyQSA.push( ":enabled", ":disabled" );
                                    }

                                    // Support: IE9-11+
                                    // IE's :disabled selector does not pick up the children of disabled fieldsets
                                    docElem.appendChild( el ).disabled = true;
                                    if ( el.querySelectorAll( ":disabled" ).length !== 2 ) {
                                        rbuggyQSA.push( ":enabled", ":disabled" );
                                    }

                                    // Support: Opera 10 - 11 only
                                    // Opera 10-11 does not throw on post-comma invalid pseudos
                                    el.querySelectorAll( "*,:x" );
                                    rbuggyQSA.push( ",.*:" );
                                } );
                            }

                            if ( ( support.matchesSelector = rnative.test( ( matches = docElem.matches ||
                                docElem.webkitMatchesSelector ||
                                docElem.mozMatchesSelector ||
                                docElem.oMatchesSelector ||
                                docElem.msMatchesSelector ) ) ) ) {

                                assert( function( el ) {

                                    // Check to see if it's possible to do matchesSelector
                                    // on a disconnected node (IE 9)
                                    support.disconnectedMatch = matches.call( el, "*" );

                                    // This should fail with an exception
                                    // Gecko does not error, returns false instead
                                    matches.call( el, "[s!='']:x" );
                                    rbuggyMatches.push( "!=", pseudos );
                                } );
                            }

                            rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join( "|" ) );
                            rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join( "|" ) );

                            /* Contains
	---------------------------------------------------------------------- */
                            hasCompare = rnative.test( docElem.compareDocumentPosition );

                            // Element contains another
                            // Purposefully self-exclusive
                            // As in, an element does not contain itself
                            contains = hasCompare || rnative.test( docElem.contains ) ?
                                function( a, b ) {
                                    var adown = a.nodeType === 9 ? a.documentElement : a,
                                        bup = b && b.parentNode;
                                    return a === bup || !!( bup && bup.nodeType === 1 && (
                                        adown.contains ?
                                            adown.contains( bup ) :
                                            a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
                                    ) );
                                } :
                                function( a, b ) {
                                    if ( b ) {
                                        while ( ( b = b.parentNode ) ) {
                                            if ( b === a ) {
                                                return true;
                                            }
                                        }
                                    }
                                    return false;
                                };

                            /* Sorting
	---------------------------------------------------------------------- */

                            // Document order sorting
                            sortOrder = hasCompare ?
                                function( a, b ) {

                                    // Flag for duplicate removal
                                    if ( a === b ) {
                                        hasDuplicate = true;
                                        return 0;
                                    }

                                    // Sort on method existence if only one input has compareDocumentPosition
                                    var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                                    if ( compare ) {
                                        return compare;
                                    }

                                    // Calculate position if both inputs belong to the same document
                                    // Support: IE 11+, Edge 17 - 18+
                                    // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                                    // two documents; shallow comparisons work.
                                    // eslint-disable-next-line eqeqeq
                                    compare = ( a.ownerDocument || a ) == ( b.ownerDocument || b ) ?
                                        a.compareDocumentPosition( b ) :

                                        // Otherwise we know they are disconnected
                                        1;

                                    // Disconnected nodes
                                    if ( compare & 1 ||
                                        ( !support.sortDetached && b.compareDocumentPosition( a ) === compare ) ) {

                                        // Choose the first element that is related to our preferred document
                                        // Support: IE 11+, Edge 17 - 18+
                                        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                                        // two documents; shallow comparisons work.
                                        // eslint-disable-next-line eqeqeq
                                        if ( a == document || a.ownerDocument == preferredDoc &&
                                            contains( preferredDoc, a ) ) {
                                            return -1;
                                        }

                                        // Support: IE 11+, Edge 17 - 18+
                                        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                                        // two documents; shallow comparisons work.
                                        // eslint-disable-next-line eqeqeq
                                        if ( b == document || b.ownerDocument == preferredDoc &&
                                            contains( preferredDoc, b ) ) {
                                            return 1;
                                        }

                                        // Maintain original order
                                        return sortInput ?
                                            ( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
                                            0;
                                    }

                                    return compare & 4 ? -1 : 1;
                                } :
                                function( a, b ) {

                                    // Exit early if the nodes are identical
                                    if ( a === b ) {
                                        hasDuplicate = true;
                                        return 0;
                                    }

                                    var cur,
                                        i = 0,
                                        aup = a.parentNode,
                                        bup = b.parentNode,
                                        ap = [ a ],
                                        bp = [ b ];

                                    // Parentless nodes are either documents or disconnected
                                    if ( !aup || !bup ) {

                                        // Support: IE 11+, Edge 17 - 18+
                                        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                                        // two documents; shallow comparisons work.
                                        /* eslint-disable eqeqeq */
                                        return a == document ? -1 :
                                            b == document ? 1 :
                                                /* eslint-enable eqeqeq */
                                                aup ? -1 :
                                                    bup ? 1 :
                                                        sortInput ?
                                                            ( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
                                                            0;

                                        // If the nodes are siblings, we can do a quick check
                                    } else if ( aup === bup ) {
                                        return siblingCheck( a, b );
                                    }

                                    // Otherwise we need full lists of their ancestors for comparison
                                    cur = a;
                                    while ( ( cur = cur.parentNode ) ) {
                                        ap.unshift( cur );
                                    }
                                    cur = b;
                                    while ( ( cur = cur.parentNode ) ) {
                                        bp.unshift( cur );
                                    }

                                    // Walk down the tree looking for a discrepancy
                                    while ( ap[ i ] === bp[ i ] ) {
                                        i++;
                                    }

                                    return i ?

                                        // Do a sibling check if the nodes have a common ancestor
                                        siblingCheck( ap[ i ], bp[ i ] ) :

                                        // Otherwise nodes in our document sort first
                                        // Support: IE 11+, Edge 17 - 18+
                                        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                                        // two documents; shallow comparisons work.
                                        /* eslint-disable eqeqeq */
                                        ap[ i ] == preferredDoc ? -1 :
                                            bp[ i ] == preferredDoc ? 1 :
                                                /* eslint-enable eqeqeq */
                                                0;
                                };

                            return document;
                        };

                        Sizzle.matches = function( expr, elements ) {
                            return Sizzle( expr, null, null, elements );
                        };

                        Sizzle.matchesSelector = function( elem, expr ) {
                            setDocument( elem );

                            if ( support.matchesSelector && documentIsHTML &&
                                !nonnativeSelectorCache[ expr + " " ] &&
                                ( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
                                ( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

                                try {
                                    var ret = matches.call( elem, expr );

                                    // IE 9's matchesSelector returns false on disconnected nodes
                                    if ( ret || support.disconnectedMatch ||

                                        // As well, disconnected nodes are said to be in a document
                                        // fragment in IE 9
                                        elem.document && elem.document.nodeType !== 11 ) {
                                        return ret;
                                    }
                                } catch ( e ) {
                                    nonnativeSelectorCache( expr, true );
                                }
                            }

                            return Sizzle( expr, document, null, [ elem ] ).length > 0;
                        };

                        Sizzle.contains = function( context, elem ) {

                            // Set document vars if needed
                            // Support: IE 11+, Edge 17 - 18+
                            // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                            // two documents; shallow comparisons work.
                            // eslint-disable-next-line eqeqeq
                            if ( ( context.ownerDocument || context ) != document ) {
                                setDocument( context );
                            }
                            return contains( context, elem );
                        };

                        Sizzle.attr = function( elem, name ) {

                            // Set document vars if needed
                            // Support: IE 11+, Edge 17 - 18+
                            // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                            // two documents; shallow comparisons work.
                            // eslint-disable-next-line eqeqeq
                            if ( ( elem.ownerDocument || elem ) != document ) {
                                setDocument( elem );
                            }

                            var fn = Expr.attrHandle[ name.toLowerCase() ],

                                // Don't get fooled by Object.prototype properties (jQuery #13807)
                                val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
                                    fn( elem, name, !documentIsHTML ) :
                                    undefined;

                            return val !== undefined ?
                                val :
                                support.attributes || !documentIsHTML ?
                                    elem.getAttribute( name ) :
                                    ( val = elem.getAttributeNode( name ) ) && val.specified ?
                                        val.value :
                                        null;
                        };

                        Sizzle.escape = function( sel ) {
                            return ( sel + "" ).replace( rcssescape, fcssescape );
                        };

                        Sizzle.error = function( msg ) {
                            throw new Error( "Syntax error, unrecognized expression: " + msg );
                        };

                        /**
                         * Document sorting and removing duplicates
                         * @param {ArrayLike} results
                         */
                        Sizzle.uniqueSort = function( results ) {
                            var elem,
                                duplicates = [],
                                j = 0,
                                i = 0;

                            // Unless we *know* we can detect duplicates, assume their presence
                            hasDuplicate = !support.detectDuplicates;
                            sortInput = !support.sortStable && results.slice( 0 );
                            results.sort( sortOrder );

                            if ( hasDuplicate ) {
                                while ( ( elem = results[ i++ ] ) ) {
                                    if ( elem === results[ i ] ) {
                                        j = duplicates.push( i );
                                    }
                                }
                                while ( j-- ) {
                                    results.splice( duplicates[ j ], 1 );
                                }
                            }

                            // Clear input after sorting to release objects
                            // See https://github.com/jquery/sizzle/pull/225
                            sortInput = null;

                            return results;
                        };

                        /**
                         * Utility function for retrieving the text value of an array of DOM nodes
                         * @param {Array|Element} elem
                         */
                        getText = Sizzle.getText = function( elem ) {
                            var node,
                                ret = "",
                                i = 0,
                                nodeType = elem.nodeType;

                            if ( !nodeType ) {

                                // If no nodeType, this is expected to be an array
                                while ( ( node = elem[ i++ ] ) ) {

                                    // Do not traverse comment nodes
                                    ret += getText( node );
                                }
                            } else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {

                                // Use textContent for elements
                                // innerText usage removed for consistency of new lines (jQuery #11153)
                                if ( typeof elem.textContent === "string" ) {
                                    return elem.textContent;
                                } else {

                                    // Traverse its children
                                    for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
                                        ret += getText( elem );
                                    }
                                }
                            } else if ( nodeType === 3 || nodeType === 4 ) {
                                return elem.nodeValue;
                            }

                            // Do not include comment or processing instruction nodes

                            return ret;
                        };

                        Expr = Sizzle.selectors = {

                            // Can be adjusted by the user
                            cacheLength: 50,

                            createPseudo: markFunction,

                            match: matchExpr,

                            attrHandle: {},

                            find: {},

                            relative: {
                                ">": { dir: "parentNode", first: true },
                                " ": { dir: "parentNode" },
                                "+": { dir: "previousSibling", first: true },
                                "~": { dir: "previousSibling" }
                            },

                            preFilter: {
                                "ATTR": function( match ) {
                                    match[ 1 ] = match[ 1 ].replace( runescape, funescape );

                                    // Move the given value to match[3] whether quoted or unquoted
                                    match[ 3 ] = ( match[ 3 ] || match[ 4 ] ||
                                        match[ 5 ] || "" ).replace( runescape, funescape );

                                    if ( match[ 2 ] === "~=" ) {
                                        match[ 3 ] = " " + match[ 3 ] + " ";
                                    }

                                    return match.slice( 0, 4 );
                                },

                                "CHILD": function( match ) {

                                    /* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
                                    match[ 1 ] = match[ 1 ].toLowerCase();

                                    if ( match[ 1 ].slice( 0, 3 ) === "nth" ) {

                                        // nth-* requires argument
                                        if ( !match[ 3 ] ) {
                                            Sizzle.error( match[ 0 ] );
                                        }

                                        // numeric x and y parameters for Expr.filter.CHILD
                                        // remember that false/true cast respectively to 0/1
                                        match[ 4 ] = +( match[ 4 ] ?
                                            match[ 5 ] + ( match[ 6 ] || 1 ) :
                                            2 * ( match[ 3 ] === "even" || match[ 3 ] === "odd" ) );
                                        match[ 5 ] = +( ( match[ 7 ] + match[ 8 ] ) || match[ 3 ] === "odd" );

                                        // other types prohibit arguments
                                    } else if ( match[ 3 ] ) {
                                        Sizzle.error( match[ 0 ] );
                                    }

                                    return match;
                                },

                                "PSEUDO": function( match ) {
                                    var excess,
                                        unquoted = !match[ 6 ] && match[ 2 ];

                                    if ( matchExpr[ "CHILD" ].test( match[ 0 ] ) ) {
                                        return null;
                                    }

                                    // Accept quoted arguments as-is
                                    if ( match[ 3 ] ) {
                                        match[ 2 ] = match[ 4 ] || match[ 5 ] || "";

                                        // Strip excess characters from unquoted arguments
                                    } else if ( unquoted && rpseudo.test( unquoted ) &&

                                        // Get excess from tokenize (recursively)
                                        ( excess = tokenize( unquoted, true ) ) &&

                                        // advance to the next closing parenthesis
                                        ( excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length ) ) {

                                        // excess is a negative index
                                        match[ 0 ] = match[ 0 ].slice( 0, excess );
                                        match[ 2 ] = unquoted.slice( 0, excess );
                                    }

                                    // Return only captures needed by the pseudo filter method (type and argument)
                                    return match.slice( 0, 3 );
                                }
                            },

                            filter: {

                                "TAG": function( nodeNameSelector ) {
                                    var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
                                    return nodeNameSelector === "*" ?
                                        function() {
                                            return true;
                                        } :
                                        function( elem ) {
                                            return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                                        };
                                },

                                "CLASS": function( className ) {
                                    var pattern = classCache[ className + " " ];

                                    return pattern ||
                                        ( pattern = new RegExp( "(^|" + whitespace +
                                            ")" + className + "(" + whitespace + "|$)" ) ) && classCache(
                                            className, function( elem ) {
                                                return pattern.test(
                                                    typeof elem.className === "string" && elem.className ||
                                                    typeof elem.getAttribute !== "undefined" &&
                                                    elem.getAttribute( "class" ) ||
                                                    ""
                                                );
                                            } );
                                },

                                "ATTR": function( name, operator, check ) {
                                    return function( elem ) {
                                        var result = Sizzle.attr( elem, name );

                                        if ( result == null ) {
                                            return operator === "!=";
                                        }
                                        if ( !operator ) {
                                            return true;
                                        }

                                        result += "";

                                        /* eslint-disable max-len */

                                        return operator === "=" ? result === check :
                                            operator === "!=" ? result !== check :
                                                operator === "^=" ? check && result.indexOf( check ) === 0 :
                                                    operator === "*=" ? check && result.indexOf( check ) > -1 :
                                                        operator === "$=" ? check && result.slice( -check.length ) === check :
                                                            operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
                                                                operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
                                                                    false;
                                        /* eslint-enable max-len */

                                    };
                                },

                                "CHILD": function( type, what, _argument, first, last ) {
                                    var simple = type.slice( 0, 3 ) !== "nth",
                                        forward = type.slice( -4 ) !== "last",
                                        ofType = what === "of-type";

                                    return first === 1 && last === 0 ?

                                        // Shortcut for :nth-*(n)
                                        function( elem ) {
                                            return !!elem.parentNode;
                                        } :

                                        function( elem, _context, xml ) {
                                            var cache, uniqueCache, outerCache, node, nodeIndex, start,
                                                dir = simple !== forward ? "nextSibling" : "previousSibling",
                                                parent = elem.parentNode,
                                                name = ofType && elem.nodeName.toLowerCase(),
                                                useCache = !xml && !ofType,
                                                diff = false;

                                            if ( parent ) {

                                                // :(first|last|only)-(child|of-type)
                                                if ( simple ) {
                                                    while ( dir ) {
                                                        node = elem;
                                                        while ( ( node = node[ dir ] ) ) {
                                                            if ( ofType ?
                                                                node.nodeName.toLowerCase() === name :
                                                                node.nodeType === 1 ) {

                                                                return false;
                                                            }
                                                        }

                                                        // Reverse direction for :only-* (if we haven't yet done so)
                                                        start = dir = type === "only" && !start && "nextSibling";
                                                    }
                                                    return true;
                                                }

                                                start = [ forward ? parent.firstChild : parent.lastChild ];

                                                // non-xml :nth-child(...) stores cache data on `parent`
                                                if ( forward && useCache ) {

                                                    // Seek `elem` from a previously-cached index

                                                    // ...in a gzip-friendly way
                                                    node = parent;
                                                    outerCache = node[ expando ] || ( node[ expando ] = {} );

                                                    // Support: IE <9 only
                                                    // Defend against cloned attroperties (jQuery gh-1709)
                                                    uniqueCache = outerCache[ node.uniqueID ] ||
                                                        ( outerCache[ node.uniqueID ] = {} );

                                                    cache = uniqueCache[ type ] || [];
                                                    nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
                                                    diff = nodeIndex && cache[ 2 ];
                                                    node = nodeIndex && parent.childNodes[ nodeIndex ];

                                                    while ( ( node = ++nodeIndex && node && node[ dir ] ||

                                                        // Fallback to seeking `elem` from the start
                                                        ( diff = nodeIndex = 0 ) || start.pop() ) ) {

                                                        // When found, cache indexes on `parent` and break
                                                        if ( node.nodeType === 1 && ++diff && node === elem ) {
                                                            uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
                                                            break;
                                                        }
                                                    }

                                                } else {

                                                    // Use previously-cached element index if available
                                                    if ( useCache ) {

                                                        // ...in a gzip-friendly way
                                                        node = elem;
                                                        outerCache = node[ expando ] || ( node[ expando ] = {} );

                                                        // Support: IE <9 only
                                                        // Defend against cloned attroperties (jQuery gh-1709)
                                                        uniqueCache = outerCache[ node.uniqueID ] ||
                                                            ( outerCache[ node.uniqueID ] = {} );

                                                        cache = uniqueCache[ type ] || [];
                                                        nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
                                                        diff = nodeIndex;
                                                    }

                                                    // xml :nth-child(...)
                                                    // or :nth-last-child(...) or :nth(-last)?-of-type(...)
                                                    if ( diff === false ) {

                                                        // Use the same loop as above to seek `elem` from the start
                                                        while ( ( node = ++nodeIndex && node && node[ dir ] ||
                                                            ( diff = nodeIndex = 0 ) || start.pop() ) ) {

                                                            if ( ( ofType ?
                                                                    node.nodeName.toLowerCase() === name :
                                                                    node.nodeType === 1 ) &&
                                                                ++diff ) {

                                                                // Cache the index of each encountered element
                                                                if ( useCache ) {
                                                                    outerCache = node[ expando ] ||
                                                                        ( node[ expando ] = {} );

                                                                    // Support: IE <9 only
                                                                    // Defend against cloned attroperties (jQuery gh-1709)
                                                                    uniqueCache = outerCache[ node.uniqueID ] ||
                                                                        ( outerCache[ node.uniqueID ] = {} );

                                                                    uniqueCache[ type ] = [ dirruns, diff ];
                                                                }

                                                                if ( node === elem ) {
                                                                    break;
                                                                }
                                                            }
                                                        }
                                                    }
                                                }

                                                // Incorporate the offset, then check against cycle size
                                                diff -= last;
                                                return diff === first || ( diff % first === 0 && diff / first >= 0 );
                                            }
                                        };
                                },

                                "PSEUDO": function( pseudo, argument ) {

                                    // pseudo-class names are case-insensitive
                                    // http://www.w3.org/TR/selectors/#pseudo-classes
                                    // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
                                    // Remember that setFilters inherits from pseudos
                                    var args,
                                        fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
                                            Sizzle.error( "unsupported pseudo: " + pseudo );

                                    // The user may use createPseudo to indicate that
                                    // arguments are needed to create the filter function
                                    // just as Sizzle does
                                    if ( fn[ expando ] ) {
                                        return fn( argument );
                                    }

                                    // But maintain support for old signatures
                                    if ( fn.length > 1 ) {
                                        args = [ pseudo, pseudo, "", argument ];
                                        return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
                                            markFunction( function( seed, matches ) {
                                                var idx,
                                                    matched = fn( seed, argument ),
                                                    i = matched.length;
                                                while ( i-- ) {
                                                    idx = indexOf( seed, matched[ i ] );
                                                    seed[ idx ] = !( matches[ idx ] = matched[ i ] );
                                                }
                                            } ) :
                                            function( elem ) {
                                                return fn( elem, 0, args );
                                            };
                                    }

                                    return fn;
                                }
                            },

                            pseudos: {

                                // Potentially complex pseudos
                                "not": markFunction( function( selector ) {

                                    // Trim the selector passed to compile
                                    // to avoid treating leading and trailing
                                    // spaces as combinators
                                    var input = [],
                                        results = [],
                                        matcher = compile( selector.replace( rtrim, "$1" ) );

                                    return matcher[ expando ] ?
                                        markFunction( function( seed, matches, _context, xml ) {
                                            var elem,
                                                unmatched = matcher( seed, null, xml, [] ),
                                                i = seed.length;

                                            // Match elements unmatched by `matcher`
                                            while ( i-- ) {
                                                if ( ( elem = unmatched[ i ] ) ) {
                                                    seed[ i ] = !( matches[ i ] = elem );
                                                }
                                            }
                                        } ) :
                                        function( elem, _context, xml ) {
                                            input[ 0 ] = elem;
                                            matcher( input, null, xml, results );

                                            // Don't keep the element (issue #299)
                                            input[ 0 ] = null;
                                            return !results.pop();
                                        };
                                } ),

                                "has": markFunction( function( selector ) {
                                    return function( elem ) {
                                        return Sizzle( selector, elem ).length > 0;
                                    };
                                } ),

                                "contains": markFunction( function( text ) {
                                    text = text.replace( runescape, funescape );
                                    return function( elem ) {
                                        return ( elem.textContent || getText( elem ) ).indexOf( text ) > -1;
                                    };
                                } ),

                                // "Whether an element is represented by a :lang() selector
                                // is based solely on the element's language value
                                // being equal to the identifier C,
                                // or beginning with the identifier C immediately followed by "-".
                                // The matching of C against the element's language value is performed case-insensitively.
                                // The identifier C does not have to be a valid language name."
                                // http://www.w3.org/TR/selectors/#lang-pseudo
                                "lang": markFunction( function( lang ) {

                                    // lang value must be a valid identifier
                                    if ( !ridentifier.test( lang || "" ) ) {
                                        Sizzle.error( "unsupported lang: " + lang );
                                    }
                                    lang = lang.replace( runescape, funescape ).toLowerCase();
                                    return function( elem ) {
                                        var elemLang;
                                        do {
                                            if ( ( elemLang = documentIsHTML ?
                                                elem.lang :
                                                elem.getAttribute( "xml:lang" ) || elem.getAttribute( "lang" ) ) ) {

                                                elemLang = elemLang.toLowerCase();
                                                return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
                                            }
                                        } while ( ( elem = elem.parentNode ) && elem.nodeType === 1 );
                                        return false;
                                    };
                                } ),

                                // Miscellaneous
                                "target": function( elem ) {
                                    var hash = window.location && window.location.hash;
                                    return hash && hash.slice( 1 ) === elem.id;
                                },

                                "root": function( elem ) {
                                    return elem === docElem;
                                },

                                "focus": function( elem ) {
                                    return elem === document.activeElement &&
                                        ( !document.hasFocus || document.hasFocus() ) &&
                                        !!( elem.type || elem.href || ~elem.tabIndex );
                                },

                                // Boolean properties
                                "enabled": createDisabledPseudo( false ),
                                "disabled": createDisabledPseudo( true ),

                                "checked": function( elem ) {

                                    // In CSS3, :checked should return both checked and selected elements
                                    // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                                    var nodeName = elem.nodeName.toLowerCase();
                                    return ( nodeName === "input" && !!elem.checked ) ||
                                        ( nodeName === "option" && !!elem.selected );
                                },

                                "selected": function( elem ) {

                                    // Accessing this property makes selected-by-default
                                    // options in Safari work properly
                                    if ( elem.parentNode ) {
                                        // eslint-disable-next-line no-unused-expressions
                                        elem.parentNode.selectedIndex;
                                    }

                                    return elem.selected === true;
                                },

                                // Contents
                                "empty": function( elem ) {

                                    // http://www.w3.org/TR/selectors/#empty-pseudo
                                    // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
                                    //   but not by others (comment: 8; processing instruction: 7; etc.)
                                    // nodeType < 6 works because attributes (2) do not appear as children
                                    for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
                                        if ( elem.nodeType < 6 ) {
                                            return false;
                                        }
                                    }
                                    return true;
                                },

                                "parent": function( elem ) {
                                    return !Expr.pseudos[ "empty" ]( elem );
                                },

                                // Element/input types
                                "header": function( elem ) {
                                    return rheader.test( elem.nodeName );
                                },

                                "input": function( elem ) {
                                    return rinputs.test( elem.nodeName );
                                },

                                "button": function( elem ) {
                                    var name = elem.nodeName.toLowerCase();
                                    return name === "input" && elem.type === "button" || name === "button";
                                },

                                "text": function( elem ) {
                                    var attr;
                                    return elem.nodeName.toLowerCase() === "input" &&
                                        elem.type === "text" &&

                                        // Support: IE<8
                                        // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
                                        ( ( attr = elem.getAttribute( "type" ) ) == null ||
                                            attr.toLowerCase() === "text" );
                                },

                                // Position-in-collection
                                "first": createPositionalPseudo( function() {
                                    return [ 0 ];
                                } ),

                                "last": createPositionalPseudo( function( _matchIndexes, length ) {
                                    return [ length - 1 ];
                                } ),

                                "eq": createPositionalPseudo( function( _matchIndexes, length, argument ) {
                                    return [ argument < 0 ? argument + length : argument ];
                                } ),

                                "even": createPositionalPseudo( function( matchIndexes, length ) {
                                    var i = 0;
                                    for ( ; i < length; i += 2 ) {
                                        matchIndexes.push( i );
                                    }
                                    return matchIndexes;
                                } ),

                                "odd": createPositionalPseudo( function( matchIndexes, length ) {
                                    var i = 1;
                                    for ( ; i < length; i += 2 ) {
                                        matchIndexes.push( i );
                                    }
                                    return matchIndexes;
                                } ),

                                "lt": createPositionalPseudo( function( matchIndexes, length, argument ) {
                                    var i = argument < 0 ?
                                        argument + length :
                                        argument > length ?
                                            length :
                                            argument;
                                    for ( ; --i >= 0; ) {
                                        matchIndexes.push( i );
                                    }
                                    return matchIndexes;
                                } ),

                                "gt": createPositionalPseudo( function( matchIndexes, length, argument ) {
                                    var i = argument < 0 ? argument + length : argument;
                                    for ( ; ++i < length; ) {
                                        matchIndexes.push( i );
                                    }
                                    return matchIndexes;
                                } )
                            }
                        };

                        Expr.pseudos[ "nth" ] = Expr.pseudos[ "eq" ];

// Add button/input type pseudos
                        for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
                            Expr.pseudos[ i ] = createInputPseudo( i );
                        }
                        for ( i in { submit: true, reset: true } ) {
                            Expr.pseudos[ i ] = createButtonPseudo( i );
                        }

// Easy API for creating new setFilters
                        function setFilters() {}
                        setFilters.prototype = Expr.filters = Expr.pseudos;
                        Expr.setFilters = new setFilters();

                        tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
                            var matched, match, tokens, type,
                                soFar, groups, preFilters,
                                cached = tokenCache[ selector + " " ];

                            if ( cached ) {
                                return parseOnly ? 0 : cached.slice( 0 );
                            }

                            soFar = selector;
                            groups = [];
                            preFilters = Expr.preFilter;

                            while ( soFar ) {

                                // Comma and first run
                                if ( !matched || ( match = rcomma.exec( soFar ) ) ) {
                                    if ( match ) {

                                        // Don't consume trailing commas as valid
                                        soFar = soFar.slice( match[ 0 ].length ) || soFar;
                                    }
                                    groups.push( ( tokens = [] ) );
                                }

                                matched = false;

                                // Combinators
                                if ( ( match = rcombinators.exec( soFar ) ) ) {
                                    matched = match.shift();
                                    tokens.push( {
                                        value: matched,

                                        // Cast descendant combinators to space
                                        type: match[ 0 ].replace( rtrim, " " )
                                    } );
                                    soFar = soFar.slice( matched.length );
                                }

                                // Filters
                                for ( type in Expr.filter ) {
                                    if ( ( match = matchExpr[ type ].exec( soFar ) ) && ( !preFilters[ type ] ||
                                        ( match = preFilters[ type ]( match ) ) ) ) {
                                        matched = match.shift();
                                        tokens.push( {
                                            value: matched,
                                            type: type,
                                            matches: match
                                        } );
                                        soFar = soFar.slice( matched.length );
                                    }
                                }

                                if ( !matched ) {
                                    break;
                                }
                            }

                            // Return the length of the invalid excess
                            // if we're just parsing
                            // Otherwise, throw an error or return tokens
                            return parseOnly ?
                                soFar.length :
                                soFar ?
                                    Sizzle.error( selector ) :

                                    // Cache the tokens
                                    tokenCache( selector, groups ).slice( 0 );
                        };

                        function toSelector( tokens ) {
                            var i = 0,
                                len = tokens.length,
                                selector = "";
                            for ( ; i < len; i++ ) {
                                selector += tokens[ i ].value;
                            }
                            return selector;
                        }

                        function addCombinator( matcher, combinator, base ) {
                            var dir = combinator.dir,
                                skip = combinator.next,
                                key = skip || dir,
                                checkNonElements = base && key === "parentNode",
                                doneName = done++;

                            return combinator.first ?

                                // Check against closest ancestor/preceding element
                                function( elem, context, xml ) {
                                    while ( ( elem = elem[ dir ] ) ) {
                                        if ( elem.nodeType === 1 || checkNonElements ) {
                                            return matcher( elem, context, xml );
                                        }
                                    }
                                    return false;
                                } :

                                // Check against all ancestor/preceding elements
                                function( elem, context, xml ) {
                                    var oldCache, uniqueCache, outerCache,
                                        newCache = [ dirruns, doneName ];

                                    // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
                                    if ( xml ) {
                                        while ( ( elem = elem[ dir ] ) ) {
                                            if ( elem.nodeType === 1 || checkNonElements ) {
                                                if ( matcher( elem, context, xml ) ) {
                                                    return true;
                                                }
                                            }
                                        }
                                    } else {
                                        while ( ( elem = elem[ dir ] ) ) {
                                            if ( elem.nodeType === 1 || checkNonElements ) {
                                                outerCache = elem[ expando ] || ( elem[ expando ] = {} );

                                                // Support: IE <9 only
                                                // Defend against cloned attroperties (jQuery gh-1709)
                                                uniqueCache = outerCache[ elem.uniqueID ] ||
                                                    ( outerCache[ elem.uniqueID ] = {} );

                                                if ( skip && skip === elem.nodeName.toLowerCase() ) {
                                                    elem = elem[ dir ] || elem;
                                                } else if ( ( oldCache = uniqueCache[ key ] ) &&
                                                    oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

                                                    // Assign to newCache so results back-propagate to previous elements
                                                    return ( newCache[ 2 ] = oldCache[ 2 ] );
                                                } else {

                                                    // Reuse newcache so results back-propagate to previous elements
                                                    uniqueCache[ key ] = newCache;

                                                    // A match means we're done; a fail means we have to keep checking
                                                    if ( ( newCache[ 2 ] = matcher( elem, context, xml ) ) ) {
                                                        return true;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    return false;
                                };
                        }

                        function elementMatcher( matchers ) {
                            return matchers.length > 1 ?
                                function( elem, context, xml ) {
                                    var i = matchers.length;
                                    while ( i-- ) {
                                        if ( !matchers[ i ]( elem, context, xml ) ) {
                                            return false;
                                        }
                                    }
                                    return true;
                                } :
                                matchers[ 0 ];
                        }

                        function multipleContexts( selector, contexts, results ) {
                            var i = 0,
                                len = contexts.length;
                            for ( ; i < len; i++ ) {
                                Sizzle( selector, contexts[ i ], results );
                            }
                            return results;
                        }

                        function condense( unmatched, map, filter, context, xml ) {
                            var elem,
                                newUnmatched = [],
                                i = 0,
                                len = unmatched.length,
                                mapped = map != null;

                            for ( ; i < len; i++ ) {
                                if ( ( elem = unmatched[ i ] ) ) {
                                    if ( !filter || filter( elem, context, xml ) ) {
                                        newUnmatched.push( elem );
                                        if ( mapped ) {
                                            map.push( i );
                                        }
                                    }
                                }
                            }

                            return newUnmatched;
                        }

                        function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
                            if ( postFilter && !postFilter[ expando ] ) {
                                postFilter = setMatcher( postFilter );
                            }
                            if ( postFinder && !postFinder[ expando ] ) {
                                postFinder = setMatcher( postFinder, postSelector );
                            }
                            return markFunction( function( seed, results, context, xml ) {
                                var temp, i, elem,
                                    preMap = [],
                                    postMap = [],
                                    preexisting = results.length,

                                    // Get initial elements from seed or context
                                    elems = seed || multipleContexts(
                                        selector || "*",
                                        context.nodeType ? [ context ] : context,
                                        []
                                    ),

                                    // Prefilter to get matcher input, preserving a map for seed-results synchronization
                                    matcherIn = preFilter && ( seed || !selector ) ?
                                        condense( elems, preMap, preFilter, context, xml ) :
                                        elems,

                                    matcherOut = matcher ?

                                        // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
                                        postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

                                            // ...intermediate processing is necessary
                                            [] :

                                            // ...otherwise use results directly
                                            results :
                                        matcherIn;

                                // Find primary matches
                                if ( matcher ) {
                                    matcher( matcherIn, matcherOut, context, xml );
                                }

                                // Apply postFilter
                                if ( postFilter ) {
                                    temp = condense( matcherOut, postMap );
                                    postFilter( temp, [], context, xml );

                                    // Un-match failing elements by moving them back to matcherIn
                                    i = temp.length;
                                    while ( i-- ) {
                                        if ( ( elem = temp[ i ] ) ) {
                                            matcherOut[ postMap[ i ] ] = !( matcherIn[ postMap[ i ] ] = elem );
                                        }
                                    }
                                }

                                if ( seed ) {
                                    if ( postFinder || preFilter ) {
                                        if ( postFinder ) {

                                            // Get the final matcherOut by condensing this intermediate into postFinder contexts
                                            temp = [];
                                            i = matcherOut.length;
                                            while ( i-- ) {
                                                if ( ( elem = matcherOut[ i ] ) ) {

                                                    // Restore matcherIn since elem is not yet a final match
                                                    temp.push( ( matcherIn[ i ] = elem ) );
                                                }
                                            }
                                            postFinder( null, ( matcherOut = [] ), temp, xml );
                                        }

                                        // Move matched elements from seed to results to keep them synchronized
                                        i = matcherOut.length;
                                        while ( i-- ) {
                                            if ( ( elem = matcherOut[ i ] ) &&
                                                ( temp = postFinder ? indexOf( seed, elem ) : preMap[ i ] ) > -1 ) {

                                                seed[ temp ] = !( results[ temp ] = elem );
                                            }
                                        }
                                    }

                                    // Add elements to results, through postFinder if defined
                                } else {
                                    matcherOut = condense(
                                        matcherOut === results ?
                                            matcherOut.splice( preexisting, matcherOut.length ) :
                                            matcherOut
                                    );
                                    if ( postFinder ) {
                                        postFinder( null, results, matcherOut, xml );
                                    } else {
                                        push.apply( results, matcherOut );
                                    }
                                }
                            } );
                        }

                        function matcherFromTokens( tokens ) {
                            var checkContext, matcher, j,
                                len = tokens.length,
                                leadingRelative = Expr.relative[ tokens[ 0 ].type ],
                                implicitRelative = leadingRelative || Expr.relative[ " " ],
                                i = leadingRelative ? 1 : 0,

                                // The foundational matcher ensures that elements are reachable from top-level context(s)
                                matchContext = addCombinator( function( elem ) {
                                    return elem === checkContext;
                                }, implicitRelative, true ),
                                matchAnyContext = addCombinator( function( elem ) {
                                    return indexOf( checkContext, elem ) > -1;
                                }, implicitRelative, true ),
                                matchers = [ function( elem, context, xml ) {
                                    var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
                                        ( checkContext = context ).nodeType ?
                                            matchContext( elem, context, xml ) :
                                            matchAnyContext( elem, context, xml ) );

                                    // Avoid hanging onto element (issue #299)
                                    checkContext = null;
                                    return ret;
                                } ];

                            for ( ; i < len; i++ ) {
                                if ( ( matcher = Expr.relative[ tokens[ i ].type ] ) ) {
                                    matchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];
                                } else {
                                    matcher = Expr.filter[ tokens[ i ].type ].apply( null, tokens[ i ].matches );

                                    // Return special upon seeing a positional matcher
                                    if ( matcher[ expando ] ) {

                                        // Find the next relative operator (if any) for proper handling
                                        j = ++i;
                                        for ( ; j < len; j++ ) {
                                            if ( Expr.relative[ tokens[ j ].type ] ) {
                                                break;
                                            }
                                        }
                                        return setMatcher(
                                            i > 1 && elementMatcher( matchers ),
                                            i > 1 && toSelector(

                                                // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                                                tokens
                                                    .slice( 0, i - 1 )
                                                    .concat( { value: tokens[ i - 2 ].type === " " ? "*" : "" } )
                                            ).replace( rtrim, "$1" ),
                                            matcher,
                                            i < j && matcherFromTokens( tokens.slice( i, j ) ),
                                            j < len && matcherFromTokens( ( tokens = tokens.slice( j ) ) ),
                                            j < len && toSelector( tokens )
                                        );
                                    }
                                    matchers.push( matcher );
                                }
                            }

                            return elementMatcher( matchers );
                        }

                        function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
                            var bySet = setMatchers.length > 0,
                                byElement = elementMatchers.length > 0,
                                superMatcher = function( seed, context, xml, results, outermost ) {
                                    var elem, j, matcher,
                                        matchedCount = 0,
                                        i = "0",
                                        unmatched = seed && [],
                                        setMatched = [],
                                        contextBackup = outermostContext,

                                        // We must always have either seed elements or outermost context
                                        elems = seed || byElement && Expr.find[ "TAG" ]( "*", outermost ),

                                        // Use integer dirruns iff this is the outermost matcher
                                        dirrunsUnique = ( dirruns += contextBackup == null ? 1 : Math.random() || 0.1 ),
                                        len = elems.length;

                                    if ( outermost ) {

                                        // Support: IE 11+, Edge 17 - 18+
                                        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                                        // two documents; shallow comparisons work.
                                        // eslint-disable-next-line eqeqeq
                                        outermostContext = context == document || context || outermost;
                                    }

                                    // Add elements passing elementMatchers directly to results
                                    // Support: IE<9, Safari
                                    // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
                                    for ( ; i !== len && ( elem = elems[ i ] ) != null; i++ ) {
                                        if ( byElement && elem ) {
                                            j = 0;

                                            // Support: IE 11+, Edge 17 - 18+
                                            // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                                            // two documents; shallow comparisons work.
                                            // eslint-disable-next-line eqeqeq
                                            if ( !context && elem.ownerDocument != document ) {
                                                setDocument( elem );
                                                xml = !documentIsHTML;
                                            }
                                            while ( ( matcher = elementMatchers[ j++ ] ) ) {
                                                if ( matcher( elem, context || document, xml ) ) {
                                                    results.push( elem );
                                                    break;
                                                }
                                            }
                                            if ( outermost ) {
                                                dirruns = dirrunsUnique;
                                            }
                                        }

                                        // Track unmatched elements for set filters
                                        if ( bySet ) {

                                            // They will have gone through all possible matchers
                                            if ( ( elem = !matcher && elem ) ) {
                                                matchedCount--;
                                            }

                                            // Lengthen the array for every element, matched or not
                                            if ( seed ) {
                                                unmatched.push( elem );
                                            }
                                        }
                                    }

                                    // `i` is now the count of elements visited above, and adding it to `matchedCount`
                                    // makes the latter nonnegative.
                                    matchedCount += i;

                                    // Apply set filters to unmatched elements
                                    // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
                                    // equals `i`), unless we didn't visit _any_ elements in the above loop because we have
                                    // no element matchers and no seed.
                                    // Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
                                    // case, which will result in a "00" `matchedCount` that differs from `i` but is also
                                    // numerically zero.
                                    if ( bySet && i !== matchedCount ) {
                                        j = 0;
                                        while ( ( matcher = setMatchers[ j++ ] ) ) {
                                            matcher( unmatched, setMatched, context, xml );
                                        }

                                        if ( seed ) {

                                            // Reintegrate element matches to eliminate the need for sorting
                                            if ( matchedCount > 0 ) {
                                                while ( i-- ) {
                                                    if ( !( unmatched[ i ] || setMatched[ i ] ) ) {
                                                        setMatched[ i ] = pop.call( results );
                                                    }
                                                }
                                            }

                                            // Discard index placeholder values to get only actual matches
                                            setMatched = condense( setMatched );
                                        }

                                        // Add matches to results
                                        push.apply( results, setMatched );

                                        // Seedless set matches succeeding multiple successful matchers stipulate sorting
                                        if ( outermost && !seed && setMatched.length > 0 &&
                                            ( matchedCount + setMatchers.length ) > 1 ) {

                                            Sizzle.uniqueSort( results );
                                        }
                                    }

                                    // Override manipulation of globals by nested matchers
                                    if ( outermost ) {
                                        dirruns = dirrunsUnique;
                                        outermostContext = contextBackup;
                                    }

                                    return unmatched;
                                };

                            return bySet ?
                                markFunction( superMatcher ) :
                                superMatcher;
                        }

                        compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
                            var i,
                                setMatchers = [],
                                elementMatchers = [],
                                cached = compilerCache[ selector + " " ];

                            if ( !cached ) {

                                // Generate a function of recursive functions that can be used to check each element
                                if ( !match ) {
                                    match = tokenize( selector );
                                }
                                i = match.length;
                                while ( i-- ) {
                                    cached = matcherFromTokens( match[ i ] );
                                    if ( cached[ expando ] ) {
                                        setMatchers.push( cached );
                                    } else {
                                        elementMatchers.push( cached );
                                    }
                                }

                                // Cache the compiled function
                                cached = compilerCache(
                                    selector,
                                    matcherFromGroupMatchers( elementMatchers, setMatchers )
                                );

                                // Save selector and tokenization
                                cached.selector = selector;
                            }
                            return cached;
                        };

                        /**
                         * A low-level selection function that works with Sizzle's compiled
                         *  selector functions
                         * @param {String|Function} selector A selector or a pre-compiled
                         *  selector function built with Sizzle.compile
                         * @param {Element} context
                         * @param {Array} [results]
                         * @param {Array} [seed] A set of elements to match against
                         */
                        select = Sizzle.select = function( selector, context, results, seed ) {
                            var i, tokens, token, type, find,
                                compiled = typeof selector === "function" && selector,
                                match = !seed && tokenize( ( selector = compiled.selector || selector ) );

                            results = results || [];

                            // Try to minimize operations if there is only one selector in the list and no seed
                            // (the latter of which guarantees us context)
                            if ( match.length === 1 ) {

                                // Reduce context if the leading compound selector is an ID
                                tokens = match[ 0 ] = match[ 0 ].slice( 0 );
                                if ( tokens.length > 2 && ( token = tokens[ 0 ] ).type === "ID" &&
                                    context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[ 1 ].type ] ) {

                                    context = ( Expr.find[ "ID" ]( token.matches[ 0 ]
                                        .replace( runescape, funescape ), context ) || [] )[ 0 ];
                                    if ( !context ) {
                                        return results;

                                        // Precompiled matchers will still verify ancestry, so step up a level
                                    } else if ( compiled ) {
                                        context = context.parentNode;
                                    }

                                    selector = selector.slice( tokens.shift().value.length );
                                }

                                // Fetch a seed set for right-to-left matching
                                i = matchExpr[ "needsContext" ].test( selector ) ? 0 : tokens.length;
                                while ( i-- ) {
                                    token = tokens[ i ];

                                    // Abort if we hit a combinator
                                    if ( Expr.relative[ ( type = token.type ) ] ) {
                                        break;
                                    }
                                    if ( ( find = Expr.find[ type ] ) ) {

                                        // Search, expanding context for leading sibling combinators
                                        if ( ( seed = find(
                                            token.matches[ 0 ].replace( runescape, funescape ),
                                            rsibling.test( tokens[ 0 ].type ) && testContext( context.parentNode ) ||
                                            context
                                        ) ) ) {

                                            // If seed is empty or no tokens remain, we can return early
                                            tokens.splice( i, 1 );
                                            selector = seed.length && toSelector( tokens );
                                            if ( !selector ) {
                                                push.apply( results, seed );
                                                return results;
                                            }

                                            break;
                                        }
                                    }
                                }
                            }

                            // Compile and execute a filtering function if one is not provided
                            // Provide `match` to avoid retokenization if we modified the selector above
                            ( compiled || compile( selector, match ) )(
                                seed,
                                context,
                                !documentIsHTML,
                                results,
                                !context || rsibling.test( selector ) && testContext( context.parentNode ) || context
                            );
                            return results;
                        };

// One-time assignments

// Sort stability
                        support.sortStable = expando.split( "" ).sort( sortOrder ).join( "" ) === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
                        support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
                        setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
                        support.sortDetached = assert( function( el ) {

                            // Should return 1, but returns 4 (following)
                            return el.compareDocumentPosition( document.createElement( "fieldset" ) ) & 1;
                        } );

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
                        if ( !assert( function( el ) {
                            el.innerHTML = "<a href='#'></a>";
                            return el.firstChild.getAttribute( "href" ) === "#";
                        } ) ) {
                            addHandle( "type|href|height|width", function( elem, name, isXML ) {
                                if ( !isXML ) {
                                    return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
                                }
                            } );
                        }

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
                        if ( !support.attributes || !assert( function( el ) {
                            el.innerHTML = "<input/>";
                            el.firstChild.setAttribute( "value", "" );
                            return el.firstChild.getAttribute( "value" ) === "";
                        } ) ) {
                            addHandle( "value", function( elem, _name, isXML ) {
                                if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
                                    return elem.defaultValue;
                                }
                            } );
                        }

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
                        if ( !assert( function( el ) {
                            return el.getAttribute( "disabled" ) == null;
                        } ) ) {
                            addHandle( booleans, function( elem, name, isXML ) {
                                var val;
                                if ( !isXML ) {
                                    return elem[ name ] === true ? name.toLowerCase() :
                                        ( val = elem.getAttributeNode( name ) ) && val.specified ?
                                            val.value :
                                            null;
                                }
                            } );
                        }

                        return Sizzle;

                    } )( window );



                jQuery.find = Sizzle;
                jQuery.expr = Sizzle.selectors;

// Deprecated
                jQuery.expr[ ":" ] = jQuery.expr.pseudos;
                jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
                jQuery.text = Sizzle.getText;
                jQuery.isXMLDoc = Sizzle.isXML;
                jQuery.contains = Sizzle.contains;
                jQuery.escapeSelector = Sizzle.escape;




                var dir = function( elem, dir, until ) {
                    var matched = [],
                        truncate = until !== undefined;

                    while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
                        if ( elem.nodeType === 1 ) {
                            if ( truncate && jQuery( elem ).is( until ) ) {
                                break;
                            }
                            matched.push( elem );
                        }
                    }
                    return matched;
                };


                var siblings = function( n, elem ) {
                    var matched = [];

                    for ( ; n; n = n.nextSibling ) {
                        if ( n.nodeType === 1 && n !== elem ) {
                            matched.push( n );
                        }
                    }

                    return matched;
                };


                var rneedsContext = jQuery.expr.match.needsContext;



                function nodeName( elem, name ) {

                    return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

                };
                var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



// Implement the identical functionality for filter and not
                function winnow( elements, qualifier, not ) {
                    if ( isFunction( qualifier ) ) {
                        return jQuery.grep( elements, function( elem, i ) {
                            return !!qualifier.call( elem, i, elem ) !== not;
                        } );
                    }

                    // Single element
                    if ( qualifier.nodeType ) {
                        return jQuery.grep( elements, function( elem ) {
                            return ( elem === qualifier ) !== not;
                        } );
                    }

                    // Arraylike of elements (jQuery, arguments, Array)
                    if ( typeof qualifier !== "string" ) {
                        return jQuery.grep( elements, function( elem ) {
                            return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
                        } );
                    }

                    // Filtered directly for both simple and complex selectors
                    return jQuery.filter( qualifier, elements, not );
                }

                jQuery.filter = function( expr, elems, not ) {
                    var elem = elems[ 0 ];

                    if ( not ) {
                        expr = ":not(" + expr + ")";
                    }

                    if ( elems.length === 1 && elem.nodeType === 1 ) {
                        return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
                    }

                    return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
                        return elem.nodeType === 1;
                    } ) );
                };

                jQuery.fn.extend( {
                    find: function( selector ) {
                        var i, ret,
                            len = this.length,
                            self = this;

                        if ( typeof selector !== "string" ) {
                            return this.pushStack( jQuery( selector ).filter( function() {
                                for ( i = 0; i < len; i++ ) {
                                    if ( jQuery.contains( self[ i ], this ) ) {
                                        return true;
                                    }
                                }
                            } ) );
                        }

                        ret = this.pushStack( [] );

                        for ( i = 0; i < len; i++ ) {
                            jQuery.find( selector, self[ i ], ret );
                        }

                        return len > 1 ? jQuery.uniqueSort( ret ) : ret;
                    },
                    filter: function( selector ) {
                        return this.pushStack( winnow( this, selector || [], false ) );
                    },
                    not: function( selector ) {
                        return this.pushStack( winnow( this, selector || [], true ) );
                    },
                    is: function( selector ) {
                        return !!winnow(
                            this,

                            // If this is a positional/relative selector, check membership in the returned set
                            // so $("p:first").is("p:last") won't return true for a doc with two "p".
                            typeof selector === "string" && rneedsContext.test( selector ) ?
                                jQuery( selector ) :
                                selector || [],
                            false
                        ).length;
                    }
                } );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
                var rootjQuery,

                    // A simple way to check for HTML strings
                    // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
                    // Strict HTML recognition (#11290: must start with <)
                    // Shortcut simple #id case for speed
                    rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

                    init = jQuery.fn.init = function( selector, context, root ) {
                        var match, elem;

                        // HANDLE: $(""), $(null), $(undefined), $(false)
                        if ( !selector ) {
                            return this;
                        }

                        // Method init() accepts an alternate rootjQuery
                        // so migrate can support jQuery.sub (gh-2101)
                        root = root || rootjQuery;

                        // Handle HTML strings
                        if ( typeof selector === "string" ) {
                            if ( selector[ 0 ] === "<" &&
                                selector[ selector.length - 1 ] === ">" &&
                                selector.length >= 3 ) {

                                // Assume that strings that start and end with <> are HTML and skip the regex check
                                match = [ null, selector, null ];

                            } else {
                                match = rquickExpr.exec( selector );
                            }

                            // Match html or make sure no context is specified for #id
                            if ( match && ( match[ 1 ] || !context ) ) {

                                // HANDLE: $(html) -> $(array)
                                if ( match[ 1 ] ) {
                                    context = context instanceof jQuery ? context[ 0 ] : context;

                                    // Option to run scripts is true for back-compat
                                    // Intentionally let the error be thrown if parseHTML is not present
                                    jQuery.merge( this, jQuery.parseHTML(
                                        match[ 1 ],
                                        context && context.nodeType ? context.ownerDocument || context : document,
                                        true
                                    ) );

                                    // HANDLE: $(html, props)
                                    if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
                                        for ( match in context ) {

                                            // Properties of context are called as methods if possible
                                            if ( isFunction( this[ match ] ) ) {
                                                this[ match ]( context[ match ] );

                                                // ...and otherwise set as attributes
                                            } else {
                                                this.attr( match, context[ match ] );
                                            }
                                        }
                                    }

                                    return this;

                                    // HANDLE: $(#id)
                                } else {
                                    elem = document.getElementById( match[ 2 ] );

                                    if ( elem ) {

                                        // Inject the element directly into the jQuery object
                                        this[ 0 ] = elem;
                                        this.length = 1;
                                    }
                                    return this;
                                }

                                // HANDLE: $(expr, $(...))
                            } else if ( !context || context.jquery ) {
                                return ( context || root ).find( selector );

                                // HANDLE: $(expr, context)
                                // (which is just equivalent to: $(context).find(expr)
                            } else {
                                return this.constructor( context ).find( selector );
                            }

                            // HANDLE: $(DOMElement)
                        } else if ( selector.nodeType ) {
                            this[ 0 ] = selector;
                            this.length = 1;
                            return this;

                            // HANDLE: $(function)
                            // Shortcut for document ready
                        } else if ( isFunction( selector ) ) {
                            return root.ready !== undefined ?
                                root.ready( selector ) :

                                // Execute immediately if ready is not present
                                selector( jQuery );
                        }

                        return jQuery.makeArray( selector, this );
                    };

// Give the init function the jQuery prototype for later instantiation
                init.prototype = jQuery.fn;

// Initialize central reference
                rootjQuery = jQuery( document );


                var rparentsprev = /^(?:parents|prev(?:Until|All))/,

                    // Methods guaranteed to produce a unique set when starting from a unique set
                    guaranteedUnique = {
                        children: true,
                        contents: true,
                        next: true,
                        prev: true
                    };

                jQuery.fn.extend( {
                    has: function( target ) {
                        var targets = jQuery( target, this ),
                            l = targets.length;

                        return this.filter( function() {
                            var i = 0;
                            for ( ; i < l; i++ ) {
                                if ( jQuery.contains( this, targets[ i ] ) ) {
                                    return true;
                                }
                            }
                        } );
                    },

                    closest: function( selectors, context ) {
                        var cur,
                            i = 0,
                            l = this.length,
                            matched = [],
                            targets = typeof selectors !== "string" && jQuery( selectors );

                        // Positional selectors never match, since there's no _selection_ context
                        if ( !rneedsContext.test( selectors ) ) {
                            for ( ; i < l; i++ ) {
                                for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

                                    // Always skip document fragments
                                    if ( cur.nodeType < 11 && ( targets ?
                                        targets.index( cur ) > -1 :

                                        // Don't pass non-elements to Sizzle
                                        cur.nodeType === 1 &&
                                        jQuery.find.matchesSelector( cur, selectors ) ) ) {

                                        matched.push( cur );
                                        break;
                                    }
                                }
                            }
                        }

                        return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
                    },

                    // Determine the position of an element within the set
                    index: function( elem ) {

                        // No argument, return index in parent
                        if ( !elem ) {
                            return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
                        }

                        // Index in selector
                        if ( typeof elem === "string" ) {
                            return indexOf.call( jQuery( elem ), this[ 0 ] );
                        }

                        // Locate the position of the desired element
                        return indexOf.call( this,

                            // If it receives a jQuery object, the first element is used
                            elem.jquery ? elem[ 0 ] : elem
                        );
                    },

                    add: function( selector, context ) {
                        return this.pushStack(
                            jQuery.uniqueSort(
                                jQuery.merge( this.get(), jQuery( selector, context ) )
                            )
                        );
                    },

                    addBack: function( selector ) {
                        return this.add( selector == null ?
                            this.prevObject : this.prevObject.filter( selector )
                        );
                    }
                } );

                function sibling( cur, dir ) {
                    while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
                    return cur;
                }

                jQuery.each( {
                    parent: function( elem ) {
                        var parent = elem.parentNode;
                        return parent && parent.nodeType !== 11 ? parent : null;
                    },
                    parents: function( elem ) {
                        return dir( elem, "parentNode" );
                    },
                    parentsUntil: function( elem, _i, until ) {
                        return dir( elem, "parentNode", until );
                    },
                    next: function( elem ) {
                        return sibling( elem, "nextSibling" );
                    },
                    prev: function( elem ) {
                        return sibling( elem, "previousSibling" );
                    },
                    nextAll: function( elem ) {
                        return dir( elem, "nextSibling" );
                    },
                    prevAll: function( elem ) {
                        return dir( elem, "previousSibling" );
                    },
                    nextUntil: function( elem, _i, until ) {
                        return dir( elem, "nextSibling", until );
                    },
                    prevUntil: function( elem, _i, until ) {
                        return dir( elem, "previousSibling", until );
                    },
                    siblings: function( elem ) {
                        return siblings( ( elem.parentNode || {} ).firstChild, elem );
                    },
                    children: function( elem ) {
                        return siblings( elem.firstChild );
                    },
                    contents: function( elem ) {
                        if ( elem.contentDocument != null &&

                            // Support: IE 11+
                            // <object> elements with no `data` attribute has an object
                            // `contentDocument` with a `null` prototype.
                            getProto( elem.contentDocument ) ) {

                            return elem.contentDocument;
                        }

                        // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
                        // Treat the template element as a regular one in browsers that
                        // don't support it.
                        if ( nodeName( elem, "template" ) ) {
                            elem = elem.content || elem;
                        }

                        return jQuery.merge( [], elem.childNodes );
                    }
                }, function( name, fn ) {
                    jQuery.fn[ name ] = function( until, selector ) {
                        var matched = jQuery.map( this, fn, until );

                        if ( name.slice( -5 ) !== "Until" ) {
                            selector = until;
                        }

                        if ( selector && typeof selector === "string" ) {
                            matched = jQuery.filter( selector, matched );
                        }

                        if ( this.length > 1 ) {

                            // Remove duplicates
                            if ( !guaranteedUnique[ name ] ) {
                                jQuery.uniqueSort( matched );
                            }

                            // Reverse order for parents* and prev-derivatives
                            if ( rparentsprev.test( name ) ) {
                                matched.reverse();
                            }
                        }

                        return this.pushStack( matched );
                    };
                } );
                var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
                function createOptions( options ) {
                    var object = {};
                    jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
                        object[ flag ] = true;
                    } );
                    return object;
                }

                /*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
                jQuery.Callbacks = function( options ) {

                    // Convert options from String-formatted to Object-formatted if needed
                    // (we check in cache first)
                    options = typeof options === "string" ?
                        createOptions( options ) :
                        jQuery.extend( {}, options );

                    var // Flag to know if list is currently firing
                        firing,

                        // Last fire value for non-forgettable lists
                        memory,

                        // Flag to know if list was already fired
                        fired,

                        // Flag to prevent firing
                        locked,

                        // Actual callback list
                        list = [],

                        // Queue of execution data for repeatable lists
                        queue = [],

                        // Index of currently firing callback (modified by add/remove as needed)
                        firingIndex = -1,

                        // Fire callbacks
                        fire = function() {

                            // Enforce single-firing
                            locked = locked || options.once;

                            // Execute callbacks for all pending executions,
                            // respecting firingIndex overrides and runtime changes
                            fired = firing = true;
                            for ( ; queue.length; firingIndex = -1 ) {
                                memory = queue.shift();
                                while ( ++firingIndex < list.length ) {

                                    // Run callback and check for early termination
                                    if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
                                        options.stopOnFalse ) {

                                        // Jump to end and forget the data so .add doesn't re-fire
                                        firingIndex = list.length;
                                        memory = false;
                                    }
                                }
                            }

                            // Forget the data if we're done with it
                            if ( !options.memory ) {
                                memory = false;
                            }

                            firing = false;

                            // Clean up if we're done firing for good
                            if ( locked ) {

                                // Keep an empty list if we have data for future add calls
                                if ( memory ) {
                                    list = [];

                                    // Otherwise, this object is spent
                                } else {
                                    list = "";
                                }
                            }
                        },

                        // Actual Callbacks object
                        self = {

                            // Add a callback or a collection of callbacks to the list
                            add: function() {
                                if ( list ) {

                                    // If we have memory from a past run, we should fire after adding
                                    if ( memory && !firing ) {
                                        firingIndex = list.length - 1;
                                        queue.push( memory );
                                    }

                                    ( function add( args ) {
                                        jQuery.each( args, function( _, arg ) {
                                            if ( isFunction( arg ) ) {
                                                if ( !options.unique || !self.has( arg ) ) {
                                                    list.push( arg );
                                                }
                                            } else if ( arg && arg.length && toType( arg ) !== "string" ) {

                                                // Inspect recursively
                                                add( arg );
                                            }
                                        } );
                                    } )( arguments );

                                    if ( memory && !firing ) {
                                        fire();
                                    }
                                }
                                return this;
                            },

                            // Remove a callback from the list
                            remove: function() {
                                jQuery.each( arguments, function( _, arg ) {
                                    var index;
                                    while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
                                        list.splice( index, 1 );

                                        // Handle firing indexes
                                        if ( index <= firingIndex ) {
                                            firingIndex--;
                                        }
                                    }
                                } );
                                return this;
                            },

                            // Check if a given callback is in the list.
                            // If no argument is given, return whether or not list has callbacks attached.
                            has: function( fn ) {
                                return fn ?
                                    jQuery.inArray( fn, list ) > -1 :
                                    list.length > 0;
                            },

                            // Remove all callbacks from the list
                            empty: function() {
                                if ( list ) {
                                    list = [];
                                }
                                return this;
                            },

                            // Disable .fire and .add
                            // Abort any current/pending executions
                            // Clear all callbacks and values
                            disable: function() {
                                locked = queue = [];
                                list = memory = "";
                                return this;
                            },
                            disabled: function() {
                                return !list;
                            },

                            // Disable .fire
                            // Also disable .add unless we have memory (since it would have no effect)
                            // Abort any pending executions
                            lock: function() {
                                locked = queue = [];
                                if ( !memory && !firing ) {
                                    list = memory = "";
                                }
                                return this;
                            },
                            locked: function() {
                                return !!locked;
                            },

                            // Call all callbacks with the given context and arguments
                            fireWith: function( context, args ) {
                                if ( !locked ) {
                                    args = args || [];
                                    args = [ context, args.slice ? args.slice() : args ];
                                    queue.push( args );
                                    if ( !firing ) {
                                        fire();
                                    }
                                }
                                return this;
                            },

                            // Call all the callbacks with the given arguments
                            fire: function() {
                                self.fireWith( this, arguments );
                                return this;
                            },

                            // To know if the callbacks have already been called at least once
                            fired: function() {
                                return !!fired;
                            }
                        };

                    return self;
                };


                function Identity( v ) {
                    return v;
                }
                function Thrower( ex ) {
                    throw ex;
                }

                function adoptValue( value, resolve, reject, noValue ) {
                    var method;

                    try {

                        // Check for promise aspect first to privilege synchronous behavior
                        if ( value && isFunction( ( method = value.promise ) ) ) {
                            method.call( value ).done( resolve ).fail( reject );

                            // Other thenables
                        } else if ( value && isFunction( ( method = value.then ) ) ) {
                            method.call( value, resolve, reject );

                            // Other non-thenables
                        } else {

                            // Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
                            // * false: [ value ].slice( 0 ) => resolve( value )
                            // * true: [ value ].slice( 1 ) => resolve()
                            resolve.apply( undefined, [ value ].slice( noValue ) );
                        }

                        // For Promises/A+, convert exceptions into rejections
                        // Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
                        // Deferred#then to conditionally suppress rejection.
                    } catch ( value ) {

                        // Support: Android 4.0 only
                        // Strict mode functions invoked without .call/.apply get global-object context
                        reject.apply( undefined, [ value ] );
                    }
                }

                jQuery.extend( {

                    Deferred: function( func ) {
                        var tuples = [

                                // action, add listener, callbacks,
                                // ... .then handlers, argument index, [final state]
                                [ "notify", "progress", jQuery.Callbacks( "memory" ),
                                    jQuery.Callbacks( "memory" ), 2 ],
                                [ "resolve", "done", jQuery.Callbacks( "once memory" ),
                                    jQuery.Callbacks( "once memory" ), 0, "resolved" ],
                                [ "reject", "fail", jQuery.Callbacks( "once memory" ),
                                    jQuery.Callbacks( "once memory" ), 1, "rejected" ]
                            ],
                            state = "pending",
                            promise = {
                                state: function() {
                                    return state;
                                },
                                always: function() {
                                    deferred.done( arguments ).fail( arguments );
                                    return this;
                                },
                                "catch": function( fn ) {
                                    return promise.then( null, fn );
                                },

                                // Keep pipe for back-compat
                                pipe: function( /* fnDone, fnFail, fnProgress */ ) {
                                    var fns = arguments;

                                    return jQuery.Deferred( function( newDefer ) {
                                        jQuery.each( tuples, function( _i, tuple ) {

                                            // Map tuples (progress, done, fail) to arguments (done, fail, progress)
                                            var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

                                            // deferred.progress(function() { bind to newDefer or newDefer.notify })
                                            // deferred.done(function() { bind to newDefer or newDefer.resolve })
                                            // deferred.fail(function() { bind to newDefer or newDefer.reject })
                                            deferred[ tuple[ 1 ] ]( function() {
                                                var returned = fn && fn.apply( this, arguments );
                                                if ( returned && isFunction( returned.promise ) ) {
                                                    returned.promise()
                                                        .progress( newDefer.notify )
                                                        .done( newDefer.resolve )
                                                        .fail( newDefer.reject );
                                                } else {
                                                    newDefer[ tuple[ 0 ] + "With" ](
                                                        this,
                                                        fn ? [ returned ] : arguments
                                                    );
                                                }
                                            } );
                                        } );
                                        fns = null;
                                    } ).promise();
                                },
                                then: function( onFulfilled, onRejected, onProgress ) {
                                    var maxDepth = 0;
                                    function resolve( depth, deferred, handler, special ) {
                                        return function() {
                                            var that = this,
                                                args = arguments,
                                                mightThrow = function() {
                                                    var returned, then;

                                                    // Support: Promises/A+ section 2.3.3.3.3
                                                    // https://promisesaplus.com/#point-59
                                                    // Ignore double-resolution attempts
                                                    if ( depth < maxDepth ) {
                                                        return;
                                                    }

                                                    returned = handler.apply( that, args );

                                                    // Support: Promises/A+ section 2.3.1
                                                    // https://promisesaplus.com/#point-48
                                                    if ( returned === deferred.promise() ) {
                                                        throw new TypeError( "Thenable self-resolution" );
                                                    }

                                                    // Support: Promises/A+ sections 2.3.3.1, 3.5
                                                    // https://promisesaplus.com/#point-54
                                                    // https://promisesaplus.com/#point-75
                                                    // Retrieve `then` only once
                                                    then = returned &&

                                                        // Support: Promises/A+ section 2.3.4
                                                        // https://promisesaplus.com/#point-64
                                                        // Only check objects and functions for thenability
                                                        ( typeof returned === "object" ||
                                                            typeof returned === "function" ) &&
                                                        returned.then;

                                                    // Handle a returned thenable
                                                    if ( isFunction( then ) ) {

                                                        // Special processors (notify) just wait for resolution
                                                        if ( special ) {
                                                            then.call(
                                                                returned,
                                                                resolve( maxDepth, deferred, Identity, special ),
                                                                resolve( maxDepth, deferred, Thrower, special )
                                                            );

                                                            // Normal processors (resolve) also hook into progress
                                                        } else {

                                                            // ...and disregard older resolution values
                                                            maxDepth++;

                                                            then.call(
                                                                returned,
                                                                resolve( maxDepth, deferred, Identity, special ),
                                                                resolve( maxDepth, deferred, Thrower, special ),
                                                                resolve( maxDepth, deferred, Identity,
                                                                    deferred.notifyWith )
                                                            );
                                                        }

                                                        // Handle all other returned values
                                                    } else {

                                                        // Only substitute handlers pass on context
                                                        // and multiple values (non-spec behavior)
                                                        if ( handler !== Identity ) {
                                                            that = undefined;
                                                            args = [ returned ];
                                                        }

                                                        // Process the value(s)
                                                        // Default process is resolve
                                                        ( special || deferred.resolveWith )( that, args );
                                                    }
                                                },

                                                // Only normal processors (resolve) catch and reject exceptions
                                                process = special ?
                                                    mightThrow :
                                                    function() {
                                                        try {
                                                            mightThrow();
                                                        } catch ( e ) {

                                                            if ( jQuery.Deferred.exceptionHook ) {
                                                                jQuery.Deferred.exceptionHook( e,
                                                                    process.stackTrace );
                                                            }

                                                            // Support: Promises/A+ section 2.3.3.3.4.1
                                                            // https://promisesaplus.com/#point-61
                                                            // Ignore post-resolution exceptions
                                                            if ( depth + 1 >= maxDepth ) {

                                                                // Only substitute handlers pass on context
                                                                // and multiple values (non-spec behavior)
                                                                if ( handler !== Thrower ) {
                                                                    that = undefined;
                                                                    args = [ e ];
                                                                }

                                                                deferred.rejectWith( that, args );
                                                            }
                                                        }
                                                    };

                                            // Support: Promises/A+ section 2.3.3.3.1
                                            // https://promisesaplus.com/#point-57
                                            // Re-resolve promises immediately to dodge false rejection from
                                            // subsequent errors
                                            if ( depth ) {
                                                process();
                                            } else {

                                                // Call an optional hook to record the stack, in case of exception
                                                // since it's otherwise lost when execution goes async
                                                if ( jQuery.Deferred.getStackHook ) {
                                                    process.stackTrace = jQuery.Deferred.getStackHook();
                                                }
                                                window.setTimeout( process );
                                            }
                                        };
                                    }

                                    return jQuery.Deferred( function( newDefer ) {

                                        // progress_handlers.add( ... )
                                        tuples[ 0 ][ 3 ].add(
                                            resolve(
                                                0,
                                                newDefer,
                                                isFunction( onProgress ) ?
                                                    onProgress :
                                                    Identity,
                                                newDefer.notifyWith
                                            )
                                        );

                                        // fulfilled_handlers.add( ... )
                                        tuples[ 1 ][ 3 ].add(
                                            resolve(
                                                0,
                                                newDefer,
                                                isFunction( onFulfilled ) ?
                                                    onFulfilled :
                                                    Identity
                                            )
                                        );

                                        // rejected_handlers.add( ... )
                                        tuples[ 2 ][ 3 ].add(
                                            resolve(
                                                0,
                                                newDefer,
                                                isFunction( onRejected ) ?
                                                    onRejected :
                                                    Thrower
                                            )
                                        );
                                    } ).promise();
                                },

                                // Get a promise for this deferred
                                // If obj is provided, the promise aspect is added to the object
                                promise: function( obj ) {
                                    return obj != null ? jQuery.extend( obj, promise ) : promise;
                                }
                            },
                            deferred = {};

                        // Add list-specific methods
                        jQuery.each( tuples, function( i, tuple ) {
                            var list = tuple[ 2 ],
                                stateString = tuple[ 5 ];

                            // promise.progress = list.add
                            // promise.done = list.add
                            // promise.fail = list.add
                            promise[ tuple[ 1 ] ] = list.add;

                            // Handle state
                            if ( stateString ) {
                                list.add(
                                    function() {

                                        // state = "resolved" (i.e., fulfilled)
                                        // state = "rejected"
                                        state = stateString;
                                    },

                                    // rejected_callbacks.disable
                                    // fulfilled_callbacks.disable
                                    tuples[ 3 - i ][ 2 ].disable,

                                    // rejected_handlers.disable
                                    // fulfilled_handlers.disable
                                    tuples[ 3 - i ][ 3 ].disable,

                                    // progress_callbacks.lock
                                    tuples[ 0 ][ 2 ].lock,

                                    // progress_handlers.lock
                                    tuples[ 0 ][ 3 ].lock
                                );
                            }

                            // progress_handlers.fire
                            // fulfilled_handlers.fire
                            // rejected_handlers.fire
                            list.add( tuple[ 3 ].fire );

                            // deferred.notify = function() { deferred.notifyWith(...) }
                            // deferred.resolve = function() { deferred.resolveWith(...) }
                            // deferred.reject = function() { deferred.rejectWith(...) }
                            deferred[ tuple[ 0 ] ] = function() {
                                deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
                                return this;
                            };

                            // deferred.notifyWith = list.fireWith
                            // deferred.resolveWith = list.fireWith
                            // deferred.rejectWith = list.fireWith
                            deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
                        } );

                        // Make the deferred a promise
                        promise.promise( deferred );

                        // Call given func if any
                        if ( func ) {
                            func.call( deferred, deferred );
                        }

                        // All done!
                        return deferred;
                    },

                    // Deferred helper
                    when: function( singleValue ) {
                        var

                            // count of uncompleted subordinates
                            remaining = arguments.length,

                            // count of unprocessed arguments
                            i = remaining,

                            // subordinate fulfillment data
                            resolveContexts = Array( i ),
                            resolveValues = slice.call( arguments ),

                            // the master Deferred
                            master = jQuery.Deferred(),

                            // subordinate callback factory
                            updateFunc = function( i ) {
                                return function( value ) {
                                    resolveContexts[ i ] = this;
                                    resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
                                    if ( !( --remaining ) ) {
                                        master.resolveWith( resolveContexts, resolveValues );
                                    }
                                };
                            };

                        // Single- and empty arguments are adopted like Promise.resolve
                        if ( remaining <= 1 ) {
                            adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
                                !remaining );

                            // Use .then() to unwrap secondary thenables (cf. gh-3000)
                            if ( master.state() === "pending" ||
                                isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

                                return master.then();
                            }
                        }

                        // Multiple arguments are aggregated like Promise.all array elements
                        while ( i-- ) {
                            adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
                        }

                        return master.promise();
                    }
                } );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
                var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

                jQuery.Deferred.exceptionHook = function( error, stack ) {

                    // Support: IE 8 - 9 only
                    // Console exists when dev tools are open, which can happen at any time
                    if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
                        window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
                    }
                };




                jQuery.readyException = function( error ) {
                    window.setTimeout( function() {
                        throw error;
                    } );
                };




// The deferred used on DOM ready
                var readyList = jQuery.Deferred();

                jQuery.fn.ready = function( fn ) {

                    readyList
                        .then( fn )

                        // Wrap jQuery.readyException in a function so that the lookup
                        // happens at the time of error handling instead of callback
                        // registration.
                        .catch( function( error ) {
                            jQuery.readyException( error );
                        } );

                    return this;
                };

                jQuery.extend( {

                    // Is the DOM ready to be used? Set to true once it occurs.
                    isReady: false,

                    // A counter to track how many items to wait for before
                    // the ready event fires. See #6781
                    readyWait: 1,

                    // Handle when the DOM is ready
                    ready: function( wait ) {

                        // Abort if there are pending holds or we're already ready
                        if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
                            return;
                        }

                        // Remember that the DOM is ready
                        jQuery.isReady = true;

                        // If a normal DOM Ready event fired, decrement, and wait if need be
                        if ( wait !== true && --jQuery.readyWait > 0 ) {
                            return;
                        }

                        // If there are functions bound, to execute
                        readyList.resolveWith( document, [ jQuery ] );
                    }
                } );

                jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
                function completed() {
                    document.removeEventListener( "DOMContentLoaded", completed );
                    window.removeEventListener( "load", completed );
                    jQuery.ready();
                }

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
                if ( document.readyState === "complete" ||
                    ( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

                    // Handle it asynchronously to allow scripts the opportunity to delay ready
                    window.setTimeout( jQuery.ready );

                } else {

                    // Use the handy event callback
                    document.addEventListener( "DOMContentLoaded", completed );

                    // A fallback to window.onload, that will always work
                    window.addEventListener( "load", completed );
                }




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
                var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
                    var i = 0,
                        len = elems.length,
                        bulk = key == null;

                    // Sets many values
                    if ( toType( key ) === "object" ) {
                        chainable = true;
                        for ( i in key ) {
                            access( elems, fn, i, key[ i ], true, emptyGet, raw );
                        }

                        // Sets one value
                    } else if ( value !== undefined ) {
                        chainable = true;

                        if ( !isFunction( value ) ) {
                            raw = true;
                        }

                        if ( bulk ) {

                            // Bulk operations run against the entire set
                            if ( raw ) {
                                fn.call( elems, value );
                                fn = null;

                                // ...except when executing function values
                            } else {
                                bulk = fn;
                                fn = function( elem, _key, value ) {
                                    return bulk.call( jQuery( elem ), value );
                                };
                            }
                        }

                        if ( fn ) {
                            for ( ; i < len; i++ ) {
                                fn(
                                    elems[ i ], key, raw ?
                                        value :
                                        value.call( elems[ i ], i, fn( elems[ i ], key ) )
                                );
                            }
                        }
                    }

                    if ( chainable ) {
                        return elems;
                    }

                    // Gets
                    if ( bulk ) {
                        return fn.call( elems );
                    }

                    return len ? fn( elems[ 0 ], key ) : emptyGet;
                };


// Matches dashed string for camelizing
                var rmsPrefix = /^-ms-/,
                    rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
                function fcamelCase( _all, letter ) {
                    return letter.toUpperCase();
                }

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (#9572)
                function camelCase( string ) {
                    return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
                }
                var acceptData = function( owner ) {

                    // Accepts only:
                    //  - Node
                    //    - Node.ELEMENT_NODE
                    //    - Node.DOCUMENT_NODE
                    //  - Object
                    //    - Any
                    return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
                };




                function Data() {
                    this.expando = jQuery.expando + Data.uid++;
                }

                Data.uid = 1;

                Data.prototype = {

                    cache: function( owner ) {

                        // Check if the owner object already has a cache
                        var value = owner[ this.expando ];

                        // If not, create one
                        if ( !value ) {
                            value = {};

                            // We can accept data for non-element nodes in modern browsers,
                            // but we should not, see #8335.
                            // Always return an empty object.
                            if ( acceptData( owner ) ) {

                                // If it is a node unlikely to be stringify-ed or looped over
                                // use plain assignment
                                if ( owner.nodeType ) {
                                    owner[ this.expando ] = value;

                                    // Otherwise secure it in a non-enumerable property
                                    // configurable must be true to allow the property to be
                                    // deleted when data is removed
                                } else {
                                    Object.defineProperty( owner, this.expando, {
                                        value: value,
                                        configurable: true
                                    } );
                                }
                            }
                        }

                        return value;
                    },
                    set: function( owner, data, value ) {
                        var prop,
                            cache = this.cache( owner );

                        // Handle: [ owner, key, value ] args
                        // Always use camelCase key (gh-2257)
                        if ( typeof data === "string" ) {
                            cache[ camelCase( data ) ] = value;

                            // Handle: [ owner, { properties } ] args
                        } else {

                            // Copy the properties one-by-one to the cache object
                            for ( prop in data ) {
                                cache[ camelCase( prop ) ] = data[ prop ];
                            }
                        }
                        return cache;
                    },
                    get: function( owner, key ) {
                        return key === undefined ?
                            this.cache( owner ) :

                            // Always use camelCase key (gh-2257)
                            owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
                    },
                    access: function( owner, key, value ) {

                        // In cases where either:
                        //
                        //   1. No key was specified
                        //   2. A string key was specified, but no value provided
                        //
                        // Take the "read" path and allow the get method to determine
                        // which value to return, respectively either:
                        //
                        //   1. The entire cache object
                        //   2. The data stored at the key
                        //
                        if ( key === undefined ||
                            ( ( key && typeof key === "string" ) && value === undefined ) ) {

                            return this.get( owner, key );
                        }

                        // When the key is not a string, or both a key and value
                        // are specified, set or extend (existing objects) with either:
                        //
                        //   1. An object of properties
                        //   2. A key and value
                        //
                        this.set( owner, key, value );

                        // Since the "set" path can have two possible entry points
                        // return the expected data based on which path was taken[*]
                        return value !== undefined ? value : key;
                    },
                    remove: function( owner, key ) {
                        var i,
                            cache = owner[ this.expando ];

                        if ( cache === undefined ) {
                            return;
                        }

                        if ( key !== undefined ) {

                            // Support array or space separated string of keys
                            if ( Array.isArray( key ) ) {

                                // If key is an array of keys...
                                // We always set camelCase keys, so remove that.
                                key = key.map( camelCase );
                            } else {
                                key = camelCase( key );

                                // If a key with the spaces exists, use it.
                                // Otherwise, create an array by matching non-whitespace
                                key = key in cache ?
                                    [ key ] :
                                    ( key.match( rnothtmlwhite ) || [] );
                            }

                            i = key.length;

                            while ( i-- ) {
                                delete cache[ key[ i ] ];
                            }
                        }

                        // Remove the expando if there's no more data
                        if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

                            // Support: Chrome <=35 - 45
                            // Webkit & Blink performance suffers when deleting properties
                            // from DOM nodes, so set to undefined instead
                            // https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
                            if ( owner.nodeType ) {
                                owner[ this.expando ] = undefined;
                            } else {
                                delete owner[ this.expando ];
                            }
                        }
                    },
                    hasData: function( owner ) {
                        var cache = owner[ this.expando ];
                        return cache !== undefined && !jQuery.isEmptyObject( cache );
                    }
                };
                var dataPriv = new Data();

                var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

                var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
                    rmultiDash = /[A-Z]/g;

                function getData( data ) {
                    if ( data === "true" ) {
                        return true;
                    }

                    if ( data === "false" ) {
                        return false;
                    }

                    if ( data === "null" ) {
                        return null;
                    }

                    // Only convert to a number if it doesn't change the string
                    if ( data === +data + "" ) {
                        return +data;
                    }

                    if ( rbrace.test( data ) ) {
                        return JSON.parse( data );
                    }

                    return data;
                }

                function dataAttr( elem, key, data ) {
                    var name;

                    // If nothing was found internally, try to fetch any
                    // data from the HTML5 data-* attribute
                    if ( data === undefined && elem.nodeType === 1 ) {
                        name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
                        data = elem.getAttribute( name );

                        if ( typeof data === "string" ) {
                            try {
                                data = getData( data );
                            } catch ( e ) {}

                            // Make sure we set the data so it isn't changed later
                            dataUser.set( elem, key, data );
                        } else {
                            data = undefined;
                        }
                    }
                    return data;
                }

                jQuery.extend( {
                    hasData: function( elem ) {
                        return dataUser.hasData( elem ) || dataPriv.hasData( elem );
                    },

                    data: function( elem, name, data ) {
                        return dataUser.access( elem, name, data );
                    },

                    removeData: function( elem, name ) {
                        dataUser.remove( elem, name );
                    },

                    // TODO: Now that all calls to _data and _removeData have been replaced
                    // with direct calls to dataPriv methods, these can be deprecated.
                    _data: function( elem, name, data ) {
                        return dataPriv.access( elem, name, data );
                    },

                    _removeData: function( elem, name ) {
                        dataPriv.remove( elem, name );
                    }
                } );

                jQuery.fn.extend( {
                    data: function( key, value ) {
                        var i, name, data,
                            elem = this[ 0 ],
                            attrs = elem && elem.attributes;

                        // Gets all values
                        if ( key === undefined ) {
                            if ( this.length ) {
                                data = dataUser.get( elem );

                                if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
                                    i = attrs.length;
                                    while ( i-- ) {

                                        // Support: IE 11 only
                                        // The attrs elements can be null (#14894)
                                        if ( attrs[ i ] ) {
                                            name = attrs[ i ].name;
                                            if ( name.indexOf( "data-" ) === 0 ) {
                                                name = camelCase( name.slice( 5 ) );
                                                dataAttr( elem, name, data[ name ] );
                                            }
                                        }
                                    }
                                    dataPriv.set( elem, "hasDataAttrs", true );
                                }
                            }

                            return data;
                        }

                        // Sets multiple values
                        if ( typeof key === "object" ) {
                            return this.each( function() {
                                dataUser.set( this, key );
                            } );
                        }

                        return access( this, function( value ) {
                            var data;

                            // The calling jQuery object (element matches) is not empty
                            // (and therefore has an element appears at this[ 0 ]) and the
                            // `value` parameter was not undefined. An empty jQuery object
                            // will result in `undefined` for elem = this[ 0 ] which will
                            // throw an exception if an attempt to read a data cache is made.
                            if ( elem && value === undefined ) {

                                // Attempt to get data from the cache
                                // The key will always be camelCased in Data
                                data = dataUser.get( elem, key );
                                if ( data !== undefined ) {
                                    return data;
                                }

                                // Attempt to "discover" the data in
                                // HTML5 custom data-* attrs
                                data = dataAttr( elem, key );
                                if ( data !== undefined ) {
                                    return data;
                                }

                                // We tried really hard, but the data doesn't exist.
                                return;
                            }

                            // Set the data...
                            this.each( function() {

                                // We always store the camelCased key
                                dataUser.set( this, key, value );
                            } );
                        }, null, value, arguments.length > 1, null, true );
                    },

                    removeData: function( key ) {
                        return this.each( function() {
                            dataUser.remove( this, key );
                        } );
                    }
                } );


                jQuery.extend( {
                    queue: function( elem, type, data ) {
                        var queue;

                        if ( elem ) {
                            type = ( type || "fx" ) + "queue";
                            queue = dataPriv.get( elem, type );

                            // Speed up dequeue by getting out quickly if this is just a lookup
                            if ( data ) {
                                if ( !queue || Array.isArray( data ) ) {
                                    queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
                                } else {
                                    queue.push( data );
                                }
                            }
                            return queue || [];
                        }
                    },

                    dequeue: function( elem, type ) {
                        type = type || "fx";

                        var queue = jQuery.queue( elem, type ),
                            startLength = queue.length,
                            fn = queue.shift(),
                            hooks = jQuery._queueHooks( elem, type ),
                            next = function() {
                                jQuery.dequeue( elem, type );
                            };

                        // If the fx queue is dequeued, always remove the progress sentinel
                        if ( fn === "inprogress" ) {
                            fn = queue.shift();
                            startLength--;
                        }

                        if ( fn ) {

                            // Add a progress sentinel to prevent the fx queue from being
                            // automatically dequeued
                            if ( type === "fx" ) {
                                queue.unshift( "inprogress" );
                            }

                            // Clear up the last queue stop function
                            delete hooks.stop;
                            fn.call( elem, next, hooks );
                        }

                        if ( !startLength && hooks ) {
                            hooks.empty.fire();
                        }
                    },

                    // Not public - generate a queueHooks object, or return the current one
                    _queueHooks: function( elem, type ) {
                        var key = type + "queueHooks";
                        return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
                            empty: jQuery.Callbacks( "once memory" ).add( function() {
                                dataPriv.remove( elem, [ type + "queue", key ] );
                            } )
                        } );
                    }
                } );

                jQuery.fn.extend( {
                    queue: function( type, data ) {
                        var setter = 2;

                        if ( typeof type !== "string" ) {
                            data = type;
                            type = "fx";
                            setter--;
                        }

                        if ( arguments.length < setter ) {
                            return jQuery.queue( this[ 0 ], type );
                        }

                        return data === undefined ?
                            this :
                            this.each( function() {
                                var queue = jQuery.queue( this, type, data );

                                // Ensure a hooks for this queue
                                jQuery._queueHooks( this, type );

                                if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
                                    jQuery.dequeue( this, type );
                                }
                            } );
                    },
                    dequeue: function( type ) {
                        return this.each( function() {
                            jQuery.dequeue( this, type );
                        } );
                    },
                    clearQueue: function( type ) {
                        return this.queue( type || "fx", [] );
                    },

                    // Get a promise resolved when queues of a certain type
                    // are emptied (fx is the type by default)
                    promise: function( type, obj ) {
                        var tmp,
                            count = 1,
                            defer = jQuery.Deferred(),
                            elements = this,
                            i = this.length,
                            resolve = function() {
                                if ( !( --count ) ) {
                                    defer.resolveWith( elements, [ elements ] );
                                }
                            };

                        if ( typeof type !== "string" ) {
                            obj = type;
                            type = undefined;
                        }
                        type = type || "fx";

                        while ( i-- ) {
                            tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
                            if ( tmp && tmp.empty ) {
                                count++;
                                tmp.empty.add( resolve );
                            }
                        }
                        resolve();
                        return defer.promise( obj );
                    }
                } );
                var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

                var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


                var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

                var documentElement = document.documentElement;



                var isAttached = function( elem ) {
                        return jQuery.contains( elem.ownerDocument, elem );
                    },
                    composed = { composed: true };

                // Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
                // Check attachment across shadow DOM boundaries when possible (gh-3504)
                // Support: iOS 10.0-10.2 only
                // Early iOS 10 versions support `attachShadow` but not `getRootNode`,
                // leading to errors. We need to check for `getRootNode`.
                if ( documentElement.getRootNode ) {
                    isAttached = function( elem ) {
                        return jQuery.contains( elem.ownerDocument, elem ) ||
                            elem.getRootNode( composed ) === elem.ownerDocument;
                    };
                }
                var isHiddenWithinTree = function( elem, el ) {

                    // isHiddenWithinTree might be called from jQuery#filter function;
                    // in that case, element will be second argument
                    elem = el || elem;

                    // Inline style trumps all
                    return elem.style.display === "none" ||
                        elem.style.display === "" &&

                        // Otherwise, check computed style
                        // Support: Firefox <=43 - 45
                        // Disconnected elements can have computed display: none, so first confirm that elem is
                        // in the document.
                        isAttached( elem ) &&

                        jQuery.css( elem, "display" ) === "none";
                };



                function adjustCSS( elem, prop, valueParts, tween ) {
                    var adjusted, scale,
                        maxIterations = 20,
                        currentValue = tween ?
                            function() {
                                return tween.cur();
                            } :
                            function() {
                                return jQuery.css( elem, prop, "" );
                            },
                        initial = currentValue(),
                        unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

                        // Starting value computation is required for potential unit mismatches
                        initialInUnit = elem.nodeType &&
                            ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
                            rcssNum.exec( jQuery.css( elem, prop ) );

                    if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

                        // Support: Firefox <=54
                        // Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
                        initial = initial / 2;

                        // Trust units reported by jQuery.css
                        unit = unit || initialInUnit[ 3 ];

                        // Iteratively approximate from a nonzero starting point
                        initialInUnit = +initial || 1;

                        while ( maxIterations-- ) {

                            // Evaluate and update our best guess (doubling guesses that zero out).
                            // Finish if the scale equals or crosses 1 (making the old*new product non-positive).
                            jQuery.style( elem, prop, initialInUnit + unit );
                            if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
                                maxIterations = 0;
                            }
                            initialInUnit = initialInUnit / scale;

                        }

                        initialInUnit = initialInUnit * 2;
                        jQuery.style( elem, prop, initialInUnit + unit );

                        // Make sure we update the tween properties later on
                        valueParts = valueParts || [];
                    }

                    if ( valueParts ) {
                        initialInUnit = +initialInUnit || +initial || 0;

                        // Apply relative offset (+=/-=) if specified
                        adjusted = valueParts[ 1 ] ?
                            initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
                            +valueParts[ 2 ];
                        if ( tween ) {
                            tween.unit = unit;
                            tween.start = initialInUnit;
                            tween.end = adjusted;
                        }
                    }
                    return adjusted;
                }


                var defaultDisplayMap = {};

                function getDefaultDisplay( elem ) {
                    var temp,
                        doc = elem.ownerDocument,
                        nodeName = elem.nodeName,
                        display = defaultDisplayMap[ nodeName ];

                    if ( display ) {
                        return display;
                    }

                    temp = doc.body.appendChild( doc.createElement( nodeName ) );
                    display = jQuery.css( temp, "display" );

                    temp.parentNode.removeChild( temp );

                    if ( display === "none" ) {
                        display = "block";
                    }
                    defaultDisplayMap[ nodeName ] = display;

                    return display;
                }

                function showHide( elements, show ) {
                    var display, elem,
                        values = [],
                        index = 0,
                        length = elements.length;

                    // Determine new display value for elements that need to change
                    for ( ; index < length; index++ ) {
                        elem = elements[ index ];
                        if ( !elem.style ) {
                            continue;
                        }

                        display = elem.style.display;
                        if ( show ) {

                            // Since we force visibility upon cascade-hidden elements, an immediate (and slow)
                            // check is required in this first loop unless we have a nonempty display value (either
                            // inline or about-to-be-restored)
                            if ( display === "none" ) {
                                values[ index ] = dataPriv.get( elem, "display" ) || null;
                                if ( !values[ index ] ) {
                                    elem.style.display = "";
                                }
                            }
                            if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
                                values[ index ] = getDefaultDisplay( elem );
                            }
                        } else {
                            if ( display !== "none" ) {
                                values[ index ] = "none";

                                // Remember what we're overwriting
                                dataPriv.set( elem, "display", display );
                            }
                        }
                    }

                    // Set the display of the elements in a second loop to avoid constant reflow
                    for ( index = 0; index < length; index++ ) {
                        if ( values[ index ] != null ) {
                            elements[ index ].style.display = values[ index ];
                        }
                    }

                    return elements;
                }

                jQuery.fn.extend( {
                    show: function() {
                        return showHide( this, true );
                    },
                    hide: function() {
                        return showHide( this );
                    },
                    toggle: function( state ) {
                        if ( typeof state === "boolean" ) {
                            return state ? this.show() : this.hide();
                        }

                        return this.each( function() {
                            if ( isHiddenWithinTree( this ) ) {
                                jQuery( this ).show();
                            } else {
                                jQuery( this ).hide();
                            }
                        } );
                    }
                } );
                var rcheckableType = ( /^(?:checkbox|radio)$/i );

                var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]*)/i );

                var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



                ( function() {
                    var fragment = document.createDocumentFragment(),
                        div = fragment.appendChild( document.createElement( "div" ) ),
                        input = document.createElement( "input" );

                    // Support: Android 4.0 - 4.3 only
                    // Check state lost if the name is set (#11217)
                    // Support: Windows Web Apps (WWA)
                    // `name` and `type` must use .setAttribute for WWA (#14901)
                    input.setAttribute( "type", "radio" );
                    input.setAttribute( "checked", "checked" );
                    input.setAttribute( "name", "t" );

                    div.appendChild( input );

                    // Support: Android <=4.1 only
                    // Older WebKit doesn't clone checked state correctly in fragments
                    support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

                    // Support: IE <=11 only
                    // Make sure textarea (and checkbox) defaultValue is properly cloned
                    div.innerHTML = "<textarea>x</textarea>";
                    support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;

                    // Support: IE <=9 only
                    // IE <=9 replaces <option> tags with their contents when inserted outside of
                    // the select element.
                    div.innerHTML = "<option></option>";
                    support.option = !!div.lastChild;
                } )();


// We have to close these tags to support XHTML (#13200)
                var wrapMap = {

                    // XHTML parsers do not magically insert elements in the
                    // same way that tag soup parsers do. So we cannot shorten
                    // this by omitting <tbody> or other required elements.
                    thead: [ 1, "<table>", "</table>" ],
                    col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
                    tr: [ 2, "<table><tbody>", "</tbody></table>" ],
                    td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

                    _default: [ 0, "", "" ]
                };

                wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
                wrapMap.th = wrapMap.td;

// Support: IE <=9 only
                if ( !support.option ) {
                    wrapMap.optgroup = wrapMap.option = [ 1, "<select multiple='multiple'>", "</select>" ];
                }


                function getAll( context, tag ) {

                    // Support: IE <=9 - 11 only
                    // Use typeof to avoid zero-argument method invocation on host objects (#15151)
                    var ret;

                    if ( typeof context.getElementsByTagName !== "undefined" ) {
                        ret = context.getElementsByTagName( tag || "*" );

                    } else if ( typeof context.querySelectorAll !== "undefined" ) {
                        ret = context.querySelectorAll( tag || "*" );

                    } else {
                        ret = [];
                    }

                    if ( tag === undefined || tag && nodeName( context, tag ) ) {
                        return jQuery.merge( [ context ], ret );
                    }

                    return ret;
                }


// Mark scripts as having already been evaluated
                function setGlobalEval( elems, refElements ) {
                    var i = 0,
                        l = elems.length;

                    for ( ; i < l; i++ ) {
                        dataPriv.set(
                            elems[ i ],
                            "globalEval",
                            !refElements || dataPriv.get( refElements[ i ], "globalEval" )
                        );
                    }
                }


                var rhtml = /<|&#?\w+;/;

                function buildFragment( elems, context, scripts, selection, ignored ) {
                    var elem, tmp, tag, wrap, attached, j,
                        fragment = context.createDocumentFragment(),
                        nodes = [],
                        i = 0,
                        l = elems.length;

                    for ( ; i < l; i++ ) {
                        elem = elems[ i ];

                        if ( elem || elem === 0 ) {

                            // Add nodes directly
                            if ( toType( elem ) === "object" ) {

                                // Support: Android <=4.0 only, PhantomJS 1 only
                                // push.apply(_, arraylike) throws on ancient WebKit
                                jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

                                // Convert non-html into a text node
                            } else if ( !rhtml.test( elem ) ) {
                                nodes.push( context.createTextNode( elem ) );

                                // Convert html into DOM nodes
                            } else {
                                tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

                                // Deserialize a standard representation
                                tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
                                wrap = wrapMap[ tag ] || wrapMap._default;
                                tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

                                // Descend through wrappers to the right content
                                j = wrap[ 0 ];
                                while ( j-- ) {
                                    tmp = tmp.lastChild;
                                }

                                // Support: Android <=4.0 only, PhantomJS 1 only
                                // push.apply(_, arraylike) throws on ancient WebKit
                                jQuery.merge( nodes, tmp.childNodes );

                                // Remember the top-level container
                                tmp = fragment.firstChild;

                                // Ensure the created nodes are orphaned (#12392)
                                tmp.textContent = "";
                            }
                        }
                    }

                    // Remove wrapper from fragment
                    fragment.textContent = "";

                    i = 0;
                    while ( ( elem = nodes[ i++ ] ) ) {

                        // Skip elements already in the context collection (trac-4087)
                        if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
                            if ( ignored ) {
                                ignored.push( elem );
                            }
                            continue;
                        }

                        attached = isAttached( elem );

                        // Append to fragment
                        tmp = getAll( fragment.appendChild( elem ), "script" );

                        // Preserve script evaluation history
                        if ( attached ) {
                            setGlobalEval( tmp );
                        }

                        // Capture executables
                        if ( scripts ) {
                            j = 0;
                            while ( ( elem = tmp[ j++ ] ) ) {
                                if ( rscriptType.test( elem.type || "" ) ) {
                                    scripts.push( elem );
                                }
                            }
                        }
                    }

                    return fragment;
                }


                var
                    rkeyEvent = /^key/,
                    rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
                    rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

                function returnTrue() {
                    return true;
                }

                function returnFalse() {
                    return false;
                }

// Support: IE <=9 - 11+
// focus() and blur() are asynchronous, except when they are no-op.
// So expect focus to be synchronous when the element is already active,
// and blur to be synchronous when the element is not already active.
// (focus and blur are always synchronous in other supported browsers,
// this just defines when we can count on it).
                function expectSync( elem, type ) {
                    return ( elem === safeActiveElement() ) === ( type === "focus" );
                }

// Support: IE <=9 only
// Accessing document.activeElement can throw unexpectedly
// https://bugs.jquery.com/ticket/13393
                function safeActiveElement() {
                    try {
                        return document.activeElement;
                    } catch ( err ) { }
                }

                function on( elem, types, selector, data, fn, one ) {
                    var origFn, type;

                    // Types can be a map of types/handlers
                    if ( typeof types === "object" ) {

                        // ( types-Object, selector, data )
                        if ( typeof selector !== "string" ) {

                            // ( types-Object, data )
                            data = data || selector;
                            selector = undefined;
                        }
                        for ( type in types ) {
                            on( elem, type, selector, data, types[ type ], one );
                        }
                        return elem;
                    }

                    if ( data == null && fn == null ) {

                        // ( types, fn )
                        fn = selector;
                        data = selector = undefined;
                    } else if ( fn == null ) {
                        if ( typeof selector === "string" ) {

                            // ( types, selector, fn )
                            fn = data;
                            data = undefined;
                        } else {

                            // ( types, data, fn )
                            fn = data;
                            data = selector;
                            selector = undefined;
                        }
                    }
                    if ( fn === false ) {
                        fn = returnFalse;
                    } else if ( !fn ) {
                        return elem;
                    }

                    if ( one === 1 ) {
                        origFn = fn;
                        fn = function( event ) {

                            // Can use an empty set, since event contains the info
                            jQuery().off( event );
                            return origFn.apply( this, arguments );
                        };

                        // Use same guid so caller can remove using origFn
                        fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
                    }
                    return elem.each( function() {
                        jQuery.event.add( this, types, fn, data, selector );
                    } );
                }

                /*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
                jQuery.event = {

                    global: {},

                    add: function( elem, types, handler, data, selector ) {

                        var handleObjIn, eventHandle, tmp,
                            events, t, handleObj,
                            special, handlers, type, namespaces, origType,
                            elemData = dataPriv.get( elem );

                        // Only attach events to objects that accept data
                        if ( !acceptData( elem ) ) {
                            return;
                        }

                        // Caller can pass in an object of custom data in lieu of the handler
                        if ( handler.handler ) {
                            handleObjIn = handler;
                            handler = handleObjIn.handler;
                            selector = handleObjIn.selector;
                        }

                        // Ensure that invalid selectors throw exceptions at attach time
                        // Evaluate against documentElement in case elem is a non-element node (e.g., document)
                        if ( selector ) {
                            jQuery.find.matchesSelector( documentElement, selector );
                        }

                        // Make sure that the handler has a unique ID, used to find/remove it later
                        if ( !handler.guid ) {
                            handler.guid = jQuery.guid++;
                        }

                        // Init the element's event structure and main handler, if this is the first
                        if ( !( events = elemData.events ) ) {
                            events = elemData.events = Object.create( null );
                        }
                        if ( !( eventHandle = elemData.handle ) ) {
                            eventHandle = elemData.handle = function( e ) {

                                // Discard the second event of a jQuery.event.trigger() and
                                // when an event is called after a page has unloaded
                                return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
                                    jQuery.event.dispatch.apply( elem, arguments ) : undefined;
                            };
                        }

                        // Handle multiple events separated by a space
                        types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
                        t = types.length;
                        while ( t-- ) {
                            tmp = rtypenamespace.exec( types[ t ] ) || [];
                            type = origType = tmp[ 1 ];
                            namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

                            // There *must* be a type, no attaching namespace-only handlers
                            if ( !type ) {
                                continue;
                            }

                            // If event changes its type, use the special event handlers for the changed type
                            special = jQuery.event.special[ type ] || {};

                            // If selector defined, determine special event api type, otherwise given type
                            type = ( selector ? special.delegateType : special.bindType ) || type;

                            // Update special based on newly reset type
                            special = jQuery.event.special[ type ] || {};

                            // handleObj is passed to all event handlers
                            handleObj = jQuery.extend( {
                                type: type,
                                origType: origType,
                                data: data,
                                handler: handler,
                                guid: handler.guid,
                                selector: selector,
                                needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
                                namespace: namespaces.join( "." )
                            }, handleObjIn );

                            // Init the event handler queue if we're the first
                            if ( !( handlers = events[ type ] ) ) {
                                handlers = events[ type ] = [];
                                handlers.delegateCount = 0;

                                // Only use addEventListener if the special events handler returns false
                                if ( !special.setup ||
                                    special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

                                    if ( elem.addEventListener ) {
                                        elem.addEventListener( type, eventHandle );
                                    }
                                }
                            }

                            if ( special.add ) {
                                special.add.call( elem, handleObj );

                                if ( !handleObj.handler.guid ) {
                                    handleObj.handler.guid = handler.guid;
                                }
                            }

                            // Add to the element's handler list, delegates in front
                            if ( selector ) {
                                handlers.splice( handlers.delegateCount++, 0, handleObj );
                            } else {
                                handlers.push( handleObj );
                            }

                            // Keep track of which events have ever been used, for event optimization
                            jQuery.event.global[ type ] = true;
                        }

                    },

                    // Detach an event or set of events from an element
                    remove: function( elem, types, handler, selector, mappedTypes ) {

                        var j, origCount, tmp,
                            events, t, handleObj,
                            special, handlers, type, namespaces, origType,
                            elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

                        if ( !elemData || !( events = elemData.events ) ) {
                            return;
                        }

                        // Once for each type.namespace in types; type may be omitted
                        types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
                        t = types.length;
                        while ( t-- ) {
                            tmp = rtypenamespace.exec( types[ t ] ) || [];
                            type = origType = tmp[ 1 ];
                            namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

                            // Unbind all events (on this namespace, if provided) for the element
                            if ( !type ) {
                                for ( type in events ) {
                                    jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
                                }
                                continue;
                            }

                            special = jQuery.event.special[ type ] || {};
                            type = ( selector ? special.delegateType : special.bindType ) || type;
                            handlers = events[ type ] || [];
                            tmp = tmp[ 2 ] &&
                                new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

                            // Remove matching events
                            origCount = j = handlers.length;
                            while ( j-- ) {
                                handleObj = handlers[ j ];

                                if ( ( mappedTypes || origType === handleObj.origType ) &&
                                    ( !handler || handler.guid === handleObj.guid ) &&
                                    ( !tmp || tmp.test( handleObj.namespace ) ) &&
                                    ( !selector || selector === handleObj.selector ||
                                        selector === "**" && handleObj.selector ) ) {
                                    handlers.splice( j, 1 );

                                    if ( handleObj.selector ) {
                                        handlers.delegateCount--;
                                    }
                                    if ( special.remove ) {
                                        special.remove.call( elem, handleObj );
                                    }
                                }
                            }

                            // Remove generic event handler if we removed something and no more handlers exist
                            // (avoids potential for endless recursion during removal of special event handlers)
                            if ( origCount && !handlers.length ) {
                                if ( !special.teardown ||
                                    special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

                                    jQuery.removeEvent( elem, type, elemData.handle );
                                }

                                delete events[ type ];
                            }
                        }

                        // Remove data and the expando if it's no longer used
                        if ( jQuery.isEmptyObject( events ) ) {
                            dataPriv.remove( elem, "handle events" );
                        }
                    },

                    dispatch: function( nativeEvent ) {

                        var i, j, ret, matched, handleObj, handlerQueue,
                            args = new Array( arguments.length ),

                            // Make a writable jQuery.Event from the native event object
                            event = jQuery.event.fix( nativeEvent ),

                            handlers = (
                                dataPriv.get( this, "events" ) || Object.create( null )
                            )[ event.type ] || [],
                            special = jQuery.event.special[ event.type ] || {};

                        // Use the fix-ed jQuery.Event rather than the (read-only) native event
                        args[ 0 ] = event;

                        for ( i = 1; i < arguments.length; i++ ) {
                            args[ i ] = arguments[ i ];
                        }

                        event.delegateTarget = this;

                        // Call the preDispatch hook for the mapped type, and let it bail if desired
                        if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
                            return;
                        }

                        // Determine handlers
                        handlerQueue = jQuery.event.handlers.call( this, event, handlers );

                        // Run delegates first; they may want to stop propagation beneath us
                        i = 0;
                        while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
                            event.currentTarget = matched.elem;

                            j = 0;
                            while ( ( handleObj = matched.handlers[ j++ ] ) &&
                            !event.isImmediatePropagationStopped() ) {

                                // If the event is namespaced, then each handler is only invoked if it is
                                // specially universal or its namespaces are a superset of the event's.
                                if ( !event.rnamespace || handleObj.namespace === false ||
                                    event.rnamespace.test( handleObj.namespace ) ) {

                                    event.handleObj = handleObj;
                                    event.data = handleObj.data;

                                    ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
                                        handleObj.handler ).apply( matched.elem, args );

                                    if ( ret !== undefined ) {
                                        if ( ( event.result = ret ) === false ) {
                                            event.preventDefault();
                                            event.stopPropagation();
                                        }
                                    }
                                }
                            }
                        }

                        // Call the postDispatch hook for the mapped type
                        if ( special.postDispatch ) {
                            special.postDispatch.call( this, event );
                        }

                        return event.result;
                    },

                    handlers: function( event, handlers ) {
                        var i, handleObj, sel, matchedHandlers, matchedSelectors,
                            handlerQueue = [],
                            delegateCount = handlers.delegateCount,
                            cur = event.target;

                        // Find delegate handlers
                        if ( delegateCount &&

                            // Support: IE <=9
                            // Black-hole SVG <use> instance trees (trac-13180)
                            cur.nodeType &&

                            // Support: Firefox <=42
                            // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
                            // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
                            // Support: IE 11 only
                            // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
                            !( event.type === "click" && event.button >= 1 ) ) {

                            for ( ; cur !== this; cur = cur.parentNode || this ) {

                                // Don't check non-elements (#13208)
                                // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
                                if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
                                    matchedHandlers = [];
                                    matchedSelectors = {};
                                    for ( i = 0; i < delegateCount; i++ ) {
                                        handleObj = handlers[ i ];

                                        // Don't conflict with Object.prototype properties (#13203)
                                        sel = handleObj.selector + " ";

                                        if ( matchedSelectors[ sel ] === undefined ) {
                                            matchedSelectors[ sel ] = handleObj.needsContext ?
                                                jQuery( sel, this ).index( cur ) > -1 :
                                                jQuery.find( sel, this, null, [ cur ] ).length;
                                        }
                                        if ( matchedSelectors[ sel ] ) {
                                            matchedHandlers.push( handleObj );
                                        }
                                    }
                                    if ( matchedHandlers.length ) {
                                        handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
                                    }
                                }
                            }
                        }

                        // Add the remaining (directly-bound) handlers
                        cur = this;
                        if ( delegateCount < handlers.length ) {
                            handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
                        }

                        return handlerQueue;
                    },

                    addProp: function( name, hook ) {
                        Object.defineProperty( jQuery.Event.prototype, name, {
                            enumerable: true,
                            configurable: true,

                            get: isFunction( hook ) ?
                                function() {
                                    if ( this.originalEvent ) {
                                        return hook( this.originalEvent );
                                    }
                                } :
                                function() {
                                    if ( this.originalEvent ) {
                                        return this.originalEvent[ name ];
                                    }
                                },

                            set: function( value ) {
                                Object.defineProperty( this, name, {
                                    enumerable: true,
                                    configurable: true,
                                    writable: true,
                                    value: value
                                } );
                            }
                        } );
                    },

                    fix: function( originalEvent ) {
                        return originalEvent[ jQuery.expando ] ?
                            originalEvent :
                            new jQuery.Event( originalEvent );
                    },

                    special: {
                        load: {

                            // Prevent triggered image.load events from bubbling to window.load
                            noBubble: true
                        },
                        click: {

                            // Utilize native event to ensure correct state for checkable inputs
                            setup: function( data ) {

                                // For mutual compressibility with _default, replace `this` access with a local var.
                                // `|| data` is dead code meant only to preserve the variable through minification.
                                var el = this || data;

                                // Claim the first handler
                                if ( rcheckableType.test( el.type ) &&
                                    el.click && nodeName( el, "input" ) ) {

                                    // dataPriv.set( el, "click", ... )
                                    leverageNative( el, "click", returnTrue );
                                }

                                // Return false to allow normal processing in the caller
                                return false;
                            },
                            trigger: function( data ) {

                                // For mutual compressibility with _default, replace `this` access with a local var.
                                // `|| data` is dead code meant only to preserve the variable through minification.
                                var el = this || data;

                                // Force setup before triggering a click
                                if ( rcheckableType.test( el.type ) &&
                                    el.click && nodeName( el, "input" ) ) {

                                    leverageNative( el, "click" );
                                }

                                // Return non-false to allow normal event-path propagation
                                return true;
                            },

                            // For cross-browser consistency, suppress native .click() on links
                            // Also prevent it if we're currently inside a leveraged native-event stack
                            _default: function( event ) {
                                var target = event.target;
                                return rcheckableType.test( target.type ) &&
                                    target.click && nodeName( target, "input" ) &&
                                    dataPriv.get( target, "click" ) ||
                                    nodeName( target, "a" );
                            }
                        },

                        beforeunload: {
                            postDispatch: function( event ) {

                                // Support: Firefox 20+
                                // Firefox doesn't alert if the returnValue field is not set.
                                if ( event.result !== undefined && event.originalEvent ) {
                                    event.originalEvent.returnValue = event.result;
                                }
                            }
                        }
                    }
                };

// Ensure the presence of an event listener that handles manually-triggered
// synthetic events by interrupting progress until reinvoked in response to
// *native* events that it fires directly, ensuring that state changes have
// already occurred before other listeners are invoked.
                function leverageNative( el, type, expectSync ) {

                    // Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
                    if ( !expectSync ) {
                        if ( dataPriv.get( el, type ) === undefined ) {
                            jQuery.event.add( el, type, returnTrue );
                        }
                        return;
                    }

                    // Register the controller as a special universal handler for all event namespaces
                    dataPriv.set( el, type, false );
                    jQuery.event.add( el, type, {
                        namespace: false,
                        handler: function( event ) {
                            var notAsync, result,
                                saved = dataPriv.get( this, type );

                            if ( ( event.isTrigger & 1 ) && this[ type ] ) {

                                // Interrupt processing of the outer synthetic .trigger()ed event
                                // Saved data should be false in such cases, but might be a leftover capture object
                                // from an async native handler (gh-4350)
                                if ( !saved.length ) {

                                    // Store arguments for use when handling the inner native event
                                    // There will always be at least one argument (an event object), so this array
                                    // will not be confused with a leftover capture object.
                                    saved = slice.call( arguments );
                                    dataPriv.set( this, type, saved );

                                    // Trigger the native event and capture its result
                                    // Support: IE <=9 - 11+
                                    // focus() and blur() are asynchronous
                                    notAsync = expectSync( this, type );
                                    this[ type ]();
                                    result = dataPriv.get( this, type );
                                    if ( saved !== result || notAsync ) {
                                        dataPriv.set( this, type, false );
                                    } else {
                                        result = {};
                                    }
                                    if ( saved !== result ) {

                                        // Cancel the outer synthetic event
                                        event.stopImmediatePropagation();
                                        event.preventDefault();
                                        return result.value;
                                    }

                                    // If this is an inner synthetic event for an event with a bubbling surrogate
                                    // (focus or blur), assume that the surrogate already propagated from triggering the
                                    // native event and prevent that from happening again here.
                                    // This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
                                    // bubbling surrogate propagates *after* the non-bubbling base), but that seems
                                    // less bad than duplication.
                                } else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
                                    event.stopPropagation();
                                }

                                // If this is a native event triggered above, everything is now in order
                                // Fire an inner synthetic event with the original arguments
                            } else if ( saved.length ) {

                                // ...and capture the result
                                dataPriv.set( this, type, {
                                    value: jQuery.event.trigger(

                                        // Support: IE <=9 - 11+
                                        // Extend with the prototype to reset the above stopImmediatePropagation()
                                        jQuery.extend( saved[ 0 ], jQuery.Event.prototype ),
                                        saved.slice( 1 ),
                                        this
                                    )
                                } );

                                // Abort handling of the native event
                                event.stopImmediatePropagation();
                            }
                        }
                    } );
                }

                jQuery.removeEvent = function( elem, type, handle ) {

                    // This "if" is needed for plain objects
                    if ( elem.removeEventListener ) {
                        elem.removeEventListener( type, handle );
                    }
                };

                jQuery.Event = function( src, props ) {

                    // Allow instantiation without the 'new' keyword
                    if ( !( this instanceof jQuery.Event ) ) {
                        return new jQuery.Event( src, props );
                    }

                    // Event object
                    if ( src && src.type ) {
                        this.originalEvent = src;
                        this.type = src.type;

                        // Events bubbling up the document may have been marked as prevented
                        // by a handler lower down the tree; reflect the correct value.
                        this.isDefaultPrevented = src.defaultPrevented ||
                        src.defaultPrevented === undefined &&

                        // Support: Android <=2.3 only
                        src.returnValue === false ?
                            returnTrue :
                            returnFalse;

                        // Create target properties
                        // Support: Safari <=6 - 7 only
                        // Target should not be a text node (#504, #13143)
                        this.target = ( src.target && src.target.nodeType === 3 ) ?
                            src.target.parentNode :
                            src.target;

                        this.currentTarget = src.currentTarget;
                        this.relatedTarget = src.relatedTarget;

                        // Event type
                    } else {
                        this.type = src;
                    }

                    // Put explicitly provided properties onto the event object
                    if ( props ) {
                        jQuery.extend( this, props );
                    }

                    // Create a timestamp if incoming event doesn't have one
                    this.timeStamp = src && src.timeStamp || Date.now();

                    // Mark it as fixed
                    this[ jQuery.expando ] = true;
                };

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
                jQuery.Event.prototype = {
                    constructor: jQuery.Event,
                    isDefaultPrevented: returnFalse,
                    isPropagationStopped: returnFalse,
                    isImmediatePropagationStopped: returnFalse,
                    isSimulated: false,

                    preventDefault: function() {
                        var e = this.originalEvent;

                        this.isDefaultPrevented = returnTrue;

                        if ( e && !this.isSimulated ) {
                            e.preventDefault();
                        }
                    },
                    stopPropagation: function() {
                        var e = this.originalEvent;

                        this.isPropagationStopped = returnTrue;

                        if ( e && !this.isSimulated ) {
                            e.stopPropagation();
                        }
                    },
                    stopImmediatePropagation: function() {
                        var e = this.originalEvent;

                        this.isImmediatePropagationStopped = returnTrue;

                        if ( e && !this.isSimulated ) {
                            e.stopImmediatePropagation();
                        }

                        this.stopPropagation();
                    }
                };

// Includes all common event props including KeyEvent and MouseEvent specific props
                jQuery.each( {
                    altKey: true,
                    bubbles: true,
                    cancelable: true,
                    changedTouches: true,
                    ctrlKey: true,
                    detail: true,
                    eventPhase: true,
                    metaKey: true,
                    pageX: true,
                    pageY: true,
                    shiftKey: true,
                    view: true,
                    "char": true,
                    code: true,
                    charCode: true,
                    key: true,
                    keyCode: true,
                    button: true,
                    buttons: true,
                    clientX: true,
                    clientY: true,
                    offsetX: true,
                    offsetY: true,
                    pointerId: true,
                    pointerType: true,
                    screenX: true,
                    screenY: true,
                    targetTouches: true,
                    toElement: true,
                    touches: true,

                    which: function( event ) {
                        var button = event.button;

                        // Add which for key events
                        if ( event.which == null && rkeyEvent.test( event.type ) ) {
                            return event.charCode != null ? event.charCode : event.keyCode;
                        }

                        // Add which for click: 1 === left; 2 === middle; 3 === right
                        if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
                            if ( button & 1 ) {
                                return 1;
                            }

                            if ( button & 2 ) {
                                return 3;
                            }

                            if ( button & 4 ) {
                                return 2;
                            }

                            return 0;
                        }

                        return event.which;
                    }
                }, jQuery.event.addProp );

                jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {
                    jQuery.event.special[ type ] = {

                        // Utilize native event if possible so blur/focus sequence is correct
                        setup: function() {

                            // Claim the first handler
                            // dataPriv.set( this, "focus", ... )
                            // dataPriv.set( this, "blur", ... )
                            leverageNative( this, type, expectSync );

                            // Return false to allow normal processing in the caller
                            return false;
                        },
                        trigger: function() {

                            // Force setup before trigger
                            leverageNative( this, type );

                            // Return non-false to allow normal event-path propagation
                            return true;
                        },

                        delegateType: delegateType
                    };
                } );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
                jQuery.each( {
                    mouseenter: "mouseover",
                    mouseleave: "mouseout",
                    pointerenter: "pointerover",
                    pointerleave: "pointerout"
                }, function( orig, fix ) {
                    jQuery.event.special[ orig ] = {
                        delegateType: fix,
                        bindType: fix,

                        handle: function( event ) {
                            var ret,
                                target = this,
                                related = event.relatedTarget,
                                handleObj = event.handleObj;

                            // For mouseenter/leave call the handler if related is outside the target.
                            // NB: No relatedTarget if the mouse left/entered the browser window
                            if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
                                event.type = handleObj.origType;
                                ret = handleObj.handler.apply( this, arguments );
                                event.type = fix;
                            }
                            return ret;
                        }
                    };
                } );

                jQuery.fn.extend( {

                    on: function( types, selector, data, fn ) {
                        return on( this, types, selector, data, fn );
                    },
                    one: function( types, selector, data, fn ) {
                        return on( this, types, selector, data, fn, 1 );
                    },
                    off: function( types, selector, fn ) {
                        var handleObj, type;
                        if ( types && types.preventDefault && types.handleObj ) {

                            // ( event )  dispatched jQuery.Event
                            handleObj = types.handleObj;
                            jQuery( types.delegateTarget ).off(
                                handleObj.namespace ?
                                    handleObj.origType + "." + handleObj.namespace :
                                    handleObj.origType,
                                handleObj.selector,
                                handleObj.handler
                            );
                            return this;
                        }
                        if ( typeof types === "object" ) {

                            // ( types-object [, selector] )
                            for ( type in types ) {
                                this.off( type, selector, types[ type ] );
                            }
                            return this;
                        }
                        if ( selector === false || typeof selector === "function" ) {

                            // ( types [, fn] )
                            fn = selector;
                            selector = undefined;
                        }
                        if ( fn === false ) {
                            fn = returnFalse;
                        }
                        return this.each( function() {
                            jQuery.event.remove( this, types, fn, selector );
                        } );
                    }
                } );


                var

                    // Support: IE <=10 - 11, Edge 12 - 13 only
                    // In IE/Edge using regex groups here causes severe slowdowns.
                    // See https://connect.microsoft.com/IE/feedback/details/1736512/
                    rnoInnerhtml = /<script|<style|<link/i,

                    // checked="checked" or checked
                    rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
                    rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
                function manipulationTarget( elem, content ) {
                    if ( nodeName( elem, "table" ) &&
                        nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

                        return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
                    }

                    return elem;
                }

// Replace/restore the type attribute of script elements for safe DOM manipulation
                function disableScript( elem ) {
                    elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
                    return elem;
                }
                function restoreScript( elem ) {
                    if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
                        elem.type = elem.type.slice( 5 );
                    } else {
                        elem.removeAttribute( "type" );
                    }

                    return elem;
                }

                function cloneCopyEvent( src, dest ) {
                    var i, l, type, pdataOld, udataOld, udataCur, events;

                    if ( dest.nodeType !== 1 ) {
                        return;
                    }

                    // 1. Copy private data: events, handlers, etc.
                    if ( dataPriv.hasData( src ) ) {
                        pdataOld = dataPriv.get( src );
                        events = pdataOld.events;

                        if ( events ) {
                            dataPriv.remove( dest, "handle events" );

                            for ( type in events ) {
                                for ( i = 0, l = events[ type ].length; i < l; i++ ) {
                                    jQuery.event.add( dest, type, events[ type ][ i ] );
                                }
                            }
                        }
                    }

                    // 2. Copy user data
                    if ( dataUser.hasData( src ) ) {
                        udataOld = dataUser.access( src );
                        udataCur = jQuery.extend( {}, udataOld );

                        dataUser.set( dest, udataCur );
                    }
                }

// Fix IE bugs, see support tests
                function fixInput( src, dest ) {
                    var nodeName = dest.nodeName.toLowerCase();

                    // Fails to persist the checked state of a cloned checkbox or radio button.
                    if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
                        dest.checked = src.checked;

                        // Fails to return the selected option to the default selected state when cloning options
                    } else if ( nodeName === "input" || nodeName === "textarea" ) {
                        dest.defaultValue = src.defaultValue;
                    }
                }

                function domManip( collection, args, callback, ignored ) {

                    // Flatten any nested arrays
                    args = flat( args );

                    var fragment, first, scripts, hasScripts, node, doc,
                        i = 0,
                        l = collection.length,
                        iNoClone = l - 1,
                        value = args[ 0 ],
                        valueIsFunction = isFunction( value );

                    // We can't cloneNode fragments that contain checked, in WebKit
                    if ( valueIsFunction ||
                        ( l > 1 && typeof value === "string" &&
                            !support.checkClone && rchecked.test( value ) ) ) {
                        return collection.each( function( index ) {
                            var self = collection.eq( index );
                            if ( valueIsFunction ) {
                                args[ 0 ] = value.call( this, index, self.html() );
                            }
                            domManip( self, args, callback, ignored );
                        } );
                    }

                    if ( l ) {
                        fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
                        first = fragment.firstChild;

                        if ( fragment.childNodes.length === 1 ) {
                            fragment = first;
                        }

                        // Require either new content or an interest in ignored elements to invoke the callback
                        if ( first || ignored ) {
                            scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
                            hasScripts = scripts.length;

                            // Use the original fragment for the last item
                            // instead of the first because it can end up
                            // being emptied incorrectly in certain situations (#8070).
                            for ( ; i < l; i++ ) {
                                node = fragment;

                                if ( i !== iNoClone ) {
                                    node = jQuery.clone( node, true, true );

                                    // Keep references to cloned scripts for later restoration
                                    if ( hasScripts ) {

                                        // Support: Android <=4.0 only, PhantomJS 1 only
                                        // push.apply(_, arraylike) throws on ancient WebKit
                                        jQuery.merge( scripts, getAll( node, "script" ) );
                                    }
                                }

                                callback.call( collection[ i ], node, i );
                            }

                            if ( hasScripts ) {
                                doc = scripts[ scripts.length - 1 ].ownerDocument;

                                // Reenable scripts
                                jQuery.map( scripts, restoreScript );

                                // Evaluate executable scripts on first document insertion
                                for ( i = 0; i < hasScripts; i++ ) {
                                    node = scripts[ i ];
                                    if ( rscriptType.test( node.type || "" ) &&
                                        !dataPriv.access( node, "globalEval" ) &&
                                        jQuery.contains( doc, node ) ) {

                                        if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

                                            // Optional AJAX dependency, but won't run scripts if not present
                                            if ( jQuery._evalUrl && !node.noModule ) {
                                                jQuery._evalUrl( node.src, {
                                                    nonce: node.nonce || node.getAttribute( "nonce" )
                                                }, doc );
                                            }
                                        } else {
                                            DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
                                        }
                                    }
                                }
                            }
                        }
                    }

                    return collection;
                }

                function remove( elem, selector, keepData ) {
                    var node,
                        nodes = selector ? jQuery.filter( selector, elem ) : elem,
                        i = 0;

                    for ( ; ( node = nodes[ i ] ) != null; i++ ) {
                        if ( !keepData && node.nodeType === 1 ) {
                            jQuery.cleanData( getAll( node ) );
                        }

                        if ( node.parentNode ) {
                            if ( keepData && isAttached( node ) ) {
                                setGlobalEval( getAll( node, "script" ) );
                            }
                            node.parentNode.removeChild( node );
                        }
                    }

                    return elem;
                }

                jQuery.extend( {
                    htmlPrefilter: function( html ) {
                        return html;
                    },

                    clone: function( elem, dataAndEvents, deepDataAndEvents ) {
                        var i, l, srcElements, destElements,
                            clone = elem.cloneNode( true ),
                            inPage = isAttached( elem );

                        // Fix IE cloning issues
                        if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
                            !jQuery.isXMLDoc( elem ) ) {

                            // We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
                            destElements = getAll( clone );
                            srcElements = getAll( elem );

                            for ( i = 0, l = srcElements.length; i < l; i++ ) {
                                fixInput( srcElements[ i ], destElements[ i ] );
                            }
                        }

                        // Copy the events from the original to the clone
                        if ( dataAndEvents ) {
                            if ( deepDataAndEvents ) {
                                srcElements = srcElements || getAll( elem );
                                destElements = destElements || getAll( clone );

                                for ( i = 0, l = srcElements.length; i < l; i++ ) {
                                    cloneCopyEvent( srcElements[ i ], destElements[ i ] );
                                }
                            } else {
                                cloneCopyEvent( elem, clone );
                            }
                        }

                        // Preserve script evaluation history
                        destElements = getAll( clone, "script" );
                        if ( destElements.length > 0 ) {
                            setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
                        }

                        // Return the cloned set
                        return clone;
                    },

                    cleanData: function( elems ) {
                        var data, elem, type,
                            special = jQuery.event.special,
                            i = 0;

                        for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
                            if ( acceptData( elem ) ) {
                                if ( ( data = elem[ dataPriv.expando ] ) ) {
                                    if ( data.events ) {
                                        for ( type in data.events ) {
                                            if ( special[ type ] ) {
                                                jQuery.event.remove( elem, type );

                                                // This is a shortcut to avoid jQuery.event.remove's overhead
                                            } else {
                                                jQuery.removeEvent( elem, type, data.handle );
                                            }
                                        }
                                    }

                                    // Support: Chrome <=35 - 45+
                                    // Assign undefined instead of using delete, see Data#remove
                                    elem[ dataPriv.expando ] = undefined;
                                }
                                if ( elem[ dataUser.expando ] ) {

                                    // Support: Chrome <=35 - 45+
                                    // Assign undefined instead of using delete, see Data#remove
                                    elem[ dataUser.expando ] = undefined;
                                }
                            }
                        }
                    }
                } );

                jQuery.fn.extend( {
                    detach: function( selector ) {
                        return remove( this, selector, true );
                    },

                    remove: function( selector ) {
                        return remove( this, selector );
                    },

                    text: function( value ) {
                        return access( this, function( value ) {
                            return value === undefined ?
                                jQuery.text( this ) :
                                this.empty().each( function() {
                                    if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
                                        this.textContent = value;
                                    }
                                } );
                        }, null, value, arguments.length );
                    },

                    append: function() {
                        return domManip( this, arguments, function( elem ) {
                            if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
                                var target = manipulationTarget( this, elem );
                                target.appendChild( elem );
                            }
                        } );
                    },

                    prepend: function() {
                        return domManip( this, arguments, function( elem ) {
                            if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
                                var target = manipulationTarget( this, elem );
                                target.insertBefore( elem, target.firstChild );
                            }
                        } );
                    },

                    before: function() {
                        return domManip( this, arguments, function( elem ) {
                            if ( this.parentNode ) {
                                this.parentNode.insertBefore( elem, this );
                            }
                        } );
                    },

                    after: function() {
                        return domManip( this, arguments, function( elem ) {
                            if ( this.parentNode ) {
                                this.parentNode.insertBefore( elem, this.nextSibling );
                            }
                        } );
                    },

                    empty: function() {
                        var elem,
                            i = 0;

                        for ( ; ( elem = this[ i ] ) != null; i++ ) {
                            if ( elem.nodeType === 1 ) {

                                // Prevent memory leaks
                                jQuery.cleanData( getAll( elem, false ) );

                                // Remove any remaining nodes
                                elem.textContent = "";
                            }
                        }

                        return this;
                    },

                    clone: function( dataAndEvents, deepDataAndEvents ) {
                        dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
                        deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

                        return this.map( function() {
                            return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
                        } );
                    },

                    html: function( value ) {
                        return access( this, function( value ) {
                            var elem = this[ 0 ] || {},
                                i = 0,
                                l = this.length;

                            if ( value === undefined && elem.nodeType === 1 ) {
                                return elem.innerHTML;
                            }

                            // See if we can take a shortcut and just use innerHTML
                            if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
                                !wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

                                value = jQuery.htmlPrefilter( value );

                                try {
                                    for ( ; i < l; i++ ) {
                                        elem = this[ i ] || {};

                                        // Remove element nodes and prevent memory leaks
                                        if ( elem.nodeType === 1 ) {
                                            jQuery.cleanData( getAll( elem, false ) );
                                            elem.innerHTML = value;
                                        }
                                    }

                                    elem = 0;

                                    // If using innerHTML throws an exception, use the fallback method
                                } catch ( e ) {}
                            }

                            if ( elem ) {
                                this.empty().append( value );
                            }
                        }, null, value, arguments.length );
                    },

                    replaceWith: function() {
                        var ignored = [];

                        // Make the changes, replacing each non-ignored context element with the new content
                        return domManip( this, arguments, function( elem ) {
                            var parent = this.parentNode;

                            if ( jQuery.inArray( this, ignored ) < 0 ) {
                                jQuery.cleanData( getAll( this ) );
                                if ( parent ) {
                                    parent.replaceChild( elem, this );
                                }
                            }

                            // Force callback invocation
                        }, ignored );
                    }
                } );

                jQuery.each( {
                    appendTo: "append",
                    prependTo: "prepend",
                    insertBefore: "before",
                    insertAfter: "after",
                    replaceAll: "replaceWith"
                }, function( name, original ) {
                    jQuery.fn[ name ] = function( selector ) {
                        var elems,
                            ret = [],
                            insert = jQuery( selector ),
                            last = insert.length - 1,
                            i = 0;

                        for ( ; i <= last; i++ ) {
                            elems = i === last ? this : this.clone( true );
                            jQuery( insert[ i ] )[ original ]( elems );

                            // Support: Android <=4.0 only, PhantomJS 1 only
                            // .get() because push.apply(_, arraylike) throws on ancient WebKit
                            push.apply( ret, elems.get() );
                        }

                        return this.pushStack( ret );
                    };
                } );
                var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

                var getStyles = function( elem ) {

                    // Support: IE <=11 only, Firefox <=30 (#15098, #14150)
                    // IE throws on elements created in popups
                    // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
                    var view = elem.ownerDocument.defaultView;

                    if ( !view || !view.opener ) {
                        view = window;
                    }

                    return view.getComputedStyle( elem );
                };

                var swap = function( elem, options, callback ) {
                    var ret, name,
                        old = {};

                    // Remember the old values, and insert the new ones
                    for ( name in options ) {
                        old[ name ] = elem.style[ name ];
                        elem.style[ name ] = options[ name ];
                    }

                    ret = callback.call( elem );

                    // Revert the old values
                    for ( name in options ) {
                        elem.style[ name ] = old[ name ];
                    }

                    return ret;
                };


                var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



                ( function() {

                    // Executing both pixelPosition & boxSizingReliable tests require only one layout
                    // so they're executed at the same time to save the second computation.
                    function computeStyleTests() {

                        // This is a singleton, we need to execute it only once
                        if ( !div ) {
                            return;
                        }

                        container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
                            "margin-top:1px;padding:0;border:0";
                        div.style.cssText =
                            "position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
                            "margin:auto;border:1px;padding:1px;" +
                            "width:60%;top:1%";
                        documentElement.appendChild( container ).appendChild( div );

                        var divStyle = window.getComputedStyle( div );
                        pixelPositionVal = divStyle.top !== "1%";

                        // Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
                        reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

                        // Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
                        // Some styles come back with percentage values, even though they shouldn't
                        div.style.right = "60%";
                        pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

                        // Support: IE 9 - 11 only
                        // Detect misreporting of content dimensions for box-sizing:border-box elements
                        boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

                        // Support: IE 9 only
                        // Detect overflow:scroll screwiness (gh-3699)
                        // Support: Chrome <=64
                        // Don't get tricked when zoom affects offsetWidth (gh-4029)
                        div.style.position = "absolute";
                        scrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;

                        documentElement.removeChild( container );

                        // Nullify the div so it wouldn't be stored in the memory and
                        // it will also be a sign that checks already performed
                        div = null;
                    }

                    function roundPixelMeasures( measure ) {
                        return Math.round( parseFloat( measure ) );
                    }

                    var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
                        reliableTrDimensionsVal, reliableMarginLeftVal,
                        container = document.createElement( "div" ),
                        div = document.createElement( "div" );

                    // Finish early in limited (non-browser) environments
                    if ( !div.style ) {
                        return;
                    }

                    // Support: IE <=9 - 11 only
                    // Style of cloned element affects source element cloned (#8908)
                    div.style.backgroundClip = "content-box";
                    div.cloneNode( true ).style.backgroundClip = "";
                    support.clearCloneStyle = div.style.backgroundClip === "content-box";

                    jQuery.extend( support, {
                        boxSizingReliable: function() {
                            computeStyleTests();
                            return boxSizingReliableVal;
                        },
                        pixelBoxStyles: function() {
                            computeStyleTests();
                            return pixelBoxStylesVal;
                        },
                        pixelPosition: function() {
                            computeStyleTests();
                            return pixelPositionVal;
                        },
                        reliableMarginLeft: function() {
                            computeStyleTests();
                            return reliableMarginLeftVal;
                        },
                        scrollboxSize: function() {
                            computeStyleTests();
                            return scrollboxSizeVal;
                        },

                        // Support: IE 9 - 11+, Edge 15 - 18+
                        // IE/Edge misreport `getComputedStyle` of table rows with width/height
                        // set in CSS while `offset*` properties report correct values.
                        // Behavior in IE 9 is more subtle than in newer versions & it passes
                        // some versions of this test; make sure not to make it pass there!
                        reliableTrDimensions: function() {
                            var table, tr, trChild, trStyle;
                            if ( reliableTrDimensionsVal == null ) {
                                table = document.createElement( "table" );
                                tr = document.createElement( "tr" );
                                trChild = document.createElement( "div" );

                                table.style.cssText = "position:absolute;left:-11111px";
                                tr.style.height = "1px";
                                trChild.style.height = "9px";

                                documentElement
                                    .appendChild( table )
                                    .appendChild( tr )
                                    .appendChild( trChild );

                                trStyle = window.getComputedStyle( tr );
                                reliableTrDimensionsVal = parseInt( trStyle.height ) > 3;

                                documentElement.removeChild( table );
                            }
                            return reliableTrDimensionsVal;
                        }
                    } );
                } )();


                function curCSS( elem, name, computed ) {
                    var width, minWidth, maxWidth, ret,

                        // Support: Firefox 51+
                        // Retrieving style before computed somehow
                        // fixes an issue with getting wrong values
                        // on detached elements
                        style = elem.style;

                    computed = computed || getStyles( elem );

                    // getPropertyValue is needed for:
                    //   .css('filter') (IE 9 only, #12537)
                    //   .css('--customProperty) (#3144)
                    if ( computed ) {
                        ret = computed.getPropertyValue( name ) || computed[ name ];

                        if ( ret === "" && !isAttached( elem ) ) {
                            ret = jQuery.style( elem, name );
                        }

                        // A tribute to the "awesome hack by Dean Edwards"
                        // Android Browser returns percentage for some values,
                        // but width seems to be reliably pixels.
                        // This is against the CSSOM draft spec:
                        // https://drafts.csswg.org/cssom/#resolved-values
                        if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

                            // Remember the original values
                            width = style.width;
                            minWidth = style.minWidth;
                            maxWidth = style.maxWidth;

                            // Put in the new values to get a computed value out
                            style.minWidth = style.maxWidth = style.width = ret;
                            ret = computed.width;

                            // Revert the changed values
                            style.width = width;
                            style.minWidth = minWidth;
                            style.maxWidth = maxWidth;
                        }
                    }

                    return ret !== undefined ?

                        // Support: IE <=9 - 11 only
                        // IE returns zIndex value as an integer.
                        ret + "" :
                        ret;
                }


                function addGetHookIf( conditionFn, hookFn ) {

                    // Define the hook, we'll check on the first run if it's really needed.
                    return {
                        get: function() {
                            if ( conditionFn() ) {

                                // Hook not needed (or it's not possible to use it due
                                // to missing dependency), remove it.
                                delete this.get;
                                return;
                            }

                            // Hook needed; redefine it so that the support test is not executed again.
                            return ( this.get = hookFn ).apply( this, arguments );
                        }
                    };
                }


                var cssPrefixes = [ "Webkit", "Moz", "ms" ],
                    emptyStyle = document.createElement( "div" ).style,
                    vendorProps = {};

// Return a vendor-prefixed property or undefined
                function vendorPropName( name ) {

                    // Check for vendor prefixed names
                    var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
                        i = cssPrefixes.length;

                    while ( i-- ) {
                        name = cssPrefixes[ i ] + capName;
                        if ( name in emptyStyle ) {
                            return name;
                        }
                    }
                }

// Return a potentially-mapped jQuery.cssProps or vendor prefixed property
                function finalPropName( name ) {
                    var final = jQuery.cssProps[ name ] || vendorProps[ name ];

                    if ( final ) {
                        return final;
                    }
                    if ( name in emptyStyle ) {
                        return name;
                    }
                    return vendorProps[ name ] = vendorPropName( name ) || name;
                }


                var

                    // Swappable if display is none or starts with table
                    // except "table", "table-cell", or "table-caption"
                    // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
                    rdisplayswap = /^(none|table(?!-c[ea]).+)/,
                    rcustomProp = /^--/,
                    cssShow = { position: "absolute", visibility: "hidden", display: "block" },
                    cssNormalTransform = {
                        letterSpacing: "0",
                        fontWeight: "400"
                    };

                function setPositiveNumber( _elem, value, subtract ) {

                    // Any relative (+/-) values have already been
                    // normalized at this point
                    var matches = rcssNum.exec( value );
                    return matches ?

                        // Guard against undefined "subtract", e.g., when used as in cssHooks
                        Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
                        value;
                }

                function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
                    var i = dimension === "width" ? 1 : 0,
                        extra = 0,
                        delta = 0;

                    // Adjustment may not be necessary
                    if ( box === ( isBorderBox ? "border" : "content" ) ) {
                        return 0;
                    }

                    for ( ; i < 4; i += 2 ) {

                        // Both box models exclude margin
                        if ( box === "margin" ) {
                            delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
                        }

                        // If we get here with a content-box, we're seeking "padding" or "border" or "margin"
                        if ( !isBorderBox ) {

                            // Add padding
                            delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

                            // For "border" or "margin", add border
                            if ( box !== "padding" ) {
                                delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

                                // But still keep track of it otherwise
                            } else {
                                extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
                            }

                            // If we get here with a border-box (content + padding + border), we're seeking "content" or
                            // "padding" or "margin"
                        } else {

                            // For "content", subtract padding
                            if ( box === "content" ) {
                                delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
                            }

                            // For "content" or "padding", subtract border
                            if ( box !== "margin" ) {
                                delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
                            }
                        }
                    }

                    // Account for positive content-box scroll gutter when requested by providing computedVal
                    if ( !isBorderBox && computedVal >= 0 ) {

                        // offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
                        // Assuming integer scroll gutter, subtract the rest and round down
                        delta += Math.max( 0, Math.ceil(
                            elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
                            computedVal -
                            delta -
                            extra -
                            0.5

                            // If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
                            // Use an explicit zero to avoid NaN (gh-3964)
                        ) ) || 0;
                    }

                    return delta;
                }

                function getWidthOrHeight( elem, dimension, extra ) {

                    // Start with computed style
                    var styles = getStyles( elem ),

                        // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
                        // Fake content-box until we know it's needed to know the true value.
                        boxSizingNeeded = !support.boxSizingReliable() || extra,
                        isBorderBox = boxSizingNeeded &&
                            jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
                        valueIsBorderBox = isBorderBox,

                        val = curCSS( elem, dimension, styles ),
                        offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );

                    // Support: Firefox <=54
                    // Return a confounding non-pixel value or feign ignorance, as appropriate.
                    if ( rnumnonpx.test( val ) ) {
                        if ( !extra ) {
                            return val;
                        }
                        val = "auto";
                    }


                    // Support: IE 9 - 11 only
                    // Use offsetWidth/offsetHeight for when box sizing is unreliable.
                    // In those cases, the computed value can be trusted to be border-box.
                    if ( ( !support.boxSizingReliable() && isBorderBox ||

                            // Support: IE 10 - 11+, Edge 15 - 18+
                            // IE/Edge misreport `getComputedStyle` of table rows with width/height
                            // set in CSS while `offset*` properties report correct values.
                            // Interestingly, in some cases IE 9 doesn't suffer from this issue.
                            !support.reliableTrDimensions() && nodeName( elem, "tr" ) ||

                            // Fall back to offsetWidth/offsetHeight when value is "auto"
                            // This happens for inline elements with no explicit setting (gh-3571)
                            val === "auto" ||

                            // Support: Android <=4.1 - 4.3 only
                            // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
                            !parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&

                        // Make sure the element is visible & connected
                        elem.getClientRects().length ) {

                        isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

                        // Where available, offsetWidth/offsetHeight approximate border box dimensions.
                        // Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
                        // retrieved value as a content box dimension.
                        valueIsBorderBox = offsetProp in elem;
                        if ( valueIsBorderBox ) {
                            val = elem[ offsetProp ];
                        }
                    }

                    // Normalize "" and auto
                    val = parseFloat( val ) || 0;

                    // Adjust for the element's box model
                    return ( val +
                        boxModelAdjustment(
                            elem,
                            dimension,
                            extra || ( isBorderBox ? "border" : "content" ),
                            valueIsBorderBox,
                            styles,

                            // Provide the current computed size to request scroll gutter calculation (gh-3589)
                            val
                        )
                    ) + "px";
                }

                jQuery.extend( {

                    // Add in style property hooks for overriding the default
                    // behavior of getting and setting a style property
                    cssHooks: {
                        opacity: {
                            get: function( elem, computed ) {
                                if ( computed ) {

                                    // We should always get a number back from opacity
                                    var ret = curCSS( elem, "opacity" );
                                    return ret === "" ? "1" : ret;
                                }
                            }
                        }
                    },

                    // Don't automatically add "px" to these possibly-unitless properties
                    cssNumber: {
                        "animationIterationCount": true,
                        "columnCount": true,
                        "fillOpacity": true,
                        "flexGrow": true,
                        "flexShrink": true,
                        "fontWeight": true,
                        "gridArea": true,
                        "gridColumn": true,
                        "gridColumnEnd": true,
                        "gridColumnStart": true,
                        "gridRow": true,
                        "gridRowEnd": true,
                        "gridRowStart": true,
                        "lineHeight": true,
                        "opacity": true,
                        "order": true,
                        "orphans": true,
                        "widows": true,
                        "zIndex": true,
                        "zoom": true
                    },

                    // Add in properties whose names you wish to fix before
                    // setting or getting the value
                    cssProps: {},

                    // Get and set the style property on a DOM Node
                    style: function( elem, name, value, extra ) {

                        // Don't set styles on text and comment nodes
                        if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
                            return;
                        }

                        // Make sure that we're working with the right name
                        var ret, type, hooks,
                            origName = camelCase( name ),
                            isCustomProp = rcustomProp.test( name ),
                            style = elem.style;

                        // Make sure that we're working with the right name. We don't
                        // want to query the value if it is a CSS custom property
                        // since they are user-defined.
                        if ( !isCustomProp ) {
                            name = finalPropName( origName );
                        }

                        // Gets hook for the prefixed version, then unprefixed version
                        hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

                        // Check if we're setting a value
                        if ( value !== undefined ) {
                            type = typeof value;

                            // Convert "+=" or "-=" to relative numbers (#7345)
                            if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
                                value = adjustCSS( elem, name, ret );

                                // Fixes bug #9237
                                type = "number";
                            }

                            // Make sure that null and NaN values aren't set (#7116)
                            if ( value == null || value !== value ) {
                                return;
                            }

                            // If a number was passed in, add the unit (except for certain CSS properties)
                            // The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
                            // "px" to a few hardcoded values.
                            if ( type === "number" && !isCustomProp ) {
                                value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
                            }

                            // background-* props affect original clone's values
                            if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
                                style[ name ] = "inherit";
                            }

                            // If a hook was provided, use that value, otherwise just set the specified value
                            if ( !hooks || !( "set" in hooks ) ||
                                ( value = hooks.set( elem, value, extra ) ) !== undefined ) {

                                if ( isCustomProp ) {
                                    style.setProperty( name, value );
                                } else {
                                    style[ name ] = value;
                                }
                            }

                        } else {

                            // If a hook was provided get the non-computed value from there
                            if ( hooks && "get" in hooks &&
                                ( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

                                return ret;
                            }

                            // Otherwise just get the value from the style object
                            return style[ name ];
                        }
                    },

                    css: function( elem, name, extra, styles ) {
                        var val, num, hooks,
                            origName = camelCase( name ),
                            isCustomProp = rcustomProp.test( name );

                        // Make sure that we're working with the right name. We don't
                        // want to modify the value if it is a CSS custom property
                        // since they are user-defined.
                        if ( !isCustomProp ) {
                            name = finalPropName( origName );
                        }

                        // Try prefixed name followed by the unprefixed name
                        hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

                        // If a hook was provided get the computed value from there
                        if ( hooks && "get" in hooks ) {
                            val = hooks.get( elem, true, extra );
                        }

                        // Otherwise, if a way to get the computed value exists, use that
                        if ( val === undefined ) {
                            val = curCSS( elem, name, styles );
                        }

                        // Convert "normal" to computed value
                        if ( val === "normal" && name in cssNormalTransform ) {
                            val = cssNormalTransform[ name ];
                        }

                        // Make numeric if forced or a qualifier was provided and val looks numeric
                        if ( extra === "" || extra ) {
                            num = parseFloat( val );
                            return extra === true || isFinite( num ) ? num || 0 : val;
                        }

                        return val;
                    }
                } );

                jQuery.each( [ "height", "width" ], function( _i, dimension ) {
                    jQuery.cssHooks[ dimension ] = {
                        get: function( elem, computed, extra ) {
                            if ( computed ) {

                                // Certain elements can have dimension info if we invisibly show them
                                // but it must have a current display style that would benefit
                                return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

                                // Support: Safari 8+
                                // Table columns in Safari have non-zero offsetWidth & zero
                                // getBoundingClientRect().width unless display is changed.
                                // Support: IE <=11 only
                                // Running getBoundingClientRect on a disconnected node
                                // in IE throws an error.
                                ( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
                                    swap( elem, cssShow, function() {
                                        return getWidthOrHeight( elem, dimension, extra );
                                    } ) :
                                    getWidthOrHeight( elem, dimension, extra );
                            }
                        },

                        set: function( elem, value, extra ) {
                            var matches,
                                styles = getStyles( elem ),

                                // Only read styles.position if the test has a chance to fail
                                // to avoid forcing a reflow.
                                scrollboxSizeBuggy = !support.scrollboxSize() &&
                                    styles.position === "absolute",

                                // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
                                boxSizingNeeded = scrollboxSizeBuggy || extra,
                                isBorderBox = boxSizingNeeded &&
                                    jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
                                subtract = extra ?
                                    boxModelAdjustment(
                                        elem,
                                        dimension,
                                        extra,
                                        isBorderBox,
                                        styles
                                    ) :
                                    0;

                            // Account for unreliable border-box dimensions by comparing offset* to computed and
                            // faking a content-box to get border and padding (gh-3699)
                            if ( isBorderBox && scrollboxSizeBuggy ) {
                                subtract -= Math.ceil(
                                    elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
                                    parseFloat( styles[ dimension ] ) -
                                    boxModelAdjustment( elem, dimension, "border", false, styles ) -
                                    0.5
                                );
                            }

                            // Convert to pixels if value adjustment is needed
                            if ( subtract && ( matches = rcssNum.exec( value ) ) &&
                                ( matches[ 3 ] || "px" ) !== "px" ) {

                                elem.style[ dimension ] = value;
                                value = jQuery.css( elem, dimension );
                            }

                            return setPositiveNumber( elem, value, subtract );
                        }
                    };
                } );

                jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
                    function( elem, computed ) {
                        if ( computed ) {
                            return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
                                elem.getBoundingClientRect().left -
                                swap( elem, { marginLeft: 0 }, function() {
                                    return elem.getBoundingClientRect().left;
                                } )
                            ) + "px";
                        }
                    }
                );

// These hooks are used by animate to expand properties
                jQuery.each( {
                    margin: "",
                    padding: "",
                    border: "Width"
                }, function( prefix, suffix ) {
                    jQuery.cssHooks[ prefix + suffix ] = {
                        expand: function( value ) {
                            var i = 0,
                                expanded = {},

                                // Assumes a single number if not a string
                                parts = typeof value === "string" ? value.split( " " ) : [ value ];

                            for ( ; i < 4; i++ ) {
                                expanded[ prefix + cssExpand[ i ] + suffix ] =
                                    parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
                            }

                            return expanded;
                        }
                    };

                    if ( prefix !== "margin" ) {
                        jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
                    }
                } );

                jQuery.fn.extend( {
                    css: function( name, value ) {
                        return access( this, function( elem, name, value ) {
                            var styles, len,
                                map = {},
                                i = 0;

                            if ( Array.isArray( name ) ) {
                                styles = getStyles( elem );
                                len = name.length;

                                for ( ; i < len; i++ ) {
                                    map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
                                }

                                return map;
                            }

                            return value !== undefined ?
                                jQuery.style( elem, name, value ) :
                                jQuery.css( elem, name );
                        }, name, value, arguments.length > 1 );
                    }
                } );


                function Tween( elem, options, prop, end, easing ) {
                    return new Tween.prototype.init( elem, options, prop, end, easing );
                }
                jQuery.Tween = Tween;

                Tween.prototype = {
                    constructor: Tween,
                    init: function( elem, options, prop, end, easing, unit ) {
                        this.elem = elem;
                        this.prop = prop;
                        this.easing = easing || jQuery.easing._default;
                        this.options = options;
                        this.start = this.now = this.cur();
                        this.end = end;
                        this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
                    },
                    cur: function() {
                        var hooks = Tween.propHooks[ this.prop ];

                        return hooks && hooks.get ?
                            hooks.get( this ) :
                            Tween.propHooks._default.get( this );
                    },
                    run: function( percent ) {
                        var eased,
                            hooks = Tween.propHooks[ this.prop ];

                        if ( this.options.duration ) {
                            this.pos = eased = jQuery.easing[ this.easing ](
                                percent, this.options.duration * percent, 0, 1, this.options.duration
                            );
                        } else {
                            this.pos = eased = percent;
                        }
                        this.now = ( this.end - this.start ) * eased + this.start;

                        if ( this.options.step ) {
                            this.options.step.call( this.elem, this.now, this );
                        }

                        if ( hooks && hooks.set ) {
                            hooks.set( this );
                        } else {
                            Tween.propHooks._default.set( this );
                        }
                        return this;
                    }
                };

                Tween.prototype.init.prototype = Tween.prototype;

                Tween.propHooks = {
                    _default: {
                        get: function( tween ) {
                            var result;

                            // Use a property on the element directly when it is not a DOM element,
                            // or when there is no matching style property that exists.
                            if ( tween.elem.nodeType !== 1 ||
                                tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
                                return tween.elem[ tween.prop ];
                            }

                            // Passing an empty string as a 3rd parameter to .css will automatically
                            // attempt a parseFloat and fallback to a string if the parse fails.
                            // Simple values such as "10px" are parsed to Float;
                            // complex values such as "rotate(1rad)" are returned as-is.
                            result = jQuery.css( tween.elem, tween.prop, "" );

                            // Empty strings, null, undefined and "auto" are converted to 0.
                            return !result || result === "auto" ? 0 : result;
                        },
                        set: function( tween ) {

                            // Use step hook for back compat.
                            // Use cssHook if its there.
                            // Use .style if available and use plain properties where available.
                            if ( jQuery.fx.step[ tween.prop ] ) {
                                jQuery.fx.step[ tween.prop ]( tween );
                            } else if ( tween.elem.nodeType === 1 && (
                                jQuery.cssHooks[ tween.prop ] ||
                                tween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {
                                jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
                            } else {
                                tween.elem[ tween.prop ] = tween.now;
                            }
                        }
                    }
                };

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
                Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
                    set: function( tween ) {
                        if ( tween.elem.nodeType && tween.elem.parentNode ) {
                            tween.elem[ tween.prop ] = tween.now;
                        }
                    }
                };

                jQuery.easing = {
                    linear: function( p ) {
                        return p;
                    },
                    swing: function( p ) {
                        return 0.5 - Math.cos( p * Math.PI ) / 2;
                    },
                    _default: "swing"
                };

                jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
                jQuery.fx.step = {};




                var
                    fxNow, inProgress,
                    rfxtypes = /^(?:toggle|show|hide)$/,
                    rrun = /queueHooks$/;

                function schedule() {
                    if ( inProgress ) {
                        if ( document.hidden === false && window.requestAnimationFrame ) {
                            window.requestAnimationFrame( schedule );
                        } else {
                            window.setTimeout( schedule, jQuery.fx.interval );
                        }

                        jQuery.fx.tick();
                    }
                }

// Animations created synchronously will run synchronously
                function createFxNow() {
                    window.setTimeout( function() {
                        fxNow = undefined;
                    } );
                    return ( fxNow = Date.now() );
                }

// Generate parameters to create a standard animation
                function genFx( type, includeWidth ) {
                    var which,
                        i = 0,
                        attrs = { height: type };

                    // If we include width, step value is 1 to do all cssExpand values,
                    // otherwise step value is 2 to skip over Left and Right
                    includeWidth = includeWidth ? 1 : 0;
                    for ( ; i < 4; i += 2 - includeWidth ) {
                        which = cssExpand[ i ];
                        attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
                    }

                    if ( includeWidth ) {
                        attrs.opacity = attrs.width = type;
                    }

                    return attrs;
                }

                function createTween( value, prop, animation ) {
                    var tween,
                        collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
                        index = 0,
                        length = collection.length;
                    for ( ; index < length; index++ ) {
                        if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

                            // We're done with this property
                            return tween;
                        }
                    }
                }

                function defaultPrefilter( elem, props, opts ) {
                    var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
                        isBox = "width" in props || "height" in props,
                        anim = this,
                        orig = {},
                        style = elem.style,
                        hidden = elem.nodeType && isHiddenWithinTree( elem ),
                        dataShow = dataPriv.get( elem, "fxshow" );

                    // Queue-skipping animations hijack the fx hooks
                    if ( !opts.queue ) {
                        hooks = jQuery._queueHooks( elem, "fx" );
                        if ( hooks.unqueued == null ) {
                            hooks.unqueued = 0;
                            oldfire = hooks.empty.fire;
                            hooks.empty.fire = function() {
                                if ( !hooks.unqueued ) {
                                    oldfire();
                                }
                            };
                        }
                        hooks.unqueued++;

                        anim.always( function() {

                            // Ensure the complete handler is called before this completes
                            anim.always( function() {
                                hooks.unqueued--;
                                if ( !jQuery.queue( elem, "fx" ).length ) {
                                    hooks.empty.fire();
                                }
                            } );
                        } );
                    }

                    // Detect show/hide animations
                    for ( prop in props ) {
                        value = props[ prop ];
                        if ( rfxtypes.test( value ) ) {
                            delete props[ prop ];
                            toggle = toggle || value === "toggle";
                            if ( value === ( hidden ? "hide" : "show" ) ) {

                                // Pretend to be hidden if this is a "show" and
                                // there is still data from a stopped show/hide
                                if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
                                    hidden = true;

                                    // Ignore all other no-op show/hide data
                                } else {
                                    continue;
                                }
                            }
                            orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
                        }
                    }

                    // Bail out if this is a no-op like .hide().hide()
                    propTween = !jQuery.isEmptyObject( props );
                    if ( !propTween && jQuery.isEmptyObject( orig ) ) {
                        return;
                    }

                    // Restrict "overflow" and "display" styles during box animations
                    if ( isBox && elem.nodeType === 1 ) {

                        // Support: IE <=9 - 11, Edge 12 - 15
                        // Record all 3 overflow attributes because IE does not infer the shorthand
                        // from identically-valued overflowX and overflowY and Edge just mirrors
                        // the overflowX value there.
                        opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

                        // Identify a display type, preferring old show/hide data over the CSS cascade
                        restoreDisplay = dataShow && dataShow.display;
                        if ( restoreDisplay == null ) {
                            restoreDisplay = dataPriv.get( elem, "display" );
                        }
                        display = jQuery.css( elem, "display" );
                        if ( display === "none" ) {
                            if ( restoreDisplay ) {
                                display = restoreDisplay;
                            } else {

                                // Get nonempty value(s) by temporarily forcing visibility
                                showHide( [ elem ], true );
                                restoreDisplay = elem.style.display || restoreDisplay;
                                display = jQuery.css( elem, "display" );
                                showHide( [ elem ] );
                            }
                        }

                        // Animate inline elements as inline-block
                        if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
                            if ( jQuery.css( elem, "float" ) === "none" ) {

                                // Restore the original display value at the end of pure show/hide animations
                                if ( !propTween ) {
                                    anim.done( function() {
                                        style.display = restoreDisplay;
                                    } );
                                    if ( restoreDisplay == null ) {
                                        display = style.display;
                                        restoreDisplay = display === "none" ? "" : display;
                                    }
                                }
                                style.display = "inline-block";
                            }
                        }
                    }

                    if ( opts.overflow ) {
                        style.overflow = "hidden";
                        anim.always( function() {
                            style.overflow = opts.overflow[ 0 ];
                            style.overflowX = opts.overflow[ 1 ];
                            style.overflowY = opts.overflow[ 2 ];
                        } );
                    }

                    // Implement show/hide animations
                    propTween = false;
                    for ( prop in orig ) {

                        // General show/hide setup for this element animation
                        if ( !propTween ) {
                            if ( dataShow ) {
                                if ( "hidden" in dataShow ) {
                                    hidden = dataShow.hidden;
                                }
                            } else {
                                dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
                            }

                            // Store hidden/visible for toggle so `.stop().toggle()` "reverses"
                            if ( toggle ) {
                                dataShow.hidden = !hidden;
                            }

                            // Show elements before animating them
                            if ( hidden ) {
                                showHide( [ elem ], true );
                            }

                            /* eslint-disable no-loop-func */

                            anim.done( function() {

                                /* eslint-enable no-loop-func */

                                // The final step of a "hide" animation is actually hiding the element
                                if ( !hidden ) {
                                    showHide( [ elem ] );
                                }
                                dataPriv.remove( elem, "fxshow" );
                                for ( prop in orig ) {
                                    jQuery.style( elem, prop, orig[ prop ] );
                                }
                            } );
                        }

                        // Per-property setup
                        propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
                        if ( !( prop in dataShow ) ) {
                            dataShow[ prop ] = propTween.start;
                            if ( hidden ) {
                                propTween.end = propTween.start;
                                propTween.start = 0;
                            }
                        }
                    }
                }

                function propFilter( props, specialEasing ) {
                    var index, name, easing, value, hooks;

                    // camelCase, specialEasing and expand cssHook pass
                    for ( index in props ) {
                        name = camelCase( index );
                        easing = specialEasing[ name ];
                        value = props[ index ];
                        if ( Array.isArray( value ) ) {
                            easing = value[ 1 ];
                            value = props[ index ] = value[ 0 ];
                        }

                        if ( index !== name ) {
                            props[ name ] = value;
                            delete props[ index ];
                        }

                        hooks = jQuery.cssHooks[ name ];
                        if ( hooks && "expand" in hooks ) {
                            value = hooks.expand( value );
                            delete props[ name ];

                            // Not quite $.extend, this won't overwrite existing keys.
                            // Reusing 'index' because we have the correct "name"
                            for ( index in value ) {
                                if ( !( index in props ) ) {
                                    props[ index ] = value[ index ];
                                    specialEasing[ index ] = easing;
                                }
                            }
                        } else {
                            specialEasing[ name ] = easing;
                        }
                    }
                }

                function Animation( elem, properties, options ) {
                    var result,
                        stopped,
                        index = 0,
                        length = Animation.prefilters.length,
                        deferred = jQuery.Deferred().always( function() {

                            // Don't match elem in the :animated selector
                            delete tick.elem;
                        } ),
                        tick = function() {
                            if ( stopped ) {
                                return false;
                            }
                            var currentTime = fxNow || createFxNow(),
                                remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

                                // Support: Android 2.3 only
                                // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
                                temp = remaining / animation.duration || 0,
                                percent = 1 - temp,
                                index = 0,
                                length = animation.tweens.length;

                            for ( ; index < length; index++ ) {
                                animation.tweens[ index ].run( percent );
                            }

                            deferred.notifyWith( elem, [ animation, percent, remaining ] );

                            // If there's more to do, yield
                            if ( percent < 1 && length ) {
                                return remaining;
                            }

                            // If this was an empty animation, synthesize a final progress notification
                            if ( !length ) {
                                deferred.notifyWith( elem, [ animation, 1, 0 ] );
                            }

                            // Resolve the animation and report its conclusion
                            deferred.resolveWith( elem, [ animation ] );
                            return false;
                        },
                        animation = deferred.promise( {
                            elem: elem,
                            props: jQuery.extend( {}, properties ),
                            opts: jQuery.extend( true, {
                                specialEasing: {},
                                easing: jQuery.easing._default
                            }, options ),
                            originalProperties: properties,
                            originalOptions: options,
                            startTime: fxNow || createFxNow(),
                            duration: options.duration,
                            tweens: [],
                            createTween: function( prop, end ) {
                                var tween = jQuery.Tween( elem, animation.opts, prop, end,
                                    animation.opts.specialEasing[ prop ] || animation.opts.easing );
                                animation.tweens.push( tween );
                                return tween;
                            },
                            stop: function( gotoEnd ) {
                                var index = 0,

                                    // If we are going to the end, we want to run all the tweens
                                    // otherwise we skip this part
                                    length = gotoEnd ? animation.tweens.length : 0;
                                if ( stopped ) {
                                    return this;
                                }
                                stopped = true;
                                for ( ; index < length; index++ ) {
                                    animation.tweens[ index ].run( 1 );
                                }

                                // Resolve when we played the last frame; otherwise, reject
                                if ( gotoEnd ) {
                                    deferred.notifyWith( elem, [ animation, 1, 0 ] );
                                    deferred.resolveWith( elem, [ animation, gotoEnd ] );
                                } else {
                                    deferred.rejectWith( elem, [ animation, gotoEnd ] );
                                }
                                return this;
                            }
                        } ),
                        props = animation.props;

                    propFilter( props, animation.opts.specialEasing );

                    for ( ; index < length; index++ ) {
                        result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
                        if ( result ) {
                            if ( isFunction( result.stop ) ) {
                                jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
                                    result.stop.bind( result );
                            }
                            return result;
                        }
                    }

                    jQuery.map( props, createTween, animation );

                    if ( isFunction( animation.opts.start ) ) {
                        animation.opts.start.call( elem, animation );
                    }

                    // Attach callbacks from options
                    animation
                        .progress( animation.opts.progress )
                        .done( animation.opts.done, animation.opts.complete )
                        .fail( animation.opts.fail )
                        .always( animation.opts.always );

                    jQuery.fx.timer(
                        jQuery.extend( tick, {
                            elem: elem,
                            anim: animation,
                            queue: animation.opts.queue
                        } )
                    );

                    return animation;
                }

                jQuery.Animation = jQuery.extend( Animation, {

                    tweeners: {
                        "*": [ function( prop, value ) {
                            var tween = this.createTween( prop, value );
                            adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
                            return tween;
                        } ]
                    },

                    tweener: function( props, callback ) {
                        if ( isFunction( props ) ) {
                            callback = props;
                            props = [ "*" ];
                        } else {
                            props = props.match( rnothtmlwhite );
                        }

                        var prop,
                            index = 0,
                            length = props.length;

                        for ( ; index < length; index++ ) {
                            prop = props[ index ];
                            Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
                            Animation.tweeners[ prop ].unshift( callback );
                        }
                    },

                    prefilters: [ defaultPrefilter ],

                    prefilter: function( callback, prepend ) {
                        if ( prepend ) {
                            Animation.prefilters.unshift( callback );
                        } else {
                            Animation.prefilters.push( callback );
                        }
                    }
                } );

                jQuery.speed = function( speed, easing, fn ) {
                    var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
                        complete: fn || !fn && easing ||
                            isFunction( speed ) && speed,
                        duration: speed,
                        easing: fn && easing || easing && !isFunction( easing ) && easing
                    };

                    // Go to the end state if fx are off
                    if ( jQuery.fx.off ) {
                        opt.duration = 0;

                    } else {
                        if ( typeof opt.duration !== "number" ) {
                            if ( opt.duration in jQuery.fx.speeds ) {
                                opt.duration = jQuery.fx.speeds[ opt.duration ];

                            } else {
                                opt.duration = jQuery.fx.speeds._default;
                            }
                        }
                    }

                    // Normalize opt.queue - true/undefined/null -> "fx"
                    if ( opt.queue == null || opt.queue === true ) {
                        opt.queue = "fx";
                    }

                    // Queueing
                    opt.old = opt.complete;

                    opt.complete = function() {
                        if ( isFunction( opt.old ) ) {
                            opt.old.call( this );
                        }

                        if ( opt.queue ) {
                            jQuery.dequeue( this, opt.queue );
                        }
                    };

                    return opt;
                };

                jQuery.fn.extend( {
                    fadeTo: function( speed, to, easing, callback ) {

                        // Show any hidden elements after setting opacity to 0
                        return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

                            // Animate to the value specified
                            .end().animate( { opacity: to }, speed, easing, callback );
                    },
                    animate: function( prop, speed, easing, callback ) {
                        var empty = jQuery.isEmptyObject( prop ),
                            optall = jQuery.speed( speed, easing, callback ),
                            doAnimation = function() {

                                // Operate on a copy of prop so per-property easing won't be lost
                                var anim = Animation( this, jQuery.extend( {}, prop ), optall );

                                // Empty animations, or finishing resolves immediately
                                if ( empty || dataPriv.get( this, "finish" ) ) {
                                    anim.stop( true );
                                }
                            };
                        doAnimation.finish = doAnimation;

                        return empty || optall.queue === false ?
                            this.each( doAnimation ) :
                            this.queue( optall.queue, doAnimation );
                    },
                    stop: function( type, clearQueue, gotoEnd ) {
                        var stopQueue = function( hooks ) {
                            var stop = hooks.stop;
                            delete hooks.stop;
                            stop( gotoEnd );
                        };

                        if ( typeof type !== "string" ) {
                            gotoEnd = clearQueue;
                            clearQueue = type;
                            type = undefined;
                        }
                        if ( clearQueue ) {
                            this.queue( type || "fx", [] );
                        }

                        return this.each( function() {
                            var dequeue = true,
                                index = type != null && type + "queueHooks",
                                timers = jQuery.timers,
                                data = dataPriv.get( this );

                            if ( index ) {
                                if ( data[ index ] && data[ index ].stop ) {
                                    stopQueue( data[ index ] );
                                }
                            } else {
                                for ( index in data ) {
                                    if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
                                        stopQueue( data[ index ] );
                                    }
                                }
                            }

                            for ( index = timers.length; index--; ) {
                                if ( timers[ index ].elem === this &&
                                    ( type == null || timers[ index ].queue === type ) ) {

                                    timers[ index ].anim.stop( gotoEnd );
                                    dequeue = false;
                                    timers.splice( index, 1 );
                                }
                            }

                            // Start the next in the queue if the last step wasn't forced.
                            // Timers currently will call their complete callbacks, which
                            // will dequeue but only if they were gotoEnd.
                            if ( dequeue || !gotoEnd ) {
                                jQuery.dequeue( this, type );
                            }
                        } );
                    },
                    finish: function( type ) {
                        if ( type !== false ) {
                            type = type || "fx";
                        }
                        return this.each( function() {
                            var index,
                                data = dataPriv.get( this ),
                                queue = data[ type + "queue" ],
                                hooks = data[ type + "queueHooks" ],
                                timers = jQuery.timers,
                                length = queue ? queue.length : 0;

                            // Enable finishing flag on private data
                            data.finish = true;

                            // Empty the queue first
                            jQuery.queue( this, type, [] );

                            if ( hooks && hooks.stop ) {
                                hooks.stop.call( this, true );
                            }

                            // Look for any active animations, and finish them
                            for ( index = timers.length; index--; ) {
                                if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
                                    timers[ index ].anim.stop( true );
                                    timers.splice( index, 1 );
                                }
                            }

                            // Look for any animations in the old queue and finish them
                            for ( index = 0; index < length; index++ ) {
                                if ( queue[ index ] && queue[ index ].finish ) {
                                    queue[ index ].finish.call( this );
                                }
                            }

                            // Turn off finishing flag
                            delete data.finish;
                        } );
                    }
                } );

                jQuery.each( [ "toggle", "show", "hide" ], function( _i, name ) {
                    var cssFn = jQuery.fn[ name ];
                    jQuery.fn[ name ] = function( speed, easing, callback ) {
                        return speed == null || typeof speed === "boolean" ?
                            cssFn.apply( this, arguments ) :
                            this.animate( genFx( name, true ), speed, easing, callback );
                    };
                } );

// Generate shortcuts for custom animations
                jQuery.each( {
                    slideDown: genFx( "show" ),
                    slideUp: genFx( "hide" ),
                    slideToggle: genFx( "toggle" ),
                    fadeIn: { opacity: "show" },
                    fadeOut: { opacity: "hide" },
                    fadeToggle: { opacity: "toggle" }
                }, function( name, props ) {
                    jQuery.fn[ name ] = function( speed, easing, callback ) {
                        return this.animate( props, speed, easing, callback );
                    };
                } );

                jQuery.timers = [];
                jQuery.fx.tick = function() {
                    var timer,
                        i = 0,
                        timers = jQuery.timers;

                    fxNow = Date.now();

                    for ( ; i < timers.length; i++ ) {
                        timer = timers[ i ];

                        // Run the timer and safely remove it when done (allowing for external removal)
                        if ( !timer() && timers[ i ] === timer ) {
                            timers.splice( i--, 1 );
                        }
                    }

                    if ( !timers.length ) {
                        jQuery.fx.stop();
                    }
                    fxNow = undefined;
                };

                jQuery.fx.timer = function( timer ) {
                    jQuery.timers.push( timer );
                    jQuery.fx.start();
                };

                jQuery.fx.interval = 13;
                jQuery.fx.start = function() {
                    if ( inProgress ) {
                        return;
                    }

                    inProgress = true;
                    schedule();
                };

                jQuery.fx.stop = function() {
                    inProgress = null;
                };

                jQuery.fx.speeds = {
                    slow: 600,
                    fast: 200,

                    // Default speed
                    _default: 400
                };


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
                jQuery.fn.delay = function( time, type ) {
                    time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
                    type = type || "fx";

                    return this.queue( type, function( next, hooks ) {
                        var timeout = window.setTimeout( next, time );
                        hooks.stop = function() {
                            window.clearTimeout( timeout );
                        };
                    } );
                };


                ( function() {
                    var input = document.createElement( "input" ),
                        select = document.createElement( "select" ),
                        opt = select.appendChild( document.createElement( "option" ) );

                    input.type = "checkbox";

                    // Support: Android <=4.3 only
                    // Default value for a checkbox should be "on"
                    support.checkOn = input.value !== "";

                    // Support: IE <=11 only
                    // Must access selectedIndex to make default options select
                    support.optSelected = opt.selected;

                    // Support: IE <=11 only
                    // An input loses its value after becoming a radio
                    input = document.createElement( "input" );
                    input.value = "t";
                    input.type = "radio";
                    support.radioValue = input.value === "t";
                } )();


                var boolHook,
                    attrHandle = jQuery.expr.attrHandle;

                jQuery.fn.extend( {
                    attr: function( name, value ) {
                        return access( this, jQuery.attr, name, value, arguments.length > 1 );
                    },

                    removeAttr: function( name ) {
                        return this.each( function() {
                            jQuery.removeAttr( this, name );
                        } );
                    }
                } );

                jQuery.extend( {
                    attr: function( elem, name, value ) {
                        var ret, hooks,
                            nType = elem.nodeType;

                        // Don't get/set attributes on text, comment and attribute nodes
                        if ( nType === 3 || nType === 8 || nType === 2 ) {
                            return;
                        }

                        // Fallback to prop when attributes are not supported
                        if ( typeof elem.getAttribute === "undefined" ) {
                            return jQuery.prop( elem, name, value );
                        }

                        // Attribute hooks are determined by the lowercase version
                        // Grab necessary hook if one is defined
                        if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
                            hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
                                ( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
                        }

                        if ( value !== undefined ) {
                            if ( value === null ) {
                                jQuery.removeAttr( elem, name );
                                return;
                            }

                            if ( hooks && "set" in hooks &&
                                ( ret = hooks.set( elem, value, name ) ) !== undefined ) {
                                return ret;
                            }

                            elem.setAttribute( name, value + "" );
                            return value;
                        }

                        if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
                            return ret;
                        }

                        ret = jQuery.find.attr( elem, name );

                        // Non-existent attributes return null, we normalize to undefined
                        return ret == null ? undefined : ret;
                    },

                    attrHooks: {
                        type: {
                            set: function( elem, value ) {
                                if ( !support.radioValue && value === "radio" &&
                                    nodeName( elem, "input" ) ) {
                                    var val = elem.value;
                                    elem.setAttribute( "type", value );
                                    if ( val ) {
                                        elem.value = val;
                                    }
                                    return value;
                                }
                            }
                        }
                    },

                    removeAttr: function( elem, value ) {
                        var name,
                            i = 0,

                            // Attribute names can contain non-HTML whitespace characters
                            // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
                            attrNames = value && value.match( rnothtmlwhite );

                        if ( attrNames && elem.nodeType === 1 ) {
                            while ( ( name = attrNames[ i++ ] ) ) {
                                elem.removeAttribute( name );
                            }
                        }
                    }
                } );

// Hooks for boolean attributes
                boolHook = {
                    set: function( elem, value, name ) {
                        if ( value === false ) {

                            // Remove boolean attributes when set to false
                            jQuery.removeAttr( elem, name );
                        } else {
                            elem.setAttribute( name, name );
                        }
                        return name;
                    }
                };

                jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( _i, name ) {
                    var getter = attrHandle[ name ] || jQuery.find.attr;

                    attrHandle[ name ] = function( elem, name, isXML ) {
                        var ret, handle,
                            lowercaseName = name.toLowerCase();

                        if ( !isXML ) {

                            // Avoid an infinite loop by temporarily removing this function from the getter
                            handle = attrHandle[ lowercaseName ];
                            attrHandle[ lowercaseName ] = ret;
                            ret = getter( elem, name, isXML ) != null ?
                                lowercaseName :
                                null;
                            attrHandle[ lowercaseName ] = handle;
                        }
                        return ret;
                    };
                } );




                var rfocusable = /^(?:input|select|textarea|button)$/i,
                    rclickable = /^(?:a|area)$/i;

                jQuery.fn.extend( {
                    prop: function( name, value ) {
                        return access( this, jQuery.prop, name, value, arguments.length > 1 );
                    },

                    removeProp: function( name ) {
                        return this.each( function() {
                            delete this[ jQuery.propFix[ name ] || name ];
                        } );
                    }
                } );

                jQuery.extend( {
                    prop: function( elem, name, value ) {
                        var ret, hooks,
                            nType = elem.nodeType;

                        // Don't get/set properties on text, comment and attribute nodes
                        if ( nType === 3 || nType === 8 || nType === 2 ) {
                            return;
                        }

                        if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

                            // Fix name and attach hooks
                            name = jQuery.propFix[ name ] || name;
                            hooks = jQuery.propHooks[ name ];
                        }

                        if ( value !== undefined ) {
                            if ( hooks && "set" in hooks &&
                                ( ret = hooks.set( elem, value, name ) ) !== undefined ) {
                                return ret;
                            }

                            return ( elem[ name ] = value );
                        }

                        if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
                            return ret;
                        }

                        return elem[ name ];
                    },

                    propHooks: {
                        tabIndex: {
                            get: function( elem ) {

                                // Support: IE <=9 - 11 only
                                // elem.tabIndex doesn't always return the
                                // correct value when it hasn't been explicitly set
                                // https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
                                // Use proper attribute retrieval(#12072)
                                var tabindex = jQuery.find.attr( elem, "tabindex" );

                                if ( tabindex ) {
                                    return parseInt( tabindex, 10 );
                                }

                                if (
                                    rfocusable.test( elem.nodeName ) ||
                                    rclickable.test( elem.nodeName ) &&
                                    elem.href
                                ) {
                                    return 0;
                                }

                                return -1;
                            }
                        }
                    },

                    propFix: {
                        "for": "htmlFor",
                        "class": "className"
                    }
                } );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
                if ( !support.optSelected ) {
                    jQuery.propHooks.selected = {
                        get: function( elem ) {

                            /* eslint no-unused-expressions: "off" */

                            var parent = elem.parentNode;
                            if ( parent && parent.parentNode ) {
                                parent.parentNode.selectedIndex;
                            }
                            return null;
                        },
                        set: function( elem ) {

                            /* eslint no-unused-expressions: "off" */

                            var parent = elem.parentNode;
                            if ( parent ) {
                                parent.selectedIndex;

                                if ( parent.parentNode ) {
                                    parent.parentNode.selectedIndex;
                                }
                            }
                        }
                    };
                }

                jQuery.each( [
                    "tabIndex",
                    "readOnly",
                    "maxLength",
                    "cellSpacing",
                    "cellPadding",
                    "rowSpan",
                    "colSpan",
                    "useMap",
                    "frameBorder",
                    "contentEditable"
                ], function() {
                    jQuery.propFix[ this.toLowerCase() ] = this;
                } );




                // Strip and collapse whitespace according to HTML spec
                // https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
                function stripAndCollapse( value ) {
                    var tokens = value.match( rnothtmlwhite ) || [];
                    return tokens.join( " " );
                }


                function getClass( elem ) {
                    return elem.getAttribute && elem.getAttribute( "class" ) || "";
                }

                function classesToArray( value ) {
                    if ( Array.isArray( value ) ) {
                        return value;
                    }
                    if ( typeof value === "string" ) {
                        return value.match( rnothtmlwhite ) || [];
                    }
                    return [];
                }

                jQuery.fn.extend( {
                    addClass: function( value ) {
                        var classes, elem, cur, curValue, clazz, j, finalValue,
                            i = 0;

                        if ( isFunction( value ) ) {
                            return this.each( function( j ) {
                                jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
                            } );
                        }

                        classes = classesToArray( value );

                        if ( classes.length ) {
                            while ( ( elem = this[ i++ ] ) ) {
                                curValue = getClass( elem );
                                cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

                                if ( cur ) {
                                    j = 0;
                                    while ( ( clazz = classes[ j++ ] ) ) {
                                        if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
                                            cur += clazz + " ";
                                        }
                                    }

                                    // Only assign if different to avoid unneeded rendering.
                                    finalValue = stripAndCollapse( cur );
                                    if ( curValue !== finalValue ) {
                                        elem.setAttribute( "class", finalValue );
                                    }
                                }
                            }
                        }

                        return this;
                    },

                    removeClass: function( value ) {
                        var classes, elem, cur, curValue, clazz, j, finalValue,
                            i = 0;

                        if ( isFunction( value ) ) {
                            return this.each( function( j ) {
                                jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
                            } );
                        }

                        if ( !arguments.length ) {
                            return this.attr( "class", "" );
                        }

                        classes = classesToArray( value );

                        if ( classes.length ) {
                            while ( ( elem = this[ i++ ] ) ) {
                                curValue = getClass( elem );

                                // This expression is here for better compressibility (see addClass)
                                cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

                                if ( cur ) {
                                    j = 0;
                                    while ( ( clazz = classes[ j++ ] ) ) {

                                        // Remove *all* instances
                                        while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
                                            cur = cur.replace( " " + clazz + " ", " " );
                                        }
                                    }

                                    // Only assign if different to avoid unneeded rendering.
                                    finalValue = stripAndCollapse( cur );
                                    if ( curValue !== finalValue ) {
                                        elem.setAttribute( "class", finalValue );
                                    }
                                }
                            }
                        }

                        return this;
                    },

                    toggleClass: function( value, stateVal ) {
                        var type = typeof value,
                            isValidValue = type === "string" || Array.isArray( value );

                        if ( typeof stateVal === "boolean" && isValidValue ) {
                            return stateVal ? this.addClass( value ) : this.removeClass( value );
                        }

                        if ( isFunction( value ) ) {
                            return this.each( function( i ) {
                                jQuery( this ).toggleClass(
                                    value.call( this, i, getClass( this ), stateVal ),
                                    stateVal
                                );
                            } );
                        }

                        return this.each( function() {
                            var className, i, self, classNames;

                            if ( isValidValue ) {

                                // Toggle individual class names
                                i = 0;
                                self = jQuery( this );
                                classNames = classesToArray( value );

                                while ( ( className = classNames[ i++ ] ) ) {

                                    // Check each className given, space separated list
                                    if ( self.hasClass( className ) ) {
                                        self.removeClass( className );
                                    } else {
                                        self.addClass( className );
                                    }
                                }

                                // Toggle whole class name
                            } else if ( value === undefined || type === "boolean" ) {
                                className = getClass( this );
                                if ( className ) {

                                    // Store className if set
                                    dataPriv.set( this, "__className__", className );
                                }

                                // If the element has a class name or if we're passed `false`,
                                // then remove the whole classname (if there was one, the above saved it).
                                // Otherwise bring back whatever was previously saved (if anything),
                                // falling back to the empty string if nothing was stored.
                                if ( this.setAttribute ) {
                                    this.setAttribute( "class",
                                        className || value === false ?
                                            "" :
                                            dataPriv.get( this, "__className__" ) || ""
                                    );
                                }
                            }
                        } );
                    },

                    hasClass: function( selector ) {
                        var className, elem,
                            i = 0;

                        className = " " + selector + " ";
                        while ( ( elem = this[ i++ ] ) ) {
                            if ( elem.nodeType === 1 &&
                                ( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
                                return true;
                            }
                        }

                        return false;
                    }
                } );




                var rreturn = /\r/g;

                jQuery.fn.extend( {
                    val: function( value ) {
                        var hooks, ret, valueIsFunction,
                            elem = this[ 0 ];

                        if ( !arguments.length ) {
                            if ( elem ) {
                                hooks = jQuery.valHooks[ elem.type ] ||
                                    jQuery.valHooks[ elem.nodeName.toLowerCase() ];

                                if ( hooks &&
                                    "get" in hooks &&
                                    ( ret = hooks.get( elem, "value" ) ) !== undefined
                                ) {
                                    return ret;
                                }

                                ret = elem.value;

                                // Handle most common string cases
                                if ( typeof ret === "string" ) {
                                    return ret.replace( rreturn, "" );
                                }

                                // Handle cases where value is null/undef or number
                                return ret == null ? "" : ret;
                            }

                            return;
                        }

                        valueIsFunction = isFunction( value );

                        return this.each( function( i ) {
                            var val;

                            if ( this.nodeType !== 1 ) {
                                return;
                            }

                            if ( valueIsFunction ) {
                                val = value.call( this, i, jQuery( this ).val() );
                            } else {
                                val = value;
                            }

                            // Treat null/undefined as ""; convert numbers to string
                            if ( val == null ) {
                                val = "";

                            } else if ( typeof val === "number" ) {
                                val += "";

                            } else if ( Array.isArray( val ) ) {
                                val = jQuery.map( val, function( value ) {
                                    return value == null ? "" : value + "";
                                } );
                            }

                            hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

                            // If set returns undefined, fall back to normal setting
                            if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
                                this.value = val;
                            }
                        } );
                    }
                } );

                jQuery.extend( {
                    valHooks: {
                        option: {
                            get: function( elem ) {

                                var val = jQuery.find.attr( elem, "value" );
                                return val != null ?
                                    val :

                                    // Support: IE <=10 - 11 only
                                    // option.text throws exceptions (#14686, #14858)
                                    // Strip and collapse whitespace
                                    // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
                                    stripAndCollapse( jQuery.text( elem ) );
                            }
                        },
                        select: {
                            get: function( elem ) {
                                var value, option, i,
                                    options = elem.options,
                                    index = elem.selectedIndex,
                                    one = elem.type === "select-one",
                                    values = one ? null : [],
                                    max = one ? index + 1 : options.length;

                                if ( index < 0 ) {
                                    i = max;

                                } else {
                                    i = one ? index : 0;
                                }

                                // Loop through all the selected options
                                for ( ; i < max; i++ ) {
                                    option = options[ i ];

                                    // Support: IE <=9 only
                                    // IE8-9 doesn't update selected after form reset (#2551)
                                    if ( ( option.selected || i === index ) &&

                                        // Don't return options that are disabled or in a disabled optgroup
                                        !option.disabled &&
                                        ( !option.parentNode.disabled ||
                                            !nodeName( option.parentNode, "optgroup" ) ) ) {

                                        // Get the specific value for the option
                                        value = jQuery( option ).val();

                                        // We don't need an array for one selects
                                        if ( one ) {
                                            return value;
                                        }

                                        // Multi-Selects return an array
                                        values.push( value );
                                    }
                                }

                                return values;
                            },

                            set: function( elem, value ) {
                                var optionSet, option,
                                    options = elem.options,
                                    values = jQuery.makeArray( value ),
                                    i = options.length;

                                while ( i-- ) {
                                    option = options[ i ];

                                    /* eslint-disable no-cond-assign */

                                    if ( option.selected =
                                        jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
                                    ) {
                                        optionSet = true;
                                    }

                                    /* eslint-enable no-cond-assign */
                                }

                                // Force browsers to behave consistently when non-matching value is set
                                if ( !optionSet ) {
                                    elem.selectedIndex = -1;
                                }
                                return values;
                            }
                        }
                    }
                } );

// Radios and checkboxes getter/setter
                jQuery.each( [ "radio", "checkbox" ], function() {
                    jQuery.valHooks[ this ] = {
                        set: function( elem, value ) {
                            if ( Array.isArray( value ) ) {
                                return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
                            }
                        }
                    };
                    if ( !support.checkOn ) {
                        jQuery.valHooks[ this ].get = function( elem ) {
                            return elem.getAttribute( "value" ) === null ? "on" : elem.value;
                        };
                    }
                } );




// Return jQuery for attributes-only inclusion


                support.focusin = "onfocusin" in window;


                var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
                    stopPropagationCallback = function( e ) {
                        e.stopPropagation();
                    };

                jQuery.extend( jQuery.event, {

                    trigger: function( event, data, elem, onlyHandlers ) {

                        var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
                            eventPath = [ elem || document ],
                            type = hasOwn.call( event, "type" ) ? event.type : event,
                            namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

                        cur = lastElement = tmp = elem = elem || document;

                        // Don't do events on text and comment nodes
                        if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
                            return;
                        }

                        // focus/blur morphs to focusin/out; ensure we're not firing them right now
                        if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
                            return;
                        }

                        if ( type.indexOf( "." ) > -1 ) {

                            // Namespaced trigger; create a regexp to match event type in handle()
                            namespaces = type.split( "." );
                            type = namespaces.shift();
                            namespaces.sort();
                        }
                        ontype = type.indexOf( ":" ) < 0 && "on" + type;

                        // Caller can pass in a jQuery.Event object, Object, or just an event type string
                        event = event[ jQuery.expando ] ?
                            event :
                            new jQuery.Event( type, typeof event === "object" && event );

                        // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
                        event.isTrigger = onlyHandlers ? 2 : 3;
                        event.namespace = namespaces.join( "." );
                        event.rnamespace = event.namespace ?
                            new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
                            null;

                        // Clean up the event in case it is being reused
                        event.result = undefined;
                        if ( !event.target ) {
                            event.target = elem;
                        }

                        // Clone any incoming data and prepend the event, creating the handler arg list
                        data = data == null ?
                            [ event ] :
                            jQuery.makeArray( data, [ event ] );

                        // Allow special events to draw outside the lines
                        special = jQuery.event.special[ type ] || {};
                        if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
                            return;
                        }

                        // Determine event propagation path in advance, per W3C events spec (#9951)
                        // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
                        if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

                            bubbleType = special.delegateType || type;
                            if ( !rfocusMorph.test( bubbleType + type ) ) {
                                cur = cur.parentNode;
                            }
                            for ( ; cur; cur = cur.parentNode ) {
                                eventPath.push( cur );
                                tmp = cur;
                            }

                            // Only add window if we got to document (e.g., not plain obj or detached DOM)
                            if ( tmp === ( elem.ownerDocument || document ) ) {
                                eventPath.push( tmp.defaultView || tmp.parentWindow || window );
                            }
                        }

                        // Fire handlers on the event path
                        i = 0;
                        while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
                            lastElement = cur;
                            event.type = i > 1 ?
                                bubbleType :
                                special.bindType || type;

                            // jQuery handler
                            handle = (
                                    dataPriv.get( cur, "events" ) || Object.create( null )
                                )[ event.type ] &&
                                dataPriv.get( cur, "handle" );
                            if ( handle ) {
                                handle.apply( cur, data );
                            }

                            // Native handler
                            handle = ontype && cur[ ontype ];
                            if ( handle && handle.apply && acceptData( cur ) ) {
                                event.result = handle.apply( cur, data );
                                if ( event.result === false ) {
                                    event.preventDefault();
                                }
                            }
                        }
                        event.type = type;

                        // If nobody prevented the default action, do it now
                        if ( !onlyHandlers && !event.isDefaultPrevented() ) {

                            if ( ( !special._default ||
                                    special._default.apply( eventPath.pop(), data ) === false ) &&
                                acceptData( elem ) ) {

                                // Call a native DOM method on the target with the same name as the event.
                                // Don't do default actions on window, that's where global variables be (#6170)
                                if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

                                    // Don't re-trigger an onFOO event when we call its FOO() method
                                    tmp = elem[ ontype ];

                                    if ( tmp ) {
                                        elem[ ontype ] = null;
                                    }

                                    // Prevent re-triggering of the same event, since we already bubbled it above
                                    jQuery.event.triggered = type;

                                    if ( event.isPropagationStopped() ) {
                                        lastElement.addEventListener( type, stopPropagationCallback );
                                    }

                                    elem[ type ]();

                                    if ( event.isPropagationStopped() ) {
                                        lastElement.removeEventListener( type, stopPropagationCallback );
                                    }

                                    jQuery.event.triggered = undefined;

                                    if ( tmp ) {
                                        elem[ ontype ] = tmp;
                                    }
                                }
                            }
                        }

                        return event.result;
                    },

                    // Piggyback on a donor event to simulate a different one
                    // Used only for `focus(in | out)` events
                    simulate: function( type, elem, event ) {
                        var e = jQuery.extend(
                            new jQuery.Event(),
                            event,
                            {
                                type: type,
                                isSimulated: true
                            }
                        );

                        jQuery.event.trigger( e, null, elem );
                    }

                } );

                jQuery.fn.extend( {

                    trigger: function( type, data ) {
                        return this.each( function() {
                            jQuery.event.trigger( type, data, this );
                        } );
                    },
                    triggerHandler: function( type, data ) {
                        var elem = this[ 0 ];
                        if ( elem ) {
                            return jQuery.event.trigger( type, data, elem, true );
                        }
                    }
                } );


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
                if ( !support.focusin ) {
                    jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

                        // Attach a single capturing handler on the document while someone wants focusin/focusout
                        var handler = function( event ) {
                            jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
                        };

                        jQuery.event.special[ fix ] = {
                            setup: function() {

                                // Handle: regular nodes (via `this.ownerDocument`), window
                                // (via `this.document`) & document (via `this`).
                                var doc = this.ownerDocument || this.document || this,
                                    attaches = dataPriv.access( doc, fix );

                                if ( !attaches ) {
                                    doc.addEventListener( orig, handler, true );
                                }
                                dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
                            },
                            teardown: function() {
                                var doc = this.ownerDocument || this.document || this,
                                    attaches = dataPriv.access( doc, fix ) - 1;

                                if ( !attaches ) {
                                    doc.removeEventListener( orig, handler, true );
                                    dataPriv.remove( doc, fix );

                                } else {
                                    dataPriv.access( doc, fix, attaches );
                                }
                            }
                        };
                    } );
                }
                var location = window.location;

                var nonce = { guid: Date.now() };

                var rquery = ( /\?/ );



// Cross-browser xml parsing
                jQuery.parseXML = function( data ) {
                    var xml;
                    if ( !data || typeof data !== "string" ) {
                        return null;
                    }

                    // Support: IE 9 - 11 only
                    // IE throws on parseFromString with invalid input.
                    try {
                        xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
                    } catch ( e ) {
                        xml = undefined;
                    }

                    if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
                        jQuery.error( "Invalid XML: " + data );
                    }
                    return xml;
                };


                var
                    rbracket = /\[\]$/,
                    rCRLF = /\r?\n/g,
                    rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
                    rsubmittable = /^(?:input|select|textarea|keygen)/i;

                function buildParams( prefix, obj, traditional, add ) {
                    var name;

                    if ( Array.isArray( obj ) ) {

                        // Serialize array item.
                        jQuery.each( obj, function( i, v ) {
                            if ( traditional || rbracket.test( prefix ) ) {

                                // Treat each array item as a scalar.
                                add( prefix, v );

                            } else {

                                // Item is non-scalar (array or object), encode its numeric index.
                                buildParams(
                                    prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
                                    v,
                                    traditional,
                                    add
                                );
                            }
                        } );

                    } else if ( !traditional && toType( obj ) === "object" ) {

                        // Serialize object item.
                        for ( name in obj ) {
                            buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
                        }

                    } else {

                        // Serialize scalar item.
                        add( prefix, obj );
                    }
                }

// Serialize an array of form elements or a set of
// key/values into a query string
                jQuery.param = function( a, traditional ) {
                    var prefix,
                        s = [],
                        add = function( key, valueOrFunction ) {

                            // If value is a function, invoke it and use its return value
                            var value = isFunction( valueOrFunction ) ?
                                valueOrFunction() :
                                valueOrFunction;

                            s[ s.length ] = encodeURIComponent( key ) + "=" +
                                encodeURIComponent( value == null ? "" : value );
                        };

                    if ( a == null ) {
                        return "";
                    }

                    // If an array was passed in, assume that it is an array of form elements.
                    if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

                        // Serialize the form elements
                        jQuery.each( a, function() {
                            add( this.name, this.value );
                        } );

                    } else {

                        // If traditional, encode the "old" way (the way 1.3.2 or older
                        // did it), otherwise encode params recursively.
                        for ( prefix in a ) {
                            buildParams( prefix, a[ prefix ], traditional, add );
                        }
                    }

                    // Return the resulting serialization
                    return s.join( "&" );
                };

                jQuery.fn.extend( {
                    serialize: function() {
                        return jQuery.param( this.serializeArray() );
                    },
                    serializeArray: function() {
                        return this.map( function() {

                            // Can add propHook for "elements" to filter or add form elements
                            var elements = jQuery.prop( this, "elements" );
                            return elements ? jQuery.makeArray( elements ) : this;
                        } )
                            .filter( function() {
                                var type = this.type;

                                // Use .is( ":disabled" ) so that fieldset[disabled] works
                                return this.name && !jQuery( this ).is( ":disabled" ) &&
                                    rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
                                    ( this.checked || !rcheckableType.test( type ) );
                            } )
                            .map( function( _i, elem ) {
                                var val = jQuery( this ).val();

                                if ( val == null ) {
                                    return null;
                                }

                                if ( Array.isArray( val ) ) {
                                    return jQuery.map( val, function( val ) {
                                        return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
                                    } );
                                }

                                return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
                            } ).get();
                    }
                } );


                var
                    r20 = /%20/g,
                    rhash = /#.*$/,
                    rantiCache = /([?&])_=[^&]*/,
                    rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

                    // #7653, #8125, #8152: local protocol detection
                    rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
                    rnoContent = /^(?:GET|HEAD)$/,
                    rprotocol = /^\/\//,

                    /* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
                    prefilters = {},

                    /* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
                    transports = {},

                    // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
                    allTypes = "*/".concat( "*" ),

                    // Anchor tag for parsing the document origin
                    originAnchor = document.createElement( "a" );
                originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
                function addToPrefiltersOrTransports( structure ) {

                    // dataTypeExpression is optional and defaults to "*"
                    return function( dataTypeExpression, func ) {

                        if ( typeof dataTypeExpression !== "string" ) {
                            func = dataTypeExpression;
                            dataTypeExpression = "*";
                        }

                        var dataType,
                            i = 0,
                            dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

                        if ( isFunction( func ) ) {

                            // For each dataType in the dataTypeExpression
                            while ( ( dataType = dataTypes[ i++ ] ) ) {

                                // Prepend if requested
                                if ( dataType[ 0 ] === "+" ) {
                                    dataType = dataType.slice( 1 ) || "*";
                                    ( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

                                    // Otherwise append
                                } else {
                                    ( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
                                }
                            }
                        }
                    };
                }

// Base inspection function for prefilters and transports
                function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

                    var inspected = {},
                        seekingTransport = ( structure === transports );

                    function inspect( dataType ) {
                        var selected;
                        inspected[ dataType ] = true;
                        jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
                            var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
                            if ( typeof dataTypeOrTransport === "string" &&
                                !seekingTransport && !inspected[ dataTypeOrTransport ] ) {

                                options.dataTypes.unshift( dataTypeOrTransport );
                                inspect( dataTypeOrTransport );
                                return false;
                            } else if ( seekingTransport ) {
                                return !( selected = dataTypeOrTransport );
                            }
                        } );
                        return selected;
                    }

                    return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
                }

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
                function ajaxExtend( target, src ) {
                    var key, deep,
                        flatOptions = jQuery.ajaxSettings.flatOptions || {};

                    for ( key in src ) {
                        if ( src[ key ] !== undefined ) {
                            ( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
                        }
                    }
                    if ( deep ) {
                        jQuery.extend( true, target, deep );
                    }

                    return target;
                }

                /* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
                function ajaxHandleResponses( s, jqXHR, responses ) {

                    var ct, type, finalDataType, firstDataType,
                        contents = s.contents,
                        dataTypes = s.dataTypes;

                    // Remove auto dataType and get content-type in the process
                    while ( dataTypes[ 0 ] === "*" ) {
                        dataTypes.shift();
                        if ( ct === undefined ) {
                            ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
                        }
                    }

                    // Check if we're dealing with a known content-type
                    if ( ct ) {
                        for ( type in contents ) {
                            if ( contents[ type ] && contents[ type ].test( ct ) ) {
                                dataTypes.unshift( type );
                                break;
                            }
                        }
                    }

                    // Check to see if we have a response for the expected dataType
                    if ( dataTypes[ 0 ] in responses ) {
                        finalDataType = dataTypes[ 0 ];
                    } else {

                        // Try convertible dataTypes
                        for ( type in responses ) {
                            if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
                                finalDataType = type;
                                break;
                            }
                            if ( !firstDataType ) {
                                firstDataType = type;
                            }
                        }

                        // Or just use first one
                        finalDataType = finalDataType || firstDataType;
                    }

                    // If we found a dataType
                    // We add the dataType to the list if needed
                    // and return the corresponding response
                    if ( finalDataType ) {
                        if ( finalDataType !== dataTypes[ 0 ] ) {
                            dataTypes.unshift( finalDataType );
                        }
                        return responses[ finalDataType ];
                    }
                }

                /* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
                function ajaxConvert( s, response, jqXHR, isSuccess ) {
                    var conv2, current, conv, tmp, prev,
                        converters = {},

                        // Work with a copy of dataTypes in case we need to modify it for conversion
                        dataTypes = s.dataTypes.slice();

                    // Create converters map with lowercased keys
                    if ( dataTypes[ 1 ] ) {
                        for ( conv in s.converters ) {
                            converters[ conv.toLowerCase() ] = s.converters[ conv ];
                        }
                    }

                    current = dataTypes.shift();

                    // Convert to each sequential dataType
                    while ( current ) {

                        if ( s.responseFields[ current ] ) {
                            jqXHR[ s.responseFields[ current ] ] = response;
                        }

                        // Apply the dataFilter if provided
                        if ( !prev && isSuccess && s.dataFilter ) {
                            response = s.dataFilter( response, s.dataType );
                        }

                        prev = current;
                        current = dataTypes.shift();

                        if ( current ) {

                            // There's only work to do if current dataType is non-auto
                            if ( current === "*" ) {

                                current = prev;

                                // Convert response if prev dataType is non-auto and differs from current
                            } else if ( prev !== "*" && prev !== current ) {

                                // Seek a direct converter
                                conv = converters[ prev + " " + current ] || converters[ "* " + current ];

                                // If none found, seek a pair
                                if ( !conv ) {
                                    for ( conv2 in converters ) {

                                        // If conv2 outputs current
                                        tmp = conv2.split( " " );
                                        if ( tmp[ 1 ] === current ) {

                                            // If prev can be converted to accepted input
                                            conv = converters[ prev + " " + tmp[ 0 ] ] ||
                                                converters[ "* " + tmp[ 0 ] ];
                                            if ( conv ) {

                                                // Condense equivalence converters
                                                if ( conv === true ) {
                                                    conv = converters[ conv2 ];

                                                    // Otherwise, insert the intermediate dataType
                                                } else if ( converters[ conv2 ] !== true ) {
                                                    current = tmp[ 0 ];
                                                    dataTypes.unshift( tmp[ 1 ] );
                                                }
                                                break;
                                            }
                                        }
                                    }
                                }

                                // Apply converter (if not an equivalence)
                                if ( conv !== true ) {

                                    // Unless errors are allowed to bubble, catch and return them
                                    if ( conv && s.throws ) {
                                        response = conv( response );
                                    } else {
                                        try {
                                            response = conv( response );
                                        } catch ( e ) {
                                            return {
                                                state: "parsererror",
                                                error: conv ? e : "No conversion from " + prev + " to " + current
                                            };
                                        }
                                    }
                                }
                            }
                        }
                    }

                    return { state: "success", data: response };
                }

                jQuery.extend( {

                    // Counter for holding the number of active queries
                    active: 0,

                    // Last-Modified header cache for next request
                    lastModified: {},
                    etag: {},

                    ajaxSettings: {
                        url: location.href,
                        type: "GET",
                        isLocal: rlocalProtocol.test( location.protocol ),
                        global: true,
                        processData: true,
                        async: true,
                        contentType: "application/x-www-form-urlencoded; charset=UTF-8",

                        /*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

                        accepts: {
                            "*": allTypes,
                            text: "text/plain",
                            html: "text/html",
                            xml: "application/xml, text/xml",
                            json: "application/json, text/javascript"
                        },

                        contents: {
                            xml: /\bxml\b/,
                            html: /\bhtml/,
                            json: /\bjson\b/
                        },

                        responseFields: {
                            xml: "responseXML",
                            text: "responseText",
                            json: "responseJSON"
                        },

                        // Data converters
                        // Keys separate source (or catchall "*") and destination types with a single space
                        converters: {

                            // Convert anything to text
                            "* text": String,

                            // Text to html (true = no transformation)
                            "text html": true,

                            // Evaluate text as a json expression
                            "text json": JSON.parse,

                            // Parse text as xml
                            "text xml": jQuery.parseXML
                        },

                        // For options that shouldn't be deep extended:
                        // you can add your own custom options here if
                        // and when you create one that shouldn't be
                        // deep extended (see ajaxExtend)
                        flatOptions: {
                            url: true,
                            context: true
                        }
                    },

                    // Creates a full fledged settings object into target
                    // with both ajaxSettings and settings fields.
                    // If target is omitted, writes into ajaxSettings.
                    ajaxSetup: function( target, settings ) {
                        return settings ?

                            // Building a settings object
                            ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

                            // Extending ajaxSettings
                            ajaxExtend( jQuery.ajaxSettings, target );
                    },

                    ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
                    ajaxTransport: addToPrefiltersOrTransports( transports ),

                    // Main method
                    ajax: function( url, options ) {

                        // If url is an object, simulate pre-1.5 signature
                        if ( typeof url === "object" ) {
                            options = url;
                            url = undefined;
                        }

                        // Force options to be an object
                        options = options || {};

                        var transport,

                            // URL without anti-cache param
                            cacheURL,

                            // Response headers
                            responseHeadersString,
                            responseHeaders,

                            // timeout handle
                            timeoutTimer,

                            // Url cleanup var
                            urlAnchor,

                            // Request state (becomes false upon send and true upon completion)
                            completed,

                            // To know if global events are to be dispatched
                            fireGlobals,

                            // Loop variable
                            i,

                            // uncached part of the url
                            uncached,

                            // Create the final options object
                            s = jQuery.ajaxSetup( {}, options ),

                            // Callbacks context
                            callbackContext = s.context || s,

                            // Context for global events is callbackContext if it is a DOM node or jQuery collection
                            globalEventContext = s.context &&
                            ( callbackContext.nodeType || callbackContext.jquery ) ?
                                jQuery( callbackContext ) :
                                jQuery.event,

                            // Deferreds
                            deferred = jQuery.Deferred(),
                            completeDeferred = jQuery.Callbacks( "once memory" ),

                            // Status-dependent callbacks
                            statusCode = s.statusCode || {},

                            // Headers (they are sent all at once)
                            requestHeaders = {},
                            requestHeadersNames = {},

                            // Default abort message
                            strAbort = "canceled",

                            // Fake xhr
                            jqXHR = {
                                readyState: 0,

                                // Builds headers hashtable if needed
                                getResponseHeader: function( key ) {
                                    var match;
                                    if ( completed ) {
                                        if ( !responseHeaders ) {
                                            responseHeaders = {};
                                            while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
                                                responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
                                                    ( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
                                                        .concat( match[ 2 ] );
                                            }
                                        }
                                        match = responseHeaders[ key.toLowerCase() + " " ];
                                    }
                                    return match == null ? null : match.join( ", " );
                                },

                                // Raw string
                                getAllResponseHeaders: function() {
                                    return completed ? responseHeadersString : null;
                                },

                                // Caches the header
                                setRequestHeader: function( name, value ) {
                                    if ( completed == null ) {
                                        name = requestHeadersNames[ name.toLowerCase() ] =
                                            requestHeadersNames[ name.toLowerCase() ] || name;
                                        requestHeaders[ name ] = value;
                                    }
                                    return this;
                                },

                                // Overrides response content-type header
                                overrideMimeType: function( type ) {
                                    if ( completed == null ) {
                                        s.mimeType = type;
                                    }
                                    return this;
                                },

                                // Status-dependent callbacks
                                statusCode: function( map ) {
                                    var code;
                                    if ( map ) {
                                        if ( completed ) {

                                            // Execute the appropriate callbacks
                                            jqXHR.always( map[ jqXHR.status ] );
                                        } else {

                                            // Lazy-add the new callbacks in a way that preserves old ones
                                            for ( code in map ) {
                                                statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
                                            }
                                        }
                                    }
                                    return this;
                                },

                                // Cancel the request
                                abort: function( statusText ) {
                                    var finalText = statusText || strAbort;
                                    if ( transport ) {
                                        transport.abort( finalText );
                                    }
                                    done( 0, finalText );
                                    return this;
                                }
                            };

                        // Attach deferreds
                        deferred.promise( jqXHR );

                        // Add protocol if not provided (prefilters might expect it)
                        // Handle falsy url in the settings object (#10093: consistency with old signature)
                        // We also use the url parameter if available
                        s.url = ( ( url || s.url || location.href ) + "" )
                            .replace( rprotocol, location.protocol + "//" );

                        // Alias method option to type as per ticket #12004
                        s.type = options.method || options.type || s.method || s.type;

                        // Extract dataTypes list
                        s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

                        // A cross-domain request is in order when the origin doesn't match the current origin.
                        if ( s.crossDomain == null ) {
                            urlAnchor = document.createElement( "a" );

                            // Support: IE <=8 - 11, Edge 12 - 15
                            // IE throws exception on accessing the href property if url is malformed,
                            // e.g. http://example.com:80x/
                            try {
                                urlAnchor.href = s.url;

                                // Support: IE <=8 - 11 only
                                // Anchor's host property isn't correctly set when s.url is relative
                                urlAnchor.href = urlAnchor.href;
                                s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
                                    urlAnchor.protocol + "//" + urlAnchor.host;
                            } catch ( e ) {

                                // If there is an error parsing the URL, assume it is crossDomain,
                                // it can be rejected by the transport if it is invalid
                                s.crossDomain = true;
                            }
                        }

                        // Convert data if not already a string
                        if ( s.data && s.processData && typeof s.data !== "string" ) {
                            s.data = jQuery.param( s.data, s.traditional );
                        }

                        // Apply prefilters
                        inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

                        // If request was aborted inside a prefilter, stop there
                        if ( completed ) {
                            return jqXHR;
                        }

                        // We can fire global events as of now if asked to
                        // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
                        fireGlobals = jQuery.event && s.global;

                        // Watch for a new set of requests
                        if ( fireGlobals && jQuery.active++ === 0 ) {
                            jQuery.event.trigger( "ajaxStart" );
                        }

                        // Uppercase the type
                        s.type = s.type.toUpperCase();

                        // Determine if request has content
                        s.hasContent = !rnoContent.test( s.type );

                        // Save the URL in case we're toying with the If-Modified-Since
                        // and/or If-None-Match header later on
                        // Remove hash to simplify url manipulation
                        cacheURL = s.url.replace( rhash, "" );

                        // More options handling for requests with no content
                        if ( !s.hasContent ) {

                            // Remember the hash so we can put it back
                            uncached = s.url.slice( cacheURL.length );

                            // If data is available and should be processed, append data to url
                            if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
                                cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

                                // #9682: remove data so that it's not used in an eventual retry
                                delete s.data;
                            }

                            // Add or update anti-cache param if needed
                            if ( s.cache === false ) {
                                cacheURL = cacheURL.replace( rantiCache, "$1" );
                                uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce.guid++ ) +
                                    uncached;
                            }

                            // Put hash and anti-cache on the URL that will be requested (gh-1732)
                            s.url = cacheURL + uncached;

                            // Change '%20' to '+' if this is encoded form body content (gh-2658)
                        } else if ( s.data && s.processData &&
                            ( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
                            s.data = s.data.replace( r20, "+" );
                        }

                        // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                        if ( s.ifModified ) {
                            if ( jQuery.lastModified[ cacheURL ] ) {
                                jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
                            }
                            if ( jQuery.etag[ cacheURL ] ) {
                                jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
                            }
                        }

                        // Set the correct header, if data is being sent
                        if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
                            jqXHR.setRequestHeader( "Content-Type", s.contentType );
                        }

                        // Set the Accepts header for the server, depending on the dataType
                        jqXHR.setRequestHeader(
                            "Accept",
                            s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
                                s.accepts[ s.dataTypes[ 0 ] ] +
                                ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
                                s.accepts[ "*" ]
                        );

                        // Check for headers option
                        for ( i in s.headers ) {
                            jqXHR.setRequestHeader( i, s.headers[ i ] );
                        }

                        // Allow custom headers/mimetypes and early abort
                        if ( s.beforeSend &&
                            ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

                            // Abort if not done already and return
                            return jqXHR.abort();
                        }

                        // Aborting is no longer a cancellation
                        strAbort = "abort";

                        // Install callbacks on deferreds
                        completeDeferred.add( s.complete );
                        jqXHR.done( s.success );
                        jqXHR.fail( s.error );

                        // Get transport
                        transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

                        // If no transport, we auto-abort
                        if ( !transport ) {
                            done( -1, "No Transport" );
                        } else {
                            jqXHR.readyState = 1;

                            // Send global event
                            if ( fireGlobals ) {
                                globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
                            }

                            // If request was aborted inside ajaxSend, stop there
                            if ( completed ) {
                                return jqXHR;
                            }

                            // Timeout
                            if ( s.async && s.timeout > 0 ) {
                                timeoutTimer = window.setTimeout( function() {
                                    jqXHR.abort( "timeout" );
                                }, s.timeout );
                            }

                            try {
                                completed = false;
                                transport.send( requestHeaders, done );
                            } catch ( e ) {

                                // Rethrow post-completion exceptions
                                if ( completed ) {
                                    throw e;
                                }

                                // Propagate others as results
                                done( -1, e );
                            }
                        }

                        // Callback for when everything is done
                        function done( status, nativeStatusText, responses, headers ) {
                            var isSuccess, success, error, response, modified,
                                statusText = nativeStatusText;

                            // Ignore repeat invocations
                            if ( completed ) {
                                return;
                            }

                            completed = true;

                            // Clear timeout if it exists
                            if ( timeoutTimer ) {
                                window.clearTimeout( timeoutTimer );
                            }

                            // Dereference transport for early garbage collection
                            // (no matter how long the jqXHR object will be used)
                            transport = undefined;

                            // Cache response headers
                            responseHeadersString = headers || "";

                            // Set readyState
                            jqXHR.readyState = status > 0 ? 4 : 0;

                            // Determine if successful
                            isSuccess = status >= 200 && status < 300 || status === 304;

                            // Get response data
                            if ( responses ) {
                                response = ajaxHandleResponses( s, jqXHR, responses );
                            }

                            // Use a noop converter for missing script
                            if ( !isSuccess && jQuery.inArray( "script", s.dataTypes ) > -1 ) {
                                s.converters[ "text script" ] = function() {};
                            }

                            // Convert no matter what (that way responseXXX fields are always set)
                            response = ajaxConvert( s, response, jqXHR, isSuccess );

                            // If successful, handle type chaining
                            if ( isSuccess ) {

                                // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                                if ( s.ifModified ) {
                                    modified = jqXHR.getResponseHeader( "Last-Modified" );
                                    if ( modified ) {
                                        jQuery.lastModified[ cacheURL ] = modified;
                                    }
                                    modified = jqXHR.getResponseHeader( "etag" );
                                    if ( modified ) {
                                        jQuery.etag[ cacheURL ] = modified;
                                    }
                                }

                                // if no content
                                if ( status === 204 || s.type === "HEAD" ) {
                                    statusText = "nocontent";

                                    // if not modified
                                } else if ( status === 304 ) {
                                    statusText = "notmodified";

                                    // If we have data, let's convert it
                                } else {
                                    statusText = response.state;
                                    success = response.data;
                                    error = response.error;
                                    isSuccess = !error;
                                }
                            } else {

                                // Extract error from statusText and normalize for non-aborts
                                error = statusText;
                                if ( status || !statusText ) {
                                    statusText = "error";
                                    if ( status < 0 ) {
                                        status = 0;
                                    }
                                }
                            }

                            // Set data for the fake xhr object
                            jqXHR.status = status;
                            jqXHR.statusText = ( nativeStatusText || statusText ) + "";

                            // Success/Error
                            if ( isSuccess ) {
                                deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
                            } else {
                                deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
                            }

                            // Status-dependent callbacks
                            jqXHR.statusCode( statusCode );
                            statusCode = undefined;

                            if ( fireGlobals ) {
                                globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
                                    [ jqXHR, s, isSuccess ? success : error ] );
                            }

                            // Complete
                            completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

                            if ( fireGlobals ) {
                                globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

                                // Handle the global AJAX counter
                                if ( !( --jQuery.active ) ) {
                                    jQuery.event.trigger( "ajaxStop" );
                                }
                            }
                        }

                        return jqXHR;
                    },

                    getJSON: function( url, data, callback ) {
                        return jQuery.get( url, data, callback, "json" );
                    },

                    getScript: function( url, callback ) {
                        return jQuery.get( url, undefined, callback, "script" );
                    }
                } );

                jQuery.each( [ "get", "post" ], function( _i, method ) {
                    jQuery[ method ] = function( url, data, callback, type ) {

                        // Shift arguments if data argument was omitted
                        if ( isFunction( data ) ) {
                            type = type || callback;
                            callback = data;
                            data = undefined;
                        }

                        // The url can be an options object (which then must have .url)
                        return jQuery.ajax( jQuery.extend( {
                            url: url,
                            type: method,
                            dataType: type,
                            data: data,
                            success: callback
                        }, jQuery.isPlainObject( url ) && url ) );
                    };
                } );

                jQuery.ajaxPrefilter( function( s ) {
                    var i;
                    for ( i in s.headers ) {
                        if ( i.toLowerCase() === "content-type" ) {
                            s.contentType = s.headers[ i ] || "";
                        }
                    }
                } );


                jQuery._evalUrl = function( url, options, doc ) {
                    return jQuery.ajax( {
                        url: url,

                        // Make this explicit, since user can override this through ajaxSetup (#11264)
                        type: "GET",
                        dataType: "script",
                        cache: true,
                        async: false,
                        global: false,

                        // Only evaluate the response if it is successful (gh-4126)
                        // dataFilter is not invoked for failure responses, so using it instead
                        // of the default converter is kludgy but it works.
                        converters: {
                            "text script": function() {}
                        },
                        dataFilter: function( response ) {
                            jQuery.globalEval( response, options, doc );
                        }
                    } );
                };


                jQuery.fn.extend( {
                    wrapAll: function( html ) {
                        var wrap;

                        if ( this[ 0 ] ) {
                            if ( isFunction( html ) ) {
                                html = html.call( this[ 0 ] );
                            }

                            // The elements to wrap the target around
                            wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

                            if ( this[ 0 ].parentNode ) {
                                wrap.insertBefore( this[ 0 ] );
                            }

                            wrap.map( function() {
                                var elem = this;

                                while ( elem.firstElementChild ) {
                                    elem = elem.firstElementChild;
                                }

                                return elem;
                            } ).append( this );
                        }

                        return this;
                    },

                    wrapInner: function( html ) {
                        if ( isFunction( html ) ) {
                            return this.each( function( i ) {
                                jQuery( this ).wrapInner( html.call( this, i ) );
                            } );
                        }

                        return this.each( function() {
                            var self = jQuery( this ),
                                contents = self.contents();

                            if ( contents.length ) {
                                contents.wrapAll( html );

                            } else {
                                self.append( html );
                            }
                        } );
                    },

                    wrap: function( html ) {
                        var htmlIsFunction = isFunction( html );

                        return this.each( function( i ) {
                            jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
                        } );
                    },

                    unwrap: function( selector ) {
                        this.parent( selector ).not( "body" ).each( function() {
                            jQuery( this ).replaceWith( this.childNodes );
                        } );
                        return this;
                    }
                } );


                jQuery.expr.pseudos.hidden = function( elem ) {
                    return !jQuery.expr.pseudos.visible( elem );
                };
                jQuery.expr.pseudos.visible = function( elem ) {
                    return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
                };




                jQuery.ajaxSettings.xhr = function() {
                    try {
                        return new window.XMLHttpRequest();
                    } catch ( e ) {}
                };

                var xhrSuccessStatus = {

                        // File protocol always yields status code 0, assume 200
                        0: 200,

                        // Support: IE <=9 only
                        // #1450: sometimes IE returns 1223 when it should be 204
                        1223: 204
                    },
                    xhrSupported = jQuery.ajaxSettings.xhr();

                support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
                support.ajax = xhrSupported = !!xhrSupported;

                jQuery.ajaxTransport( function( options ) {
                    var callback, errorCallback;

                    // Cross domain only allowed if supported through XMLHttpRequest
                    if ( support.cors || xhrSupported && !options.crossDomain ) {
                        return {
                            send: function( headers, complete ) {
                                var i,
                                    xhr = options.xhr();

                                xhr.open(
                                    options.type,
                                    options.url,
                                    options.async,
                                    options.username,
                                    options.password
                                );

                                // Apply custom fields if provided
                                if ( options.xhrFields ) {
                                    for ( i in options.xhrFields ) {
                                        xhr[ i ] = options.xhrFields[ i ];
                                    }
                                }

                                // Override mime type if needed
                                if ( options.mimeType && xhr.overrideMimeType ) {
                                    xhr.overrideMimeType( options.mimeType );
                                }

                                // X-Requested-With header
                                // For cross-domain requests, seeing as conditions for a preflight are
                                // akin to a jigsaw puzzle, we simply never set it to be sure.
                                // (it can always be set on a per-request basis or even using ajaxSetup)
                                // For same-domain requests, won't change header if already provided.
                                if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
                                    headers[ "X-Requested-With" ] = "XMLHttpRequest";
                                }

                                // Set headers
                                for ( i in headers ) {
                                    xhr.setRequestHeader( i, headers[ i ] );
                                }

                                // Callback
                                callback = function( type ) {
                                    return function() {
                                        if ( callback ) {
                                            callback = errorCallback = xhr.onload =
                                                xhr.onerror = xhr.onabort = xhr.ontimeout =
                                                    xhr.onreadystatechange = null;

                                            if ( type === "abort" ) {
                                                xhr.abort();
                                            } else if ( type === "error" ) {

                                                // Support: IE <=9 only
                                                // On a manual native abort, IE9 throws
                                                // errors on any property access that is not readyState
                                                if ( typeof xhr.status !== "number" ) {
                                                    complete( 0, "error" );
                                                } else {
                                                    complete(

                                                        // File: protocol always yields status 0; see #8605, #14207
                                                        xhr.status,
                                                        xhr.statusText
                                                    );
                                                }
                                            } else {
                                                complete(
                                                    xhrSuccessStatus[ xhr.status ] || xhr.status,
                                                    xhr.statusText,

                                                    // Support: IE <=9 only
                                                    // IE9 has no XHR2 but throws on binary (trac-11426)
                                                    // For XHR2 non-text, let the caller handle it (gh-2498)
                                                    ( xhr.responseType || "text" ) !== "text"  ||
                                                    typeof xhr.responseText !== "string" ?
                                                        { binary: xhr.response } :
                                                        { text: xhr.responseText },
                                                    xhr.getAllResponseHeaders()
                                                );
                                            }
                                        }
                                    };
                                };

                                // Listen to events
                                xhr.onload = callback();
                                errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

                                // Support: IE 9 only
                                // Use onreadystatechange to replace onabort
                                // to handle uncaught aborts
                                if ( xhr.onabort !== undefined ) {
                                    xhr.onabort = errorCallback;
                                } else {
                                    xhr.onreadystatechange = function() {

                                        // Check readyState before timeout as it changes
                                        if ( xhr.readyState === 4 ) {

                                            // Allow onerror to be called first,
                                            // but that will not handle a native abort
                                            // Also, save errorCallback to a variable
                                            // as xhr.onerror cannot be accessed
                                            window.setTimeout( function() {
                                                if ( callback ) {
                                                    errorCallback();
                                                }
                                            } );
                                        }
                                    };
                                }

                                // Create the abort callback
                                callback = callback( "abort" );

                                try {

                                    // Do send the request (this may raise an exception)
                                    xhr.send( options.hasContent && options.data || null );
                                } catch ( e ) {

                                    // #14683: Only rethrow if this hasn't been notified as an error yet
                                    if ( callback ) {
                                        throw e;
                                    }
                                }
                            },

                            abort: function() {
                                if ( callback ) {
                                    callback();
                                }
                            }
                        };
                    }
                } );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
                jQuery.ajaxPrefilter( function( s ) {
                    if ( s.crossDomain ) {
                        s.contents.script = false;
                    }
                } );

// Install script dataType
                jQuery.ajaxSetup( {
                    accepts: {
                        script: "text/javascript, application/javascript, " +
                            "application/ecmascript, application/x-ecmascript"
                    },
                    contents: {
                        script: /\b(?:java|ecma)script\b/
                    },
                    converters: {
                        "text script": function( text ) {
                            jQuery.globalEval( text );
                            return text;
                        }
                    }
                } );

// Handle cache's special case and crossDomain
                jQuery.ajaxPrefilter( "script", function( s ) {
                    if ( s.cache === undefined ) {
                        s.cache = false;
                    }
                    if ( s.crossDomain ) {
                        s.type = "GET";
                    }
                } );

// Bind script tag hack transport
                jQuery.ajaxTransport( "script", function( s ) {

                    // This transport only deals with cross domain or forced-by-attrs requests
                    if ( s.crossDomain || s.scriptAttrs ) {
                        var script, callback;
                        return {
                            send: function( _, complete ) {
                                script = jQuery( "<script>" )
                                    .attr( s.scriptAttrs || {} )
                                    .prop( { charset: s.scriptCharset, src: s.url } )
                                    .on( "load error", callback = function( evt ) {
                                        script.remove();
                                        callback = null;
                                        if ( evt ) {
                                            complete( evt.type === "error" ? 404 : 200, evt.type );
                                        }
                                    } );

                                // Use native DOM manipulation to avoid our domManip AJAX trickery
                                document.head.appendChild( script[ 0 ] );
                            },
                            abort: function() {
                                if ( callback ) {
                                    callback();
                                }
                            }
                        };
                    }
                } );




                var oldCallbacks = [],
                    rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
                jQuery.ajaxSetup( {
                    jsonp: "callback",
                    jsonpCallback: function() {
                        var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce.guid++ ) );
                        this[ callback ] = true;
                        return callback;
                    }
                } );

// Detect, normalize options and install callbacks for jsonp requests
                jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

                    var callbackName, overwritten, responseContainer,
                        jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
                                "url" :
                                typeof s.data === "string" &&
                                ( s.contentType || "" )
                                    .indexOf( "application/x-www-form-urlencoded" ) === 0 &&
                                rjsonp.test( s.data ) && "data"
                        );

                    // Handle iff the expected data type is "jsonp" or we have a parameter to set
                    if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

                        // Get callback name, remembering preexisting value associated with it
                        callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
                            s.jsonpCallback() :
                            s.jsonpCallback;

                        // Insert callback into url or form data
                        if ( jsonProp ) {
                            s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
                        } else if ( s.jsonp !== false ) {
                            s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
                        }

                        // Use data converter to retrieve json after script execution
                        s.converters[ "script json" ] = function() {
                            if ( !responseContainer ) {
                                jQuery.error( callbackName + " was not called" );
                            }
                            return responseContainer[ 0 ];
                        };

                        // Force json dataType
                        s.dataTypes[ 0 ] = "json";

                        // Install callback
                        overwritten = window[ callbackName ];
                        window[ callbackName ] = function() {
                            responseContainer = arguments;
                        };

                        // Clean-up function (fires after converters)
                        jqXHR.always( function() {

                            // If previous value didn't exist - remove it
                            if ( overwritten === undefined ) {
                                jQuery( window ).removeProp( callbackName );

                                // Otherwise restore preexisting value
                            } else {
                                window[ callbackName ] = overwritten;
                            }

                            // Save back as free
                            if ( s[ callbackName ] ) {

                                // Make sure that re-using the options doesn't screw things around
                                s.jsonpCallback = originalSettings.jsonpCallback;

                                // Save the callback name for future use
                                oldCallbacks.push( callbackName );
                            }

                            // Call if it was a function and we have a response
                            if ( responseContainer && isFunction( overwritten ) ) {
                                overwritten( responseContainer[ 0 ] );
                            }

                            responseContainer = overwritten = undefined;
                        } );

                        // Delegate to script
                        return "script";
                    }
                } );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
                support.createHTMLDocument = ( function() {
                    var body = document.implementation.createHTMLDocument( "" ).body;
                    body.innerHTML = "<form></form><form></form>";
                    return body.childNodes.length === 2;
                } )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
                jQuery.parseHTML = function( data, context, keepScripts ) {
                    if ( typeof data !== "string" ) {
                        return [];
                    }
                    if ( typeof context === "boolean" ) {
                        keepScripts = context;
                        context = false;
                    }

                    var base, parsed, scripts;

                    if ( !context ) {

                        // Stop scripts or inline event handlers from being executed immediately
                        // by using document.implementation
                        if ( support.createHTMLDocument ) {
                            context = document.implementation.createHTMLDocument( "" );

                            // Set the base href for the created document
                            // so any parsed elements with URLs
                            // are based on the document's URL (gh-2965)
                            base = context.createElement( "base" );
                            base.href = document.location.href;
                            context.head.appendChild( base );
                        } else {
                            context = document;
                        }
                    }

                    parsed = rsingleTag.exec( data );
                    scripts = !keepScripts && [];

                    // Single tag
                    if ( parsed ) {
                        return [ context.createElement( parsed[ 1 ] ) ];
                    }

                    parsed = buildFragment( [ data ], context, scripts );

                    if ( scripts && scripts.length ) {
                        jQuery( scripts ).remove();
                    }

                    return jQuery.merge( [], parsed.childNodes );
                };


                /**
                 * Load a url into a page
                 */
                jQuery.fn.load = function( url, params, callback ) {
                    var selector, type, response,
                        self = this,
                        off = url.indexOf( " " );

                    if ( off > -1 ) {
                        selector = stripAndCollapse( url.slice( off ) );
                        url = url.slice( 0, off );
                    }

                    // If it's a function
                    if ( isFunction( params ) ) {

                        // We assume that it's the callback
                        callback = params;
                        params = undefined;

                        // Otherwise, build a param string
                    } else if ( params && typeof params === "object" ) {
                        type = "POST";
                    }

                    // If we have elements to modify, make the request
                    if ( self.length > 0 ) {
                        jQuery.ajax( {
                            url: url,

                            // If "type" variable is undefined, then "GET" method will be used.
                            // Make value of this field explicit since
                            // user can override it through ajaxSetup method
                            type: type || "GET",
                            dataType: "html",
                            data: params
                        } ).done( function( responseText ) {

                            // Save response for use in complete callback
                            response = arguments;

                            self.html( selector ?

                                // If a selector was specified, locate the right elements in a dummy div
                                // Exclude scripts to avoid IE 'Permission Denied' errors
                                jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

                                // Otherwise use the full result
                                responseText );

                            // If the request succeeds, this function gets "data", "status", "jqXHR"
                            // but they are ignored because response was set above.
                            // If it fails, this function gets "jqXHR", "status", "error"
                        } ).always( callback && function( jqXHR, status ) {
                            self.each( function() {
                                callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
                            } );
                        } );
                    }

                    return this;
                };




                jQuery.expr.pseudos.animated = function( elem ) {
                    return jQuery.grep( jQuery.timers, function( fn ) {
                        return elem === fn.elem;
                    } ).length;
                };




                jQuery.offset = {
                    setOffset: function( elem, options, i ) {
                        var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
                            position = jQuery.css( elem, "position" ),
                            curElem = jQuery( elem ),
                            props = {};

                        // Set position first, in-case top/left are set even on static elem
                        if ( position === "static" ) {
                            elem.style.position = "relative";
                        }

                        curOffset = curElem.offset();
                        curCSSTop = jQuery.css( elem, "top" );
                        curCSSLeft = jQuery.css( elem, "left" );
                        calculatePosition = ( position === "absolute" || position === "fixed" ) &&
                            ( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

                        // Need to be able to calculate position if either
                        // top or left is auto and position is either absolute or fixed
                        if ( calculatePosition ) {
                            curPosition = curElem.position();
                            curTop = curPosition.top;
                            curLeft = curPosition.left;

                        } else {
                            curTop = parseFloat( curCSSTop ) || 0;
                            curLeft = parseFloat( curCSSLeft ) || 0;
                        }

                        if ( isFunction( options ) ) {

                            // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
                            options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
                        }

                        if ( options.top != null ) {
                            props.top = ( options.top - curOffset.top ) + curTop;
                        }
                        if ( options.left != null ) {
                            props.left = ( options.left - curOffset.left ) + curLeft;
                        }

                        if ( "using" in options ) {
                            options.using.call( elem, props );

                        } else {
                            if ( typeof props.top === "number" ) {
                                props.top += "px";
                            }
                            if ( typeof props.left === "number" ) {
                                props.left += "px";
                            }
                            curElem.css( props );
                        }
                    }
                };

                jQuery.fn.extend( {

                    // offset() relates an element's border box to the document origin
                    offset: function( options ) {

                        // Preserve chaining for setter
                        if ( arguments.length ) {
                            return options === undefined ?
                                this :
                                this.each( function( i ) {
                                    jQuery.offset.setOffset( this, options, i );
                                } );
                        }

                        var rect, win,
                            elem = this[ 0 ];

                        if ( !elem ) {
                            return;
                        }

                        // Return zeros for disconnected and hidden (display: none) elements (gh-2310)
                        // Support: IE <=11 only
                        // Running getBoundingClientRect on a
                        // disconnected node in IE throws an error
                        if ( !elem.getClientRects().length ) {
                            return { top: 0, left: 0 };
                        }

                        // Get document-relative position by adding viewport scroll to viewport-relative gBCR
                        rect = elem.getBoundingClientRect();
                        win = elem.ownerDocument.defaultView;
                        return {
                            top: rect.top + win.pageYOffset,
                            left: rect.left + win.pageXOffset
                        };
                    },

                    // position() relates an element's margin box to its offset parent's padding box
                    // This corresponds to the behavior of CSS absolute positioning
                    position: function() {
                        if ( !this[ 0 ] ) {
                            return;
                        }

                        var offsetParent, offset, doc,
                            elem = this[ 0 ],
                            parentOffset = { top: 0, left: 0 };

                        // position:fixed elements are offset from the viewport, which itself always has zero offset
                        if ( jQuery.css( elem, "position" ) === "fixed" ) {

                            // Assume position:fixed implies availability of getBoundingClientRect
                            offset = elem.getBoundingClientRect();

                        } else {
                            offset = this.offset();

                            // Account for the *real* offset parent, which can be the document or its root element
                            // when a statically positioned element is identified
                            doc = elem.ownerDocument;
                            offsetParent = elem.offsetParent || doc.documentElement;
                            while ( offsetParent &&
                            ( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
                            jQuery.css( offsetParent, "position" ) === "static" ) {

                                offsetParent = offsetParent.parentNode;
                            }
                            if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

                                // Incorporate borders into its offset, since they are outside its content origin
                                parentOffset = jQuery( offsetParent ).offset();
                                parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
                                parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
                            }
                        }

                        // Subtract parent offsets and element margins
                        return {
                            top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
                            left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
                        };
                    },

                    // This method will return documentElement in the following cases:
                    // 1) For the element inside the iframe without offsetParent, this method will return
                    //    documentElement of the parent window
                    // 2) For the hidden or detached element
                    // 3) For body or html element, i.e. in case of the html node - it will return itself
                    //
                    // but those exceptions were never presented as a real life use-cases
                    // and might be considered as more preferable results.
                    //
                    // This logic, however, is not guaranteed and can change at any point in the future
                    offsetParent: function() {
                        return this.map( function() {
                            var offsetParent = this.offsetParent;

                            while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
                                offsetParent = offsetParent.offsetParent;
                            }

                            return offsetParent || documentElement;
                        } );
                    }
                } );

// Create scrollLeft and scrollTop methods
                jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
                    var top = "pageYOffset" === prop;

                    jQuery.fn[ method ] = function( val ) {
                        return access( this, function( elem, method, val ) {

                            // Coalesce documents and windows
                            var win;
                            if ( isWindow( elem ) ) {
                                win = elem;
                            } else if ( elem.nodeType === 9 ) {
                                win = elem.defaultView;
                            }

                            if ( val === undefined ) {
                                return win ? win[ prop ] : elem[ method ];
                            }

                            if ( win ) {
                                win.scrollTo(
                                    !top ? val : win.pageXOffset,
                                    top ? val : win.pageYOffset
                                );

                            } else {
                                elem[ method ] = val;
                            }
                        }, method, val, arguments.length );
                    };
                } );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
                jQuery.each( [ "top", "left" ], function( _i, prop ) {
                    jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
                        function( elem, computed ) {
                            if ( computed ) {
                                computed = curCSS( elem, prop );

                                // If curCSS returns percentage, fallback to offset
                                return rnumnonpx.test( computed ) ?
                                    jQuery( elem ).position()[ prop ] + "px" :
                                    computed;
                            }
                        }
                    );
                } );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
                jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
                    jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
                        function( defaultExtra, funcName ) {

                            // Margin is only for outerHeight, outerWidth
                            jQuery.fn[ funcName ] = function( margin, value ) {
                                var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
                                    extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

                                return access( this, function( elem, type, value ) {
                                    var doc;

                                    if ( isWindow( elem ) ) {

                                        // $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
                                        return funcName.indexOf( "outer" ) === 0 ?
                                            elem[ "inner" + name ] :
                                            elem.document.documentElement[ "client" + name ];
                                    }

                                    // Get document width or height
                                    if ( elem.nodeType === 9 ) {
                                        doc = elem.documentElement;

                                        // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
                                        // whichever is greatest
                                        return Math.max(
                                            elem.body[ "scroll" + name ], doc[ "scroll" + name ],
                                            elem.body[ "offset" + name ], doc[ "offset" + name ],
                                            doc[ "client" + name ]
                                        );
                                    }

                                    return value === undefined ?

                                        // Get width or height on the element, requesting but not forcing parseFloat
                                        jQuery.css( elem, type, extra ) :

                                        // Set width or height on the element
                                        jQuery.style( elem, type, value, extra );
                                }, type, chainable ? margin : undefined, chainable );
                            };
                        } );
                } );


                jQuery.each( [
                    "ajaxStart",
                    "ajaxStop",
                    "ajaxComplete",
                    "ajaxError",
                    "ajaxSuccess",
                    "ajaxSend"
                ], function( _i, type ) {
                    jQuery.fn[ type ] = function( fn ) {
                        return this.on( type, fn );
                    };
                } );




                jQuery.fn.extend( {

                    bind: function( types, data, fn ) {
                        return this.on( types, null, data, fn );
                    },
                    unbind: function( types, fn ) {
                        return this.off( types, null, fn );
                    },

                    delegate: function( selector, types, data, fn ) {
                        return this.on( types, selector, data, fn );
                    },
                    undelegate: function( selector, types, fn ) {

                        // ( namespace ) or ( selector, types [, fn] )
                        return arguments.length === 1 ?
                            this.off( selector, "**" ) :
                            this.off( types, selector || "**", fn );
                    },

                    hover: function( fnOver, fnOut ) {
                        return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
                    }
                } );

                jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
                        "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
                        "change select submit keydown keypress keyup contextmenu" ).split( " " ),
                    function( _i, name ) {

                        // Handle event binding
                        jQuery.fn[ name ] = function( data, fn ) {
                            return arguments.length > 0 ?
                                this.on( name, null, data, fn ) :
                                this.trigger( name );
                        };
                    } );




// Support: Android <=4.0 only
// Make sure we trim BOM and NBSP
                var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
                jQuery.proxy = function( fn, context ) {
                    var tmp, args, proxy;

                    if ( typeof context === "string" ) {
                        tmp = fn[ context ];
                        context = fn;
                        fn = tmp;
                    }

                    // Quick check to determine if target is callable, in the spec
                    // this throws a TypeError, but we will just return undefined.
                    if ( !isFunction( fn ) ) {
                        return undefined;
                    }

                    // Simulated bind
                    args = slice.call( arguments, 2 );
                    proxy = function() {
                        return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
                    };

                    // Set the guid of unique handler to the same of original handler, so it can be removed
                    proxy.guid = fn.guid = fn.guid || jQuery.guid++;

                    return proxy;
                };

                jQuery.holdReady = function( hold ) {
                    if ( hold ) {
                        jQuery.readyWait++;
                    } else {
                        jQuery.ready( true );
                    }
                };
                jQuery.isArray = Array.isArray;
                jQuery.parseJSON = JSON.parse;
                jQuery.nodeName = nodeName;
                jQuery.isFunction = isFunction;
                jQuery.isWindow = isWindow;
                jQuery.camelCase = camelCase;
                jQuery.type = toType;

                jQuery.now = Date.now;

                jQuery.isNumeric = function( obj ) {

                    // As of jQuery 3.0, isNumeric is limited to
                    // strings and numbers (primitives or objects)
                    // that can be coerced to finite numbers (gh-2662)
                    var type = jQuery.type( obj );
                    return ( type === "number" || type === "string" ) &&

                        // parseFloat NaNs numeric-cast false positives ("")
                        // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
                        // subtraction forces infinities to NaN
                        !isNaN( obj - parseFloat( obj ) );
                };

                jQuery.trim = function( text ) {
                    return text == null ?
                        "" :
                        ( text + "" ).replace( rtrim, "" );
                };



// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

                if ( true ) {
                    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
                        return jQuery;
                    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                }




                var

                    // Map over jQuery in case of overwrite
                    _jQuery = window.jQuery,

                    // Map over the $ in case of overwrite
                    _$ = window.$;

                jQuery.noConflict = function( deep ) {
                    if ( window.$ === jQuery ) {
                        window.$ = _$;
                    }

                    if ( deep && window.jQuery === jQuery ) {
                        window.jQuery = _jQuery;
                    }

                    return jQuery;
                };

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
                if ( typeof noGlobal === "undefined" ) {
                    window.jQuery = window.$ = jQuery;
                }




                return jQuery;
            } );


            /***/ }),

        /***/ "./node_modules/js-cookie/dist/js.cookie.js":
        /*!**************************************************!*\
  !*** ./node_modules/js-cookie/dist/js.cookie.js ***!
  \**************************************************/
        /*! no static exports found */
        /***/ (function(module, exports, __webpack_require__) {

            /*! js-cookie v3.0.1 | MIT */
            ;
            (function (global, factory) {
                true ? module.exports = factory() :
                    undefined;
            }(this, (function () { 'use strict';

                /* eslint-disable no-var */
                function assign (target) {
                    for (var i = 1; i < arguments.length; i++) {
                        var source = arguments[i];
                        for (var key in source) {
                            target[key] = source[key];
                        }
                    }
                    return target
                }
                /* eslint-enable no-var */

                /* eslint-disable no-var */
                var defaultConverter = {
                    read: function (value) {
                        if (value[0] === '"') {
                            value = value.slice(1, -1);
                        }
                        return value.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent)
                    },
                    write: function (value) {
                        return encodeURIComponent(value).replace(
                            /%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g,
                            decodeURIComponent
                        )
                    }
                };
                /* eslint-enable no-var */

                /* eslint-disable no-var */

                function init (converter, defaultAttributes) {
                    function set (key, value, attributes) {
                        if (typeof document === 'undefined') {
                            return
                        }

                        attributes = assign({}, defaultAttributes, attributes);

                        if (typeof attributes.expires === 'number') {
                            attributes.expires = new Date(Date.now() + attributes.expires * 864e5);
                        }
                        if (attributes.expires) {
                            attributes.expires = attributes.expires.toUTCString();
                        }

                        key = encodeURIComponent(key)
                            .replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent)
                            .replace(/[()]/g, escape);

                        var stringifiedAttributes = '';
                        for (var attributeName in attributes) {
                            if (!attributes[attributeName]) {
                                continue
                            }

                            stringifiedAttributes += '; ' + attributeName;

                            if (attributes[attributeName] === true) {
                                continue
                            }

                            // Considers RFC 6265 section 5.2:
                            // ...
                            // 3.  If the remaining unparsed-attributes contains a %x3B (";")
                            //     character:
                            // Consume the characters of the unparsed-attributes up to,
                            // not including, the first %x3B (";") character.
                            // ...
                            stringifiedAttributes += '=' + attributes[attributeName].split(';')[0];
                        }

                        return (document.cookie =
                            key + '=' + converter.write(value, key) + stringifiedAttributes)
                    }

                    function get (key) {
                        if (typeof document === 'undefined' || (arguments.length && !key)) {
                            return
                        }

                        // To prevent the for loop in the first place assign an empty array
                        // in case there are no cookies at all.
                        var cookies = document.cookie ? document.cookie.split('; ') : [];
                        var jar = {};
                        for (var i = 0; i < cookies.length; i++) {
                            var parts = cookies[i].split('=');
                            var value = parts.slice(1).join('=');

                            try {
                                var foundKey = decodeURIComponent(parts[0]);
                                jar[foundKey] = converter.read(value, foundKey);

                                if (key === foundKey) {
                                    break
                                }
                            } catch (e) {}
                        }

                        return key ? jar[key] : jar
                    }

                    return Object.create(
                        {
                            set: set,
                            get: get,
                            remove: function (key, attributes) {
                                set(
                                    key,
                                    '',
                                    assign({}, attributes, {
                                        expires: -1
                                    })
                                );
                            },
                            withAttributes: function (attributes) {
                                return init(this.converter, assign({}, this.attributes, attributes))
                            },
                            withConverter: function (converter) {
                                return init(assign({}, this.converter, converter), this.attributes)
                            }
                        },
                        {
                            attributes: { value: Object.freeze(defaultAttributes) },
                            converter: { value: Object.freeze(converter) }
                        }
                    )
                }

                var api = init(defaultConverter, { path: '/' });
                /* eslint-enable no-var */

                return api;

            })));


            /***/ }),

        /***/ "./node_modules/magnific-popup/dist/jquery.magnific-popup.js":
        /*!*******************************************************************!*\
  !*** ./node_modules/magnific-popup/dist/jquery.magnific-popup.js ***!
  \*******************************************************************/
        /*! no static exports found */
        /***/ (function(module, exports, __webpack_require__) {

            /* WEBPACK VAR INJECTION */(function(__webpack_provided_window_dot_jQuery) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! Magnific Popup - v1.1.0 - 2016-02-20
* http://dimsemenov.com/plugins/magnific-popup/
* Copyright (c) 2016 Dmitry Semenov; */
                ;(function (factory) {
                    if (true) {
                        // AMD. Register as an anonymous module.
                        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                            __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                                (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                        __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                    } else {}
                }(function($) {

                    /*>>core*/
                    /**
                     *
                     * Magnific Popup Core JS file
                     *
                     */


                    /**
                     * Private static constants
                     */
                    var CLOSE_EVENT = 'Close',
                        BEFORE_CLOSE_EVENT = 'BeforeClose',
                        AFTER_CLOSE_EVENT = 'AfterClose',
                        BEFORE_APPEND_EVENT = 'BeforeAppend',
                        MARKUP_PARSE_EVENT = 'MarkupParse',
                        OPEN_EVENT = 'Open',
                        CHANGE_EVENT = 'Change',
                        NS = 'mfp',
                        EVENT_NS = '.' + NS,
                        READY_CLASS = 'mfp-ready',
                        REMOVING_CLASS = 'mfp-removing',
                        PREVENT_CLOSE_CLASS = 'mfp-prevent-close';


                    /**
                     * Private vars
                     */
                    /*jshint -W079 */
                    var mfp, // As we have only one instance of MagnificPopup object, we define it locally to not to use 'this'
                        MagnificPopup = function(){},
                        _isJQ = !!(__webpack_provided_window_dot_jQuery),
                        _prevStatus,
                        _window = $(window),
                        _document,
                        _prevContentType,
                        _wrapClasses,
                        _currPopupType;


                    /**
                     * Private functions
                     */
                    var _mfpOn = function(name, f) {
                            mfp.ev.on(NS + name + EVENT_NS, f);
                        },
                        _getEl = function(className, appendTo, html, raw) {
                            var el = document.createElement('div');
                            el.className = 'mfp-'+className;
                            if(html) {
                                el.innerHTML = html;
                            }
                            if(!raw) {
                                el = $(el);
                                if(appendTo) {
                                    el.appendTo(appendTo);
                                }
                            } else if(appendTo) {
                                appendTo.appendChild(el);
                            }
                            return el;
                        },
                        _mfpTrigger = function(e, data) {
                            mfp.ev.triggerHandler(NS + e, data);

                            if(mfp.st.callbacks) {
                                // converts "mfpEventName" to "eventName" callback and triggers it if it's present
                                e = e.charAt(0).toLowerCase() + e.slice(1);
                                if(mfp.st.callbacks[e]) {
                                    mfp.st.callbacks[e].apply(mfp, $.isArray(data) ? data : [data]);
                                }
                            }
                        },
                        _getCloseBtn = function(type) {
                            if(type !== _currPopupType || !mfp.currTemplate.closeBtn) {
                                mfp.currTemplate.closeBtn = $( mfp.st.closeMarkup.replace('%title%', mfp.st.tClose ) );
                                _currPopupType = type;
                            }
                            return mfp.currTemplate.closeBtn;
                        },
                        // Initialize Magnific Popup only when called at least once
                        _checkInstance = function() {
                            if(!$.magnificPopup.instance) {
                                /*jshint -W020 */
                                mfp = new MagnificPopup();
                                mfp.init();
                                $.magnificPopup.instance = mfp;
                            }
                        },
                        // CSS transition detection, http://stackoverflow.com/questions/7264899/detect-css-transitions-using-javascript-and-without-modernizr
                        supportsTransitions = function() {
                            var s = document.createElement('p').style, // 's' for style. better to create an element if body yet to exist
                                v = ['ms','O','Moz','Webkit']; // 'v' for vendor

                            if( s['transition'] !== undefined ) {
                                return true;
                            }

                            while( v.length ) {
                                if( v.pop() + 'Transition' in s ) {
                                    return true;
                                }
                            }

                            return false;
                        };



                    /**
                     * Public functions
                     */
                    MagnificPopup.prototype = {

                        constructor: MagnificPopup,

                        /**
                         * Initializes Magnific Popup plugin.
                         * This function is triggered only once when $.fn.magnificPopup or $.magnificPopup is executed
                         */
                        init: function() {
                            var appVersion = navigator.appVersion;
                            mfp.isLowIE = mfp.isIE8 = document.all && !document.addEventListener;
                            mfp.isAndroid = (/android/gi).test(appVersion);
                            mfp.isIOS = (/iphone|ipad|ipod/gi).test(appVersion);
                            mfp.supportsTransition = supportsTransitions();

                            // We disable fixed positioned lightbox on devices that don't handle it nicely.
                            // If you know a better way of detecting this - let me know.
                            mfp.probablyMobile = (mfp.isAndroid || mfp.isIOS || /(Opera Mini)|Kindle|webOS|BlackBerry|(Opera Mobi)|(Windows Phone)|IEMobile/i.test(navigator.userAgent) );
                            _document = $(document);

                            mfp.popupsCache = {};
                        },

                        /**
                         * Opens popup
                         * @param  data [description]
                         */
                        open: function(data) {

                            var i;

                            if(data.isObj === false) {
                                // convert jQuery collection to array to avoid conflicts later
                                mfp.items = data.items.toArray();

                                mfp.index = 0;
                                var items = data.items,
                                    item;
                                for(i = 0; i < items.length; i++) {
                                    item = items[i];
                                    if(item.parsed) {
                                        item = item.el[0];
                                    }
                                    if(item === data.el[0]) {
                                        mfp.index = i;
                                        break;
                                    }
                                }
                            } else {
                                mfp.items = $.isArray(data.items) ? data.items : [data.items];
                                mfp.index = data.index || 0;
                            }

                            // if popup is already opened - we just update the content
                            if(mfp.isOpen) {
                                mfp.updateItemHTML();
                                return;
                            }

                            mfp.types = [];
                            _wrapClasses = '';
                            if(data.mainEl && data.mainEl.length) {
                                mfp.ev = data.mainEl.eq(0);
                            } else {
                                mfp.ev = _document;
                            }

                            if(data.key) {
                                if(!mfp.popupsCache[data.key]) {
                                    mfp.popupsCache[data.key] = {};
                                }
                                mfp.currTemplate = mfp.popupsCache[data.key];
                            } else {
                                mfp.currTemplate = {};
                            }



                            mfp.st = $.extend(true, {}, $.magnificPopup.defaults, data );
                            mfp.fixedContentPos = mfp.st.fixedContentPos === 'auto' ? !mfp.probablyMobile : mfp.st.fixedContentPos;

                            if(mfp.st.modal) {
                                mfp.st.closeOnContentClick = false;
                                mfp.st.closeOnBgClick = false;
                                mfp.st.showCloseBtn = false;
                                mfp.st.enableEscapeKey = false;
                            }


                            // Building markup
                            // main containers are created only once
                            if(!mfp.bgOverlay) {

                                // Dark overlay
                                mfp.bgOverlay = _getEl('bg').on('click'+EVENT_NS, function() {
                                    mfp.close();
                                });

                                mfp.wrap = _getEl('wrap').attr('tabindex', -1).on('click'+EVENT_NS, function(e) {
                                    if(mfp._checkIfClose(e.target)) {
                                        mfp.close();
                                    }
                                });

                                mfp.container = _getEl('container', mfp.wrap);
                            }

                            mfp.contentContainer = _getEl('content');
                            if(mfp.st.preloader) {
                                mfp.preloader = _getEl('preloader', mfp.container, mfp.st.tLoading);
                            }


                            // Initializing modules
                            var modules = $.magnificPopup.modules;
                            for(i = 0; i < modules.length; i++) {
                                var n = modules[i];
                                n = n.charAt(0).toUpperCase() + n.slice(1);
                                mfp['init'+n].call(mfp);
                            }
                            _mfpTrigger('BeforeOpen');


                            if(mfp.st.showCloseBtn) {
                                // Close button
                                if(!mfp.st.closeBtnInside) {
                                    mfp.wrap.append( _getCloseBtn() );
                                } else {
                                    _mfpOn(MARKUP_PARSE_EVENT, function(e, template, values, item) {
                                        values.close_replaceWith = _getCloseBtn(item.type);
                                    });
                                    _wrapClasses += ' mfp-close-btn-in';
                                }
                            }

                            if(mfp.st.alignTop) {
                                _wrapClasses += ' mfp-align-top';
                            }



                            if(mfp.fixedContentPos) {
                                mfp.wrap.css({
                                    overflow: mfp.st.overflowY,
                                    overflowX: 'hidden',
                                    overflowY: mfp.st.overflowY
                                });
                            } else {
                                mfp.wrap.css({
                                    top: _window.scrollTop(),
                                    position: 'absolute'
                                });
                            }
                            if( mfp.st.fixedBgPos === false || (mfp.st.fixedBgPos === 'auto' && !mfp.fixedContentPos) ) {
                                mfp.bgOverlay.css({
                                    height: _document.height(),
                                    position: 'absolute'
                                });
                            }



                            if(mfp.st.enableEscapeKey) {
                                // Close on ESC key
                                _document.on('keyup' + EVENT_NS, function(e) {
                                    if(e.keyCode === 27) {
                                        mfp.close();
                                    }
                                });
                            }

                            _window.on('resize' + EVENT_NS, function() {
                                mfp.updateSize();
                            });


                            if(!mfp.st.closeOnContentClick) {
                                _wrapClasses += ' mfp-auto-cursor';
                            }

                            if(_wrapClasses)
                                mfp.wrap.addClass(_wrapClasses);


                            // this triggers recalculation of layout, so we get it once to not to trigger twice
                            var windowHeight = mfp.wH = _window.height();


                            var windowStyles = {};

                            if( mfp.fixedContentPos ) {
                                if(mfp._hasScrollBar(windowHeight)){
                                    var s = mfp._getScrollbarSize();
                                    if(s) {
                                        windowStyles.marginRight = s;
                                    }
                                }
                            }

                            if(mfp.fixedContentPos) {
                                if(!mfp.isIE7) {
                                    windowStyles.overflow = 'hidden';
                                } else {
                                    // ie7 double-scroll bug
                                    $('body, html').css('overflow', 'hidden');
                                }
                            }



                            var classesToadd = mfp.st.mainClass;
                            if(mfp.isIE7) {
                                classesToadd += ' mfp-ie7';
                            }
                            if(classesToadd) {
                                mfp._addClassToMFP( classesToadd );
                            }

                            // add content
                            mfp.updateItemHTML();

                            _mfpTrigger('BuildControls');

                            // remove scrollbar, add margin e.t.c
                            $('html').css(windowStyles);

                            // add everything to DOM
                            mfp.bgOverlay.add(mfp.wrap).prependTo( mfp.st.prependTo || $(document.body) );

                            // Save last focused element
                            mfp._lastFocusedEl = document.activeElement;

                            // Wait for next cycle to allow CSS transition
                            setTimeout(function() {

                                if(mfp.content) {
                                    mfp._addClassToMFP(READY_CLASS);
                                    mfp._setFocus();
                                } else {
                                    // if content is not defined (not loaded e.t.c) we add class only for BG
                                    mfp.bgOverlay.addClass(READY_CLASS);
                                }

                                // Trap the focus in popup
                                _document.on('focusin' + EVENT_NS, mfp._onFocusIn);

                            }, 16);

                            mfp.isOpen = true;
                            mfp.updateSize(windowHeight);
                            _mfpTrigger(OPEN_EVENT);

                            return data;
                        },

                        /**
                         * Closes the popup
                         */
                        close: function() {
                            if(!mfp.isOpen) return;
                            _mfpTrigger(BEFORE_CLOSE_EVENT);

                            mfp.isOpen = false;
                            // for CSS3 animation
                            if(mfp.st.removalDelay && !mfp.isLowIE && mfp.supportsTransition )  {
                                mfp._addClassToMFP(REMOVING_CLASS);
                                setTimeout(function() {
                                    mfp._close();
                                }, mfp.st.removalDelay);
                            } else {
                                mfp._close();
                            }
                        },

                        /**
                         * Helper for close() function
                         */
                        _close: function() {
                            _mfpTrigger(CLOSE_EVENT);

                            var classesToRemove = REMOVING_CLASS + ' ' + READY_CLASS + ' ';

                            mfp.bgOverlay.detach();
                            mfp.wrap.detach();
                            mfp.container.empty();

                            if(mfp.st.mainClass) {
                                classesToRemove += mfp.st.mainClass + ' ';
                            }

                            mfp._removeClassFromMFP(classesToRemove);

                            if(mfp.fixedContentPos) {
                                var windowStyles = {marginRight: ''};
                                if(mfp.isIE7) {
                                    $('body, html').css('overflow', '');
                                } else {
                                    windowStyles.overflow = '';
                                }
                                $('html').css(windowStyles);
                            }

                            _document.off('keyup' + EVENT_NS + ' focusin' + EVENT_NS);
                            mfp.ev.off(EVENT_NS);

                            // clean up DOM elements that aren't removed
                            mfp.wrap.attr('class', 'mfp-wrap').removeAttr('style');
                            mfp.bgOverlay.attr('class', 'mfp-bg');
                            mfp.container.attr('class', 'mfp-container');

                            // remove close button from target element
                            if(mfp.st.showCloseBtn &&
                                (!mfp.st.closeBtnInside || mfp.currTemplate[mfp.currItem.type] === true)) {
                                if(mfp.currTemplate.closeBtn)
                                    mfp.currTemplate.closeBtn.detach();
                            }


                            if(mfp.st.autoFocusLast && mfp._lastFocusedEl) {
                                $(mfp._lastFocusedEl).focus(); // put tab focus back
                            }
                            mfp.currItem = null;
                            mfp.content = null;
                            mfp.currTemplate = null;
                            mfp.prevHeight = 0;

                            _mfpTrigger(AFTER_CLOSE_EVENT);
                        },

                        updateSize: function(winHeight) {

                            if(mfp.isIOS) {
                                // fixes iOS nav bars https://github.com/dimsemenov/Magnific-Popup/issues/2
                                var zoomLevel = document.documentElement.clientWidth / window.innerWidth;
                                var height = window.innerHeight * zoomLevel;
                                mfp.wrap.css('height', height);
                                mfp.wH = height;
                            } else {
                                mfp.wH = winHeight || _window.height();
                            }
                            // Fixes #84: popup incorrectly positioned with position:relative on body
                            if(!mfp.fixedContentPos) {
                                mfp.wrap.css('height', mfp.wH);
                            }

                            _mfpTrigger('Resize');

                        },

                        /**
                         * Set content of popup based on current index
                         */
                        updateItemHTML: function() {
                            var item = mfp.items[mfp.index];

                            // Detach and perform modifications
                            mfp.contentContainer.detach();

                            if(mfp.content)
                                mfp.content.detach();

                            if(!item.parsed) {
                                item = mfp.parseEl( mfp.index );
                            }

                            var type = item.type;

                            _mfpTrigger('BeforeChange', [mfp.currItem ? mfp.currItem.type : '', type]);
                            // BeforeChange event works like so:
                            // _mfpOn('BeforeChange', function(e, prevType, newType) { });

                            mfp.currItem = item;

                            if(!mfp.currTemplate[type]) {
                                var markup = mfp.st[type] ? mfp.st[type].markup : false;

                                // allows to modify markup
                                _mfpTrigger('FirstMarkupParse', markup);

                                if(markup) {
                                    mfp.currTemplate[type] = $(markup);
                                } else {
                                    // if there is no markup found we just define that template is parsed
                                    mfp.currTemplate[type] = true;
                                }
                            }

                            if(_prevContentType && _prevContentType !== item.type) {
                                mfp.container.removeClass('mfp-'+_prevContentType+'-holder');
                            }

                            var newContent = mfp['get' + type.charAt(0).toUpperCase() + type.slice(1)](item, mfp.currTemplate[type]);
                            mfp.appendContent(newContent, type);

                            item.preloaded = true;

                            _mfpTrigger(CHANGE_EVENT, item);
                            _prevContentType = item.type;

                            // Append container back after its content changed
                            mfp.container.prepend(mfp.contentContainer);

                            _mfpTrigger('AfterChange');
                        },


                        /**
                         * Set HTML content of popup
                         */
                        appendContent: function(newContent, type) {
                            mfp.content = newContent;

                            if(newContent) {
                                if(mfp.st.showCloseBtn && mfp.st.closeBtnInside &&
                                    mfp.currTemplate[type] === true) {
                                    // if there is no markup, we just append close button element inside
                                    if(!mfp.content.find('.mfp-close').length) {
                                        mfp.content.append(_getCloseBtn());
                                    }
                                } else {
                                    mfp.content = newContent;
                                }
                            } else {
                                mfp.content = '';
                            }

                            _mfpTrigger(BEFORE_APPEND_EVENT);
                            mfp.container.addClass('mfp-'+type+'-holder');

                            mfp.contentContainer.append(mfp.content);
                        },


                        /**
                         * Creates Magnific Popup data object based on given data
                         * @param  {int} index Index of item to parse
                         */
                        parseEl: function(index) {
                            var item = mfp.items[index],
                                type;

                            if(item.tagName) {
                                item = { el: $(item) };
                            } else {
                                type = item.type;
                                item = { data: item, src: item.src };
                            }

                            if(item.el) {
                                var types = mfp.types;

                                // check for 'mfp-TYPE' class
                                for(var i = 0; i < types.length; i++) {
                                    if( item.el.hasClass('mfp-'+types[i]) ) {
                                        type = types[i];
                                        break;
                                    }
                                }

                                item.src = item.el.attr('data-mfp-src');
                                if(!item.src) {
                                    item.src = item.el.attr('href');
                                }
                            }

                            item.type = type || mfp.st.type || 'inline';
                            item.index = index;
                            item.parsed = true;
                            mfp.items[index] = item;
                            _mfpTrigger('ElementParse', item);

                            return mfp.items[index];
                        },


                        /**
                         * Initializes single popup or a group of popups
                         */
                        addGroup: function(el, options) {
                            var eHandler = function(e) {
                                e.mfpEl = this;
                                mfp._openClick(e, el, options);
                            };

                            if(!options) {
                                options = {};
                            }

                            var eName = 'click.magnificPopup';
                            options.mainEl = el;

                            if(options.items) {
                                options.isObj = true;
                                el.off(eName).on(eName, eHandler);
                            } else {
                                options.isObj = false;
                                if(options.delegate) {
                                    el.off(eName).on(eName, options.delegate , eHandler);
                                } else {
                                    options.items = el;
                                    el.off(eName).on(eName, eHandler);
                                }
                            }
                        },
                        _openClick: function(e, el, options) {
                            var midClick = options.midClick !== undefined ? options.midClick : $.magnificPopup.defaults.midClick;


                            if(!midClick && ( e.which === 2 || e.ctrlKey || e.metaKey || e.altKey || e.shiftKey ) ) {
                                return;
                            }

                            var disableOn = options.disableOn !== undefined ? options.disableOn : $.magnificPopup.defaults.disableOn;

                            if(disableOn) {
                                if($.isFunction(disableOn)) {
                                    if( !disableOn.call(mfp) ) {
                                        return true;
                                    }
                                } else { // else it's number
                                    if( _window.width() < disableOn ) {
                                        return true;
                                    }
                                }
                            }

                            if(e.type) {
                                e.preventDefault();

                                // This will prevent popup from closing if element is inside and popup is already opened
                                if(mfp.isOpen) {
                                    e.stopPropagation();
                                }
                            }

                            options.el = $(e.mfpEl);
                            if(options.delegate) {
                                options.items = el.find(options.delegate);
                            }
                            mfp.open(options);
                        },


                        /**
                         * Updates text on preloader
                         */
                        updateStatus: function(status, text) {

                            if(mfp.preloader) {
                                if(_prevStatus !== status) {
                                    mfp.container.removeClass('mfp-s-'+_prevStatus);
                                }

                                if(!text && status === 'loading') {
                                    text = mfp.st.tLoading;
                                }

                                var data = {
                                    status: status,
                                    text: text
                                };
                                // allows to modify status
                                _mfpTrigger('UpdateStatus', data);

                                status = data.status;
                                text = data.text;

                                mfp.preloader.html(text);

                                mfp.preloader.find('a').on('click', function(e) {
                                    e.stopImmediatePropagation();
                                });

                                mfp.container.addClass('mfp-s-'+status);
                                _prevStatus = status;
                            }
                        },


                        /*
		"Private" helpers that aren't private at all
	 */
                        // Check to close popup or not
                        // "target" is an element that was clicked
                        _checkIfClose: function(target) {

                            if($(target).hasClass(PREVENT_CLOSE_CLASS)) {
                                return;
                            }

                            var closeOnContent = mfp.st.closeOnContentClick;
                            var closeOnBg = mfp.st.closeOnBgClick;

                            if(closeOnContent && closeOnBg) {
                                return true;
                            } else {

                                // We close the popup if click is on close button or on preloader. Or if there is no content.
                                if(!mfp.content || $(target).hasClass('mfp-close') || (mfp.preloader && target === mfp.preloader[0]) ) {
                                    return true;
                                }

                                // if click is outside the content
                                if(  (target !== mfp.content[0] && !$.contains(mfp.content[0], target))  ) {
                                    if(closeOnBg) {
                                        // last check, if the clicked element is in DOM, (in case it's removed onclick)
                                        if( $.contains(document, target) ) {
                                            return true;
                                        }
                                    }
                                } else if(closeOnContent) {
                                    return true;
                                }

                            }
                            return false;
                        },
                        _addClassToMFP: function(cName) {
                            mfp.bgOverlay.addClass(cName);
                            mfp.wrap.addClass(cName);
                        },
                        _removeClassFromMFP: function(cName) {
                            this.bgOverlay.removeClass(cName);
                            mfp.wrap.removeClass(cName);
                        },
                        _hasScrollBar: function(winHeight) {
                            return (  (mfp.isIE7 ? _document.height() : document.body.scrollHeight) > (winHeight || _window.height()) );
                        },
                        _setFocus: function() {
                            (mfp.st.focus ? mfp.content.find(mfp.st.focus).eq(0) : mfp.wrap).focus();
                        },
                        _onFocusIn: function(e) {
                            if( e.target !== mfp.wrap[0] && !$.contains(mfp.wrap[0], e.target) ) {
                                mfp._setFocus();
                                return false;
                            }
                        },
                        _parseMarkup: function(template, values, item) {
                            var arr;
                            if(item.data) {
                                values = $.extend(item.data, values);
                            }
                            _mfpTrigger(MARKUP_PARSE_EVENT, [template, values, item] );

                            $.each(values, function(key, value) {
                                if(value === undefined || value === false) {
                                    return true;
                                }
                                arr = key.split('_');
                                if(arr.length > 1) {
                                    var el = template.find(EVENT_NS + '-'+arr[0]);

                                    if(el.length > 0) {
                                        var attr = arr[1];
                                        if(attr === 'replaceWith') {
                                            if(el[0] !== value[0]) {
                                                el.replaceWith(value);
                                            }
                                        } else if(attr === 'img') {
                                            if(el.is('img')) {
                                                el.attr('src', value);
                                            } else {
                                                el.replaceWith( $('<img>').attr('src', value).attr('class', el.attr('class')) );
                                            }
                                        } else {
                                            el.attr(arr[1], value);
                                        }
                                    }

                                } else {
                                    template.find(EVENT_NS + '-'+key).html(value);
                                }
                            });
                        },

                        _getScrollbarSize: function() {
                            // thx David
                            if(mfp.scrollbarSize === undefined) {
                                var scrollDiv = document.createElement("div");
                                scrollDiv.style.cssText = 'width: 99px; height: 99px; overflow: scroll; position: absolute; top: -9999px;';
                                document.body.appendChild(scrollDiv);
                                mfp.scrollbarSize = scrollDiv.offsetWidth - scrollDiv.clientWidth;
                                document.body.removeChild(scrollDiv);
                            }
                            return mfp.scrollbarSize;
                        }

                    }; /* MagnificPopup core prototype end */




                    /**
                     * Public static functions
                     */
                    $.magnificPopup = {
                        instance: null,
                        proto: MagnificPopup.prototype,
                        modules: [],

                        open: function(options, index) {
                            _checkInstance();

                            if(!options) {
                                options = {};
                            } else {
                                options = $.extend(true, {}, options);
                            }

                            options.isObj = true;
                            options.index = index || 0;
                            return this.instance.open(options);
                        },

                        close: function() {
                            return $.magnificPopup.instance && $.magnificPopup.instance.close();
                        },

                        registerModule: function(name, module) {
                            if(module.options) {
                                $.magnificPopup.defaults[name] = module.options;
                            }
                            $.extend(this.proto, module.proto);
                            this.modules.push(name);
                        },

                        defaults: {

                            // Info about options is in docs:
                            // http://dimsemenov.com/plugins/magnific-popup/documentation.html#options

                            disableOn: 0,

                            key: null,

                            midClick: false,

                            mainClass: '',

                            preloader: true,

                            focus: '', // CSS selector of input to focus after popup is opened

                            closeOnContentClick: false,

                            closeOnBgClick: true,

                            closeBtnInside: true,

                            showCloseBtn: true,

                            enableEscapeKey: true,

                            modal: false,

                            alignTop: false,

                            removalDelay: 0,

                            prependTo: null,

                            fixedContentPos: 'auto',

                            fixedBgPos: 'auto',

                            overflowY: 'auto',

                            closeMarkup: '<button title="%title%" type="button" class="mfp-close">&#215;</button>',

                            tClose: 'Close (Esc)',

                            tLoading: 'Loading...',

                            autoFocusLast: true

                        }
                    };



                    $.fn.magnificPopup = function(options) {
                        _checkInstance();

                        var jqEl = $(this);

                        // We call some API method of first param is a string
                        if (typeof options === "string" ) {

                            if(options === 'open') {
                                var items,
                                    itemOpts = _isJQ ? jqEl.data('magnificPopup') : jqEl[0].magnificPopup,
                                    index = parseInt(arguments[1], 10) || 0;

                                if(itemOpts.items) {
                                    items = itemOpts.items[index];
                                } else {
                                    items = jqEl;
                                    if(itemOpts.delegate) {
                                        items = items.find(itemOpts.delegate);
                                    }
                                    items = items.eq( index );
                                }
                                mfp._openClick({mfpEl:items}, jqEl, itemOpts);
                            } else {
                                if(mfp.isOpen)
                                    mfp[options].apply(mfp, Array.prototype.slice.call(arguments, 1));
                            }

                        } else {
                            // clone options obj
                            options = $.extend(true, {}, options);

                            /*
		 * As Zepto doesn't support .data() method for objects
		 * and it works only in normal browsers
		 * we assign "options" object directly to the DOM element. FTW!
		 */
                            if(_isJQ) {
                                jqEl.data('magnificPopup', options);
                            } else {
                                jqEl[0].magnificPopup = options;
                            }

                            mfp.addGroup(jqEl, options);

                        }
                        return jqEl;
                    };

                    /*>>core*/

                    /*>>inline*/

                    var INLINE_NS = 'inline',
                        _hiddenClass,
                        _inlinePlaceholder,
                        _lastInlineElement,
                        _putInlineElementsBack = function() {
                            if(_lastInlineElement) {
                                _inlinePlaceholder.after( _lastInlineElement.addClass(_hiddenClass) ).detach();
                                _lastInlineElement = null;
                            }
                        };

                    $.magnificPopup.registerModule(INLINE_NS, {
                        options: {
                            hiddenClass: 'hide', // will be appended with `mfp-` prefix
                            markup: '',
                            tNotFound: 'Content not found'
                        },
                        proto: {

                            initInline: function() {
                                mfp.types.push(INLINE_NS);

                                _mfpOn(CLOSE_EVENT+'.'+INLINE_NS, function() {
                                    _putInlineElementsBack();
                                });
                            },

                            getInline: function(item, template) {

                                _putInlineElementsBack();

                                if(item.src) {
                                    var inlineSt = mfp.st.inline,
                                        el = $(item.src);

                                    if(el.length) {

                                        // If target element has parent - we replace it with placeholder and put it back after popup is closed
                                        var parent = el[0].parentNode;
                                        if(parent && parent.tagName) {
                                            if(!_inlinePlaceholder) {
                                                _hiddenClass = inlineSt.hiddenClass;
                                                _inlinePlaceholder = _getEl(_hiddenClass);
                                                _hiddenClass = 'mfp-'+_hiddenClass;
                                            }
                                            // replace target inline element with placeholder
                                            _lastInlineElement = el.after(_inlinePlaceholder).detach().removeClass(_hiddenClass);
                                        }

                                        mfp.updateStatus('ready');
                                    } else {
                                        mfp.updateStatus('error', inlineSt.tNotFound);
                                        el = $('<div>');
                                    }

                                    item.inlineElement = el;
                                    return el;
                                }

                                mfp.updateStatus('ready');
                                mfp._parseMarkup(template, {}, item);
                                return template;
                            }
                        }
                    });

                    /*>>inline*/

                    /*>>ajax*/
                    var AJAX_NS = 'ajax',
                        _ajaxCur,
                        _removeAjaxCursor = function() {
                            if(_ajaxCur) {
                                $(document.body).removeClass(_ajaxCur);
                            }
                        },
                        _destroyAjaxRequest = function() {
                            _removeAjaxCursor();
                            if(mfp.req) {
                                mfp.req.abort();
                            }
                        };

                    $.magnificPopup.registerModule(AJAX_NS, {

                        options: {
                            settings: null,
                            cursor: 'mfp-ajax-cur',
                            tError: '<a href="%url%">The content</a> could not be loaded.'
                        },

                        proto: {
                            initAjax: function() {
                                mfp.types.push(AJAX_NS);
                                _ajaxCur = mfp.st.ajax.cursor;

                                _mfpOn(CLOSE_EVENT+'.'+AJAX_NS, _destroyAjaxRequest);
                                _mfpOn('BeforeChange.' + AJAX_NS, _destroyAjaxRequest);
                            },
                            getAjax: function(item) {

                                if(_ajaxCur) {
                                    $(document.body).addClass(_ajaxCur);
                                }

                                mfp.updateStatus('loading');

                                var opts = $.extend({
                                    url: item.src,
                                    success: function(data, textStatus, jqXHR) {
                                        var temp = {
                                            data:data,
                                            xhr:jqXHR
                                        };

                                        _mfpTrigger('ParseAjax', temp);

                                        mfp.appendContent( $(temp.data), AJAX_NS );

                                        item.finished = true;

                                        _removeAjaxCursor();

                                        mfp._setFocus();

                                        setTimeout(function() {
                                            mfp.wrap.addClass(READY_CLASS);
                                        }, 16);

                                        mfp.updateStatus('ready');

                                        _mfpTrigger('AjaxContentAdded');
                                    },
                                    error: function() {
                                        _removeAjaxCursor();
                                        item.finished = item.loadError = true;
                                        mfp.updateStatus('error', mfp.st.ajax.tError.replace('%url%', item.src));
                                    }
                                }, mfp.st.ajax.settings);

                                mfp.req = $.ajax(opts);

                                return '';
                            }
                        }
                    });

                    /*>>ajax*/

                    /*>>image*/
                    var _imgInterval,
                        _getTitle = function(item) {
                            if(item.data && item.data.title !== undefined)
                                return item.data.title;

                            var src = mfp.st.image.titleSrc;

                            if(src) {
                                if($.isFunction(src)) {
                                    return src.call(mfp, item);
                                } else if(item.el) {
                                    return item.el.attr(src) || '';
                                }
                            }
                            return '';
                        };

                    $.magnificPopup.registerModule('image', {

                        options: {
                            markup: '<div class="mfp-figure">'+
                                '<div class="mfp-close"></div>'+
                                '<figure>'+
                                '<div class="mfp-img"></div>'+
                                '<figcaption>'+
                                '<div class="mfp-bottom-bar">'+
                                '<div class="mfp-title"></div>'+
                                '<div class="mfp-counter"></div>'+
                                '</div>'+
                                '</figcaption>'+
                                '</figure>'+
                                '</div>',
                            cursor: 'mfp-zoom-out-cur',
                            titleSrc: 'title',
                            verticalFit: true,
                            tError: '<a href="%url%">The image</a> could not be loaded.'
                        },

                        proto: {
                            initImage: function() {
                                var imgSt = mfp.st.image,
                                    ns = '.image';

                                mfp.types.push('image');

                                _mfpOn(OPEN_EVENT+ns, function() {
                                    if(mfp.currItem.type === 'image' && imgSt.cursor) {
                                        $(document.body).addClass(imgSt.cursor);
                                    }
                                });

                                _mfpOn(CLOSE_EVENT+ns, function() {
                                    if(imgSt.cursor) {
                                        $(document.body).removeClass(imgSt.cursor);
                                    }
                                    _window.off('resize' + EVENT_NS);
                                });

                                _mfpOn('Resize'+ns, mfp.resizeImage);
                                if(mfp.isLowIE) {
                                    _mfpOn('AfterChange', mfp.resizeImage);
                                }
                            },
                            resizeImage: function() {
                                var item = mfp.currItem;
                                if(!item || !item.img) return;

                                if(mfp.st.image.verticalFit) {
                                    var decr = 0;
                                    // fix box-sizing in ie7/8
                                    if(mfp.isLowIE) {
                                        decr = parseInt(item.img.css('padding-top'), 10) + parseInt(item.img.css('padding-bottom'),10);
                                    }
                                    item.img.css('max-height', mfp.wH-decr);
                                }
                            },
                            _onImageHasSize: function(item) {
                                if(item.img) {

                                    item.hasSize = true;

                                    if(_imgInterval) {
                                        clearInterval(_imgInterval);
                                    }

                                    item.isCheckingImgSize = false;

                                    _mfpTrigger('ImageHasSize', item);

                                    if(item.imgHidden) {
                                        if(mfp.content)
                                            mfp.content.removeClass('mfp-loading');

                                        item.imgHidden = false;
                                    }

                                }
                            },

                            /**
                             * Function that loops until the image has size to display elements that rely on it asap
                             */
                            findImageSize: function(item) {

                                var counter = 0,
                                    img = item.img[0],
                                    mfpSetInterval = function(delay) {

                                        if(_imgInterval) {
                                            clearInterval(_imgInterval);
                                        }
                                        // decelerating interval that checks for size of an image
                                        _imgInterval = setInterval(function() {
                                            if(img.naturalWidth > 0) {
                                                mfp._onImageHasSize(item);
                                                return;
                                            }

                                            if(counter > 200) {
                                                clearInterval(_imgInterval);
                                            }

                                            counter++;
                                            if(counter === 3) {
                                                mfpSetInterval(10);
                                            } else if(counter === 40) {
                                                mfpSetInterval(50);
                                            } else if(counter === 100) {
                                                mfpSetInterval(500);
                                            }
                                        }, delay);
                                    };

                                mfpSetInterval(1);
                            },

                            getImage: function(item, template) {

                                var guard = 0,

                                    // image load complete handler
                                    onLoadComplete = function() {
                                        if(item) {
                                            if (item.img[0].complete) {
                                                item.img.off('.mfploader');

                                                if(item === mfp.currItem){
                                                    mfp._onImageHasSize(item);

                                                    mfp.updateStatus('ready');
                                                }

                                                item.hasSize = true;
                                                item.loaded = true;

                                                _mfpTrigger('ImageLoadComplete');

                                            }
                                            else {
                                                // if image complete check fails 200 times (20 sec), we assume that there was an error.
                                                guard++;
                                                if(guard < 200) {
                                                    setTimeout(onLoadComplete,100);
                                                } else {
                                                    onLoadError();
                                                }
                                            }
                                        }
                                    },

                                    // image error handler
                                    onLoadError = function() {
                                        if(item) {
                                            item.img.off('.mfploader');
                                            if(item === mfp.currItem){
                                                mfp._onImageHasSize(item);
                                                mfp.updateStatus('error', imgSt.tError.replace('%url%', item.src) );
                                            }

                                            item.hasSize = true;
                                            item.loaded = true;
                                            item.loadError = true;
                                        }
                                    },
                                    imgSt = mfp.st.image;


                                var el = template.find('.mfp-img');
                                if(el.length) {
                                    var img = document.createElement('img');
                                    img.className = 'mfp-img';
                                    if(item.el && item.el.find('img').length) {
                                        img.alt = item.el.find('img').attr('alt');
                                    }
                                    item.img = $(img).on('load.mfploader', onLoadComplete).on('error.mfploader', onLoadError);
                                    img.src = item.src;

                                    // without clone() "error" event is not firing when IMG is replaced by new IMG
                                    // TODO: find a way to avoid such cloning
                                    if(el.is('img')) {
                                        item.img = item.img.clone();
                                    }

                                    img = item.img[0];
                                    if(img.naturalWidth > 0) {
                                        item.hasSize = true;
                                    } else if(!img.width) {
                                        item.hasSize = false;
                                    }
                                }

                                mfp._parseMarkup(template, {
                                    title: _getTitle(item),
                                    img_replaceWith: item.img
                                }, item);

                                mfp.resizeImage();

                                if(item.hasSize) {
                                    if(_imgInterval) clearInterval(_imgInterval);

                                    if(item.loadError) {
                                        template.addClass('mfp-loading');
                                        mfp.updateStatus('error', imgSt.tError.replace('%url%', item.src) );
                                    } else {
                                        template.removeClass('mfp-loading');
                                        mfp.updateStatus('ready');
                                    }
                                    return template;
                                }

                                mfp.updateStatus('loading');
                                item.loading = true;

                                if(!item.hasSize) {
                                    item.imgHidden = true;
                                    template.addClass('mfp-loading');
                                    mfp.findImageSize(item);
                                }

                                return template;
                            }
                        }
                    });

                    /*>>image*/

                    /*>>zoom*/
                    var hasMozTransform,
                        getHasMozTransform = function() {
                            if(hasMozTransform === undefined) {
                                hasMozTransform = document.createElement('p').style.MozTransform !== undefined;
                            }
                            return hasMozTransform;
                        };

                    $.magnificPopup.registerModule('zoom', {

                        options: {
                            enabled: false,
                            easing: 'ease-in-out',
                            duration: 300,
                            opener: function(element) {
                                return element.is('img') ? element : element.find('img');
                            }
                        },

                        proto: {

                            initZoom: function() {
                                var zoomSt = mfp.st.zoom,
                                    ns = '.zoom',
                                    image;

                                if(!zoomSt.enabled || !mfp.supportsTransition) {
                                    return;
                                }

                                var duration = zoomSt.duration,
                                    getElToAnimate = function(image) {
                                        var newImg = image.clone().removeAttr('style').removeAttr('class').addClass('mfp-animated-image'),
                                            transition = 'all '+(zoomSt.duration/1000)+'s ' + zoomSt.easing,
                                            cssObj = {
                                                position: 'fixed',
                                                zIndex: 9999,
                                                left: 0,
                                                top: 0,
                                                '-webkit-backface-visibility': 'hidden'
                                            },
                                            t = 'transition';

                                        cssObj['-webkit-'+t] = cssObj['-moz-'+t] = cssObj['-o-'+t] = cssObj[t] = transition;

                                        newImg.css(cssObj);
                                        return newImg;
                                    },
                                    showMainContent = function() {
                                        mfp.content.css('visibility', 'visible');
                                    },
                                    openTimeout,
                                    animatedImg;

                                _mfpOn('BuildControls'+ns, function() {
                                    if(mfp._allowZoom()) {

                                        clearTimeout(openTimeout);
                                        mfp.content.css('visibility', 'hidden');

                                        // Basically, all code below does is clones existing image, puts in on top of the current one and animated it

                                        image = mfp._getItemToZoom();

                                        if(!image) {
                                            showMainContent();
                                            return;
                                        }

                                        animatedImg = getElToAnimate(image);

                                        animatedImg.css( mfp._getOffset() );

                                        mfp.wrap.append(animatedImg);

                                        openTimeout = setTimeout(function() {
                                            animatedImg.css( mfp._getOffset( true ) );
                                            openTimeout = setTimeout(function() {

                                                showMainContent();

                                                setTimeout(function() {
                                                    animatedImg.remove();
                                                    image = animatedImg = null;
                                                    _mfpTrigger('ZoomAnimationEnded');
                                                }, 16); // avoid blink when switching images

                                            }, duration); // this timeout equals animation duration

                                        }, 16); // by adding this timeout we avoid short glitch at the beginning of animation


                                        // Lots of timeouts...
                                    }
                                });
                                _mfpOn(BEFORE_CLOSE_EVENT+ns, function() {
                                    if(mfp._allowZoom()) {

                                        clearTimeout(openTimeout);

                                        mfp.st.removalDelay = duration;

                                        if(!image) {
                                            image = mfp._getItemToZoom();
                                            if(!image) {
                                                return;
                                            }
                                            animatedImg = getElToAnimate(image);
                                        }

                                        animatedImg.css( mfp._getOffset(true) );
                                        mfp.wrap.append(animatedImg);
                                        mfp.content.css('visibility', 'hidden');

                                        setTimeout(function() {
                                            animatedImg.css( mfp._getOffset() );
                                        }, 16);
                                    }

                                });

                                _mfpOn(CLOSE_EVENT+ns, function() {
                                    if(mfp._allowZoom()) {
                                        showMainContent();
                                        if(animatedImg) {
                                            animatedImg.remove();
                                        }
                                        image = null;
                                    }
                                });
                            },

                            _allowZoom: function() {
                                return mfp.currItem.type === 'image';
                            },

                            _getItemToZoom: function() {
                                if(mfp.currItem.hasSize) {
                                    return mfp.currItem.img;
                                } else {
                                    return false;
                                }
                            },

                            // Get element postion relative to viewport
                            _getOffset: function(isLarge) {
                                var el;
                                if(isLarge) {
                                    el = mfp.currItem.img;
                                } else {
                                    el = mfp.st.zoom.opener(mfp.currItem.el || mfp.currItem);
                                }

                                var offset = el.offset();
                                var paddingTop = parseInt(el.css('padding-top'),10);
                                var paddingBottom = parseInt(el.css('padding-bottom'),10);
                                offset.top -= ( $(window).scrollTop() - paddingTop );


                                /*

			Animating left + top + width/height looks glitchy in Firefox, but perfect in Chrome. And vice-versa.

			 */
                                var obj = {
                                    width: el.width(),
                                    // fix Zepto height+padding issue
                                    height: (_isJQ ? el.innerHeight() : el[0].offsetHeight) - paddingBottom - paddingTop
                                };

                                // I hate to do this, but there is no another option
                                if( getHasMozTransform() ) {
                                    obj['-moz-transform'] = obj['transform'] = 'translate(' + offset.left + 'px,' + offset.top + 'px)';
                                } else {
                                    obj.left = offset.left;
                                    obj.top = offset.top;
                                }
                                return obj;
                            }

                        }
                    });



                    /*>>zoom*/

                    /*>>iframe*/

                    var IFRAME_NS = 'iframe',
                        _emptyPage = '//about:blank',

                        _fixIframeBugs = function(isShowing) {
                            if(mfp.currTemplate[IFRAME_NS]) {
                                var el = mfp.currTemplate[IFRAME_NS].find('iframe');
                                if(el.length) {
                                    // reset src after the popup is closed to avoid "video keeps playing after popup is closed" bug
                                    if(!isShowing) {
                                        el[0].src = _emptyPage;
                                    }

                                    // IE8 black screen bug fix
                                    if(mfp.isIE8) {
                                        el.css('display', isShowing ? 'block' : 'none');
                                    }
                                }
                            }
                        };

                    $.magnificPopup.registerModule(IFRAME_NS, {

                        options: {
                            markup: '<div class="mfp-iframe-scaler">'+
                                '<div class="mfp-close"></div>'+
                                '<iframe class="mfp-iframe" src="//about:blank" frameborder="0" allowfullscreen></iframe>'+
                                '</div>',

                            srcAction: 'iframe_src',

                            // we don't care and support only one default type of URL by default
                            patterns: {
                                youtube: {
                                    index: 'youtube.com',
                                    id: 'v=',
                                    src: '//www.youtube.com/embed/%id%?autoplay=1'
                                },
                                vimeo: {
                                    index: 'vimeo.com/',
                                    id: '/',
                                    src: '//player.vimeo.com/video/%id%?autoplay=1'
                                },
                                gmaps: {
                                    index: '//maps.google.',
                                    src: '%id%&output=embed'
                                }
                            }
                        },

                        proto: {
                            initIframe: function() {
                                mfp.types.push(IFRAME_NS);

                                _mfpOn('BeforeChange', function(e, prevType, newType) {
                                    if(prevType !== newType) {
                                        if(prevType === IFRAME_NS) {
                                            _fixIframeBugs(); // iframe if removed
                                        } else if(newType === IFRAME_NS) {
                                            _fixIframeBugs(true); // iframe is showing
                                        }
                                    }// else {
                                    // iframe source is switched, don't do anything
                                    //}
                                });

                                _mfpOn(CLOSE_EVENT + '.' + IFRAME_NS, function() {
                                    _fixIframeBugs();
                                });
                            },

                            getIframe: function(item, template) {
                                var embedSrc = item.src;
                                var iframeSt = mfp.st.iframe;

                                $.each(iframeSt.patterns, function() {
                                    if(embedSrc.indexOf( this.index ) > -1) {
                                        if(this.id) {
                                            if(typeof this.id === 'string') {
                                                embedSrc = embedSrc.substr(embedSrc.lastIndexOf(this.id)+this.id.length, embedSrc.length);
                                            } else {
                                                embedSrc = this.id.call( this, embedSrc );
                                            }
                                        }
                                        embedSrc = this.src.replace('%id%', embedSrc );
                                        return false; // break;
                                    }
                                });

                                var dataObj = {};
                                if(iframeSt.srcAction) {
                                    dataObj[iframeSt.srcAction] = embedSrc;
                                }
                                mfp._parseMarkup(template, dataObj, item);

                                mfp.updateStatus('ready');

                                return template;
                            }
                        }
                    });



                    /*>>iframe*/

                    /*>>gallery*/
                    /**
                     * Get looped index depending on number of slides
                     */
                    var _getLoopedId = function(index) {
                            var numSlides = mfp.items.length;
                            if(index > numSlides - 1) {
                                return index - numSlides;
                            } else  if(index < 0) {
                                return numSlides + index;
                            }
                            return index;
                        },
                        _replaceCurrTotal = function(text, curr, total) {
                            return text.replace(/%curr%/gi, curr + 1).replace(/%total%/gi, total);
                        };

                    $.magnificPopup.registerModule('gallery', {

                        options: {
                            enabled: false,
                            arrowMarkup: '<button title="%title%" type="button" class="mfp-arrow mfp-arrow-%dir%"></button>',
                            preload: [0,2],
                            navigateByImgClick: true,
                            arrows: true,

                            tPrev: 'Previous (Left arrow key)',
                            tNext: 'Next (Right arrow key)',
                            tCounter: '%curr% of %total%'
                        },

                        proto: {
                            initGallery: function() {

                                var gSt = mfp.st.gallery,
                                    ns = '.mfp-gallery';

                                mfp.direction = true; // true - next, false - prev

                                if(!gSt || !gSt.enabled ) return false;

                                _wrapClasses += ' mfp-gallery';

                                _mfpOn(OPEN_EVENT+ns, function() {

                                    if(gSt.navigateByImgClick) {
                                        mfp.wrap.on('click'+ns, '.mfp-img', function() {
                                            if(mfp.items.length > 1) {
                                                mfp.next();
                                                return false;
                                            }
                                        });
                                    }

                                    _document.on('keydown'+ns, function(e) {
                                        if (e.keyCode === 37) {
                                            mfp.prev();
                                        } else if (e.keyCode === 39) {
                                            mfp.next();
                                        }
                                    });
                                });

                                _mfpOn('UpdateStatus'+ns, function(e, data) {
                                    if(data.text) {
                                        data.text = _replaceCurrTotal(data.text, mfp.currItem.index, mfp.items.length);
                                    }
                                });

                                _mfpOn(MARKUP_PARSE_EVENT+ns, function(e, element, values, item) {
                                    var l = mfp.items.length;
                                    values.counter = l > 1 ? _replaceCurrTotal(gSt.tCounter, item.index, l) : '';
                                });

                                _mfpOn('BuildControls' + ns, function() {
                                    if(mfp.items.length > 1 && gSt.arrows && !mfp.arrowLeft) {
                                        var markup = gSt.arrowMarkup,
                                            arrowLeft = mfp.arrowLeft = $( markup.replace(/%title%/gi, gSt.tPrev).replace(/%dir%/gi, 'left') ).addClass(PREVENT_CLOSE_CLASS),
                                            arrowRight = mfp.arrowRight = $( markup.replace(/%title%/gi, gSt.tNext).replace(/%dir%/gi, 'right') ).addClass(PREVENT_CLOSE_CLASS);

                                        arrowLeft.click(function() {
                                            mfp.prev();
                                        });
                                        arrowRight.click(function() {
                                            mfp.next();
                                        });

                                        mfp.container.append(arrowLeft.add(arrowRight));
                                    }
                                });

                                _mfpOn(CHANGE_EVENT+ns, function() {
                                    if(mfp._preloadTimeout) clearTimeout(mfp._preloadTimeout);

                                    mfp._preloadTimeout = setTimeout(function() {
                                        mfp.preloadNearbyImages();
                                        mfp._preloadTimeout = null;
                                    }, 16);
                                });


                                _mfpOn(CLOSE_EVENT+ns, function() {
                                    _document.off(ns);
                                    mfp.wrap.off('click'+ns);
                                    mfp.arrowRight = mfp.arrowLeft = null;
                                });

                            },
                            next: function() {
                                mfp.direction = true;
                                mfp.index = _getLoopedId(mfp.index + 1);
                                mfp.updateItemHTML();
                            },
                            prev: function() {
                                mfp.direction = false;
                                mfp.index = _getLoopedId(mfp.index - 1);
                                mfp.updateItemHTML();
                            },
                            goTo: function(newIndex) {
                                mfp.direction = (newIndex >= mfp.index);
                                mfp.index = newIndex;
                                mfp.updateItemHTML();
                            },
                            preloadNearbyImages: function() {
                                var p = mfp.st.gallery.preload,
                                    preloadBefore = Math.min(p[0], mfp.items.length),
                                    preloadAfter = Math.min(p[1], mfp.items.length),
                                    i;

                                for(i = 1; i <= (mfp.direction ? preloadAfter : preloadBefore); i++) {
                                    mfp._preloadItem(mfp.index+i);
                                }
                                for(i = 1; i <= (mfp.direction ? preloadBefore : preloadAfter); i++) {
                                    mfp._preloadItem(mfp.index-i);
                                }
                            },
                            _preloadItem: function(index) {
                                index = _getLoopedId(index);

                                if(mfp.items[index].preloaded) {
                                    return;
                                }

                                var item = mfp.items[index];
                                if(!item.parsed) {
                                    item = mfp.parseEl( index );
                                }

                                _mfpTrigger('LazyLoad', item);

                                if(item.type === 'image') {
                                    item.img = $('<img class="mfp-img" />').on('load.mfploader', function() {
                                        item.hasSize = true;
                                    }).on('error.mfploader', function() {
                                        item.hasSize = true;
                                        item.loadError = true;
                                        _mfpTrigger('LazyLoadError', item);
                                    }).attr('src', item.src);
                                }


                                item.preloaded = true;
                            }
                        }
                    });

                    /*>>gallery*/

                    /*>>retina*/

                    var RETINA_NS = 'retina';

                    $.magnificPopup.registerModule(RETINA_NS, {
                        options: {
                            replaceSrc: function(item) {
                                return item.src.replace(/\.\w+$/, function(m) { return '@2x' + m; });
                            },
                            ratio: 1 // Function or number.  Set to 1 to disable.
                        },
                        proto: {
                            initRetina: function() {
                                if(window.devicePixelRatio > 1) {

                                    var st = mfp.st.retina,
                                        ratio = st.ratio;

                                    ratio = !isNaN(ratio) ? ratio : ratio();

                                    if(ratio > 1) {
                                        _mfpOn('ImageHasSize' + '.' + RETINA_NS, function(e, item) {
                                            item.img.css({
                                                'max-width': item.img[0].naturalWidth / ratio,
                                                'width': '100%'
                                            });
                                        });
                                        _mfpOn('ElementParse' + '.' + RETINA_NS, function(e, item) {
                                            item.src = st.replaceSrc(item, ratio);
                                        });
                                    }
                                }

                            }
                        }
                    });

                    /*>>retina*/
                    _checkInstance(); }));
                /* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

            /***/ }),

        /***/ "./node_modules/owl.carousel/dist/owl.carousel.js":
        /*!********************************************************!*\
  !*** ./node_modules/owl.carousel/dist/owl.carousel.js ***!
  \********************************************************/
        /*! no static exports found */
        /***/ (function(module, exports, __webpack_require__) {

            /* WEBPACK VAR INJECTION */(function(__webpack_provided_window_dot_jQuery, jQuery) {/**
             * Owl Carousel v2.3.4
             * Copyright 2013-2018 David Deutsch
             * Licensed under: SEE LICENSE IN https://github.com/OwlCarousel2/OwlCarousel2/blob/master/LICENSE
             */
                /**
                 * Owl carousel
                 * @version 2.3.4
                 * @author Bartosz Wojciechowski
                 * @author David Deutsch
                 * @license The MIT License (MIT)
                 * @todo Lazy Load Icon
                 * @todo prevent animationend bubling
                 * @todo itemsScaleUp
                 * @todo Test Zepto
                 * @todo stagePadding calculate wrong active classes
                 */
                ;(function($, window, document, undefined) {

                    /**
                     * Creates a carousel.
                     * @class The Owl Carousel.
                     * @public
                     * @param {HTMLElement|jQuery} element - The element to create the carousel for.
                     * @param {Object} [options] - The options
                     */
                    function Owl(element, options) {

                        /**
                         * Current settings for the carousel.
                         * @public
                         */
                        this.settings = null;

                        /**
                         * Current options set by the caller including defaults.
                         * @public
                         */
                        this.options = $.extend({}, Owl.Defaults, options);

                        /**
                         * Plugin element.
                         * @public
                         */
                        this.$element = $(element);

                        /**
                         * Proxied event handlers.
                         * @protected
                         */
                        this._handlers = {};

                        /**
                         * References to the running plugins of this carousel.
                         * @protected
                         */
                        this._plugins = {};

                        /**
                         * Currently suppressed events to prevent them from being retriggered.
                         * @protected
                         */
                        this._supress = {};

                        /**
                         * Absolute current position.
                         * @protected
                         */
                        this._current = null;

                        /**
                         * Animation speed in milliseconds.
                         * @protected
                         */
                        this._speed = null;

                        /**
                         * Coordinates of all items in pixel.
                         * @todo The name of this member is missleading.
                         * @protected
                         */
                        this._coordinates = [];

                        /**
                         * Current breakpoint.
                         * @todo Real media queries would be nice.
                         * @protected
                         */
                        this._breakpoint = null;

                        /**
                         * Current width of the plugin element.
                         */
                        this._width = null;

                        /**
                         * All real items.
                         * @protected
                         */
                        this._items = [];

                        /**
                         * All cloned items.
                         * @protected
                         */
                        this._clones = [];

                        /**
                         * Merge values of all items.
                         * @todo Maybe this could be part of a plugin.
                         * @protected
                         */
                        this._mergers = [];

                        /**
                         * Widths of all items.
                         */
                        this._widths = [];

                        /**
                         * Invalidated parts within the update process.
                         * @protected
                         */
                        this._invalidated = {};

                        /**
                         * Ordered list of workers for the update process.
                         * @protected
                         */
                        this._pipe = [];

                        /**
                         * Current state information for the drag operation.
                         * @todo #261
                         * @protected
                         */
                        this._drag = {
                            time: null,
                            target: null,
                            pointer: null,
                            stage: {
                                start: null,
                                current: null
                            },
                            direction: null
                        };

                        /**
                         * Current state information and their tags.
                         * @type {Object}
                         * @protected
                         */
                        this._states = {
                            current: {},
                            tags: {
                                'initializing': [ 'busy' ],
                                'animating': [ 'busy' ],
                                'dragging': [ 'interacting' ]
                            }
                        };

                        $.each([ 'onResize', 'onThrottledResize' ], $.proxy(function(i, handler) {
                            this._handlers[handler] = $.proxy(this[handler], this);
                        }, this));

                        $.each(Owl.Plugins, $.proxy(function(key, plugin) {
                            this._plugins[key.charAt(0).toLowerCase() + key.slice(1)]
                                = new plugin(this);
                        }, this));

                        $.each(Owl.Workers, $.proxy(function(priority, worker) {
                            this._pipe.push({
                                'filter': worker.filter,
                                'run': $.proxy(worker.run, this)
                            });
                        }, this));

                        this.setup();
                        this.initialize();
                    }

                    /**
                     * Default options for the carousel.
                     * @public
                     */
                    Owl.Defaults = {
                        items: 3,
                        loop: false,
                        center: false,
                        rewind: false,
                        checkVisibility: true,

                        mouseDrag: true,
                        touchDrag: true,
                        pullDrag: true,
                        freeDrag: false,

                        margin: 0,
                        stagePadding: 0,

                        merge: false,
                        mergeFit: true,
                        autoWidth: false,

                        startPosition: 0,
                        rtl: false,

                        smartSpeed: 250,
                        fluidSpeed: false,
                        dragEndSpeed: false,

                        responsive: {},
                        responsiveRefreshRate: 200,
                        responsiveBaseElement: window,

                        fallbackEasing: 'swing',
                        slideTransition: '',

                        info: false,

                        nestedItemSelector: false,
                        itemElement: 'div',
                        stageElement: 'div',

                        refreshClass: 'owl-refresh',
                        loadedClass: 'owl-loaded',
                        loadingClass: 'owl-loading',
                        rtlClass: 'owl-rtl',
                        responsiveClass: 'owl-responsive',
                        dragClass: 'owl-drag',
                        itemClass: 'owl-item',
                        stageClass: 'owl-stage',
                        stageOuterClass: 'owl-stage-outer',
                        grabClass: 'owl-grab'
                    };

                    /**
                     * Enumeration for width.
                     * @public
                     * @readonly
                     * @enum {String}
                     */
                    Owl.Width = {
                        Default: 'default',
                        Inner: 'inner',
                        Outer: 'outer'
                    };

                    /**
                     * Enumeration for types.
                     * @public
                     * @readonly
                     * @enum {String}
                     */
                    Owl.Type = {
                        Event: 'event',
                        State: 'state'
                    };

                    /**
                     * Contains all registered plugins.
                     * @public
                     */
                    Owl.Plugins = {};

                    /**
                     * List of workers involved in the update process.
                     */
                    Owl.Workers = [ {
                        filter: [ 'width', 'settings' ],
                        run: function() {
                            this._width = this.$element.width();
                        }
                    }, {
                        filter: [ 'width', 'items', 'settings' ],
                        run: function(cache) {
                            cache.current = this._items && this._items[this.relative(this._current)];
                        }
                    }, {
                        filter: [ 'items', 'settings' ],
                        run: function() {
                            this.$stage.children('.cloned').remove();
                        }
                    }, {
                        filter: [ 'width', 'items', 'settings' ],
                        run: function(cache) {
                            var margin = this.settings.margin || '',
                                grid = !this.settings.autoWidth,
                                rtl = this.settings.rtl,
                                css = {
                                    'width': 'auto',
                                    'margin-left': rtl ? margin : '',
                                    'margin-right': rtl ? '' : margin
                                };

                            !grid && this.$stage.children().css(css);

                            cache.css = css;
                        }
                    }, {
                        filter: [ 'width', 'items', 'settings' ],
                        run: function(cache) {
                            var width = (this.width() / this.settings.items).toFixed(3) - this.settings.margin,
                                merge = null,
                                iterator = this._items.length,
                                grid = !this.settings.autoWidth,
                                widths = [];

                            cache.items = {
                                merge: false,
                                width: width
                            };

                            while (iterator--) {
                                merge = this._mergers[iterator];
                                merge = this.settings.mergeFit && Math.min(merge, this.settings.items) || merge;

                                cache.items.merge = merge > 1 || cache.items.merge;

                                widths[iterator] = !grid ? this._items[iterator].width() : width * merge;
                            }

                            this._widths = widths;
                        }
                    }, {
                        filter: [ 'items', 'settings' ],
                        run: function() {
                            var clones = [],
                                items = this._items,
                                settings = this.settings,
                                // TODO: Should be computed from number of min width items in stage
                                view = Math.max(settings.items * 2, 4),
                                size = Math.ceil(items.length / 2) * 2,
                                repeat = settings.loop && items.length ? settings.rewind ? view : Math.max(view, size) : 0,
                                append = '',
                                prepend = '';

                            repeat /= 2;

                            while (repeat > 0) {
                                // Switch to only using appended clones
                                clones.push(this.normalize(clones.length / 2, true));
                                append = append + items[clones[clones.length - 1]][0].outerHTML;
                                clones.push(this.normalize(items.length - 1 - (clones.length - 1) / 2, true));
                                prepend = items[clones[clones.length - 1]][0].outerHTML + prepend;
                                repeat -= 1;
                            }

                            this._clones = clones;

                            $(append).addClass('cloned').appendTo(this.$stage);
                            $(prepend).addClass('cloned').prependTo(this.$stage);
                        }
                    }, {
                        filter: [ 'width', 'items', 'settings' ],
                        run: function() {
                            var rtl = this.settings.rtl ? 1 : -1,
                                size = this._clones.length + this._items.length,
                                iterator = -1,
                                previous = 0,
                                current = 0,
                                coordinates = [];

                            while (++iterator < size) {
                                previous = coordinates[iterator - 1] || 0;
                                current = this._widths[this.relative(iterator)] + this.settings.margin;
                                coordinates.push(previous + current * rtl);
                            }

                            this._coordinates = coordinates;
                        }
                    }, {
                        filter: [ 'width', 'items', 'settings' ],
                        run: function() {
                            var padding = this.settings.stagePadding,
                                coordinates = this._coordinates,
                                css = {
                                    'width': Math.ceil(Math.abs(coordinates[coordinates.length - 1])) + padding * 2,
                                    'padding-left': padding || '',
                                    'padding-right': padding || ''
                                };

                            this.$stage.css(css);
                        }
                    }, {
                        filter: [ 'width', 'items', 'settings' ],
                        run: function(cache) {
                            var iterator = this._coordinates.length,
                                grid = !this.settings.autoWidth,
                                items = this.$stage.children();

                            if (grid && cache.items.merge) {
                                while (iterator--) {
                                    cache.css.width = this._widths[this.relative(iterator)];
                                    items.eq(iterator).css(cache.css);
                                }
                            } else if (grid) {
                                cache.css.width = cache.items.width;
                                items.css(cache.css);
                            }
                        }
                    }, {
                        filter: [ 'items' ],
                        run: function() {
                            this._coordinates.length < 1 && this.$stage.removeAttr('style');
                        }
                    }, {
                        filter: [ 'width', 'items', 'settings' ],
                        run: function(cache) {
                            cache.current = cache.current ? this.$stage.children().index(cache.current) : 0;
                            cache.current = Math.max(this.minimum(), Math.min(this.maximum(), cache.current));
                            this.reset(cache.current);
                        }
                    }, {
                        filter: [ 'position' ],
                        run: function() {
                            this.animate(this.coordinates(this._current));
                        }
                    }, {
                        filter: [ 'width', 'position', 'items', 'settings' ],
                        run: function() {
                            var rtl = this.settings.rtl ? 1 : -1,
                                padding = this.settings.stagePadding * 2,
                                begin = this.coordinates(this.current()) + padding,
                                end = begin + this.width() * rtl,
                                inner, outer, matches = [], i, n;

                            for (i = 0, n = this._coordinates.length; i < n; i++) {
                                inner = this._coordinates[i - 1] || 0;
                                outer = Math.abs(this._coordinates[i]) + padding * rtl;

                                if ((this.op(inner, '<=', begin) && (this.op(inner, '>', end)))
                                    || (this.op(outer, '<', begin) && this.op(outer, '>', end))) {
                                    matches.push(i);
                                }
                            }

                            this.$stage.children('.active').removeClass('active');
                            this.$stage.children(':eq(' + matches.join('), :eq(') + ')').addClass('active');

                            this.$stage.children('.center').removeClass('center');
                            if (this.settings.center) {
                                this.$stage.children().eq(this.current()).addClass('center');
                            }
                        }
                    } ];

                    /**
                     * Create the stage DOM element
                     */
                    Owl.prototype.initializeStage = function() {
                        this.$stage = this.$element.find('.' + this.settings.stageClass);

                        // if the stage is already in the DOM, grab it and skip stage initialization
                        if (this.$stage.length) {
                            return;
                        }

                        this.$element.addClass(this.options.loadingClass);

                        // create stage
                        this.$stage = $('<' + this.settings.stageElement + '>', {
                            "class": this.settings.stageClass
                        }).wrap( $( '<div/>', {
                            "class": this.settings.stageOuterClass
                        }));

                        // append stage
                        this.$element.append(this.$stage.parent());
                    };

                    /**
                     * Create item DOM elements
                     */
                    Owl.prototype.initializeItems = function() {
                        var $items = this.$element.find('.owl-item');

                        // if the items are already in the DOM, grab them and skip item initialization
                        if ($items.length) {
                            this._items = $items.get().map(function(item) {
                                return $(item);
                            });

                            this._mergers = this._items.map(function() {
                                return 1;
                            });

                            this.refresh();

                            return;
                        }

                        // append content
                        this.replace(this.$element.children().not(this.$stage.parent()));

                        // check visibility
                        if (this.isVisible()) {
                            // update view
                            this.refresh();
                        } else {
                            // invalidate width
                            this.invalidate('width');
                        }

                        this.$element
                            .removeClass(this.options.loadingClass)
                            .addClass(this.options.loadedClass);
                    };

                    /**
                     * Initializes the carousel.
                     * @protected
                     */
                    Owl.prototype.initialize = function() {
                        this.enter('initializing');
                        this.trigger('initialize');

                        this.$element.toggleClass(this.settings.rtlClass, this.settings.rtl);

                        if (this.settings.autoWidth && !this.is('pre-loading')) {
                            var imgs, nestedSelector, width;
                            imgs = this.$element.find('img');
                            nestedSelector = this.settings.nestedItemSelector ? '.' + this.settings.nestedItemSelector : undefined;
                            width = this.$element.children(nestedSelector).width();

                            if (imgs.length && width <= 0) {
                                this.preloadAutoWidthImages(imgs);
                            }
                        }

                        this.initializeStage();
                        this.initializeItems();

                        // register event handlers
                        this.registerEventHandlers();

                        this.leave('initializing');
                        this.trigger('initialized');
                    };

                    /**
                     * @returns {Boolean} visibility of $element
                     *                    if you know the carousel will always be visible you can set `checkVisibility` to `false` to
                     *                    prevent the expensive browser layout forced reflow the $element.is(':visible') does
                     */
                    Owl.prototype.isVisible = function() {
                        return this.settings.checkVisibility
                            ? this.$element.is(':visible')
                            : true;
                    };

                    /**
                     * Setups the current settings.
                     * @todo Remove responsive classes. Why should adaptive designs be brought into IE8?
                     * @todo Support for media queries by using `matchMedia` would be nice.
                     * @public
                     */
                    Owl.prototype.setup = function() {
                        var viewport = this.viewport(),
                            overwrites = this.options.responsive,
                            match = -1,
                            settings = null;

                        if (!overwrites) {
                            settings = $.extend({}, this.options);
                        } else {
                            $.each(overwrites, function(breakpoint) {
                                if (breakpoint <= viewport && breakpoint > match) {
                                    match = Number(breakpoint);
                                }
                            });

                            settings = $.extend({}, this.options, overwrites[match]);
                            if (typeof settings.stagePadding === 'function') {
                                settings.stagePadding = settings.stagePadding();
                            }
                            delete settings.responsive;

                            // responsive class
                            if (settings.responsiveClass) {
                                this.$element.attr('class',
                                    this.$element.attr('class').replace(new RegExp('(' + this.options.responsiveClass + '-)\\S+\\s', 'g'), '$1' + match)
                                );
                            }
                        }

                        this.trigger('change', { property: { name: 'settings', value: settings } });
                        this._breakpoint = match;
                        this.settings = settings;
                        this.invalidate('settings');
                        this.trigger('changed', { property: { name: 'settings', value: this.settings } });
                    };

                    /**
                     * Updates option logic if necessery.
                     * @protected
                     */
                    Owl.prototype.optionsLogic = function() {
                        if (this.settings.autoWidth) {
                            this.settings.stagePadding = false;
                            this.settings.merge = false;
                        }
                    };

                    /**
                     * Prepares an item before add.
                     * @todo Rename event parameter `content` to `item`.
                     * @protected
                     * @returns {jQuery|HTMLElement} - The item container.
                     */
                    Owl.prototype.prepare = function(item) {
                        var event = this.trigger('prepare', { content: item });

                        if (!event.data) {
                            event.data = $('<' + this.settings.itemElement + '/>')
                                .addClass(this.options.itemClass).append(item)
                        }

                        this.trigger('prepared', { content: event.data });

                        return event.data;
                    };

                    /**
                     * Updates the view.
                     * @public
                     */
                    Owl.prototype.update = function() {
                        var i = 0,
                            n = this._pipe.length,
                            filter = $.proxy(function(p) { return this[p] }, this._invalidated),
                            cache = {};

                        while (i < n) {
                            if (this._invalidated.all || $.grep(this._pipe[i].filter, filter).length > 0) {
                                this._pipe[i].run(cache);
                            }
                            i++;
                        }

                        this._invalidated = {};

                        !this.is('valid') && this.enter('valid');
                    };

                    /**
                     * Gets the width of the view.
                     * @public
                     * @param {Owl.Width} [dimension=Owl.Width.Default] - The dimension to return.
                     * @returns {Number} - The width of the view in pixel.
                     */
                    Owl.prototype.width = function(dimension) {
                        dimension = dimension || Owl.Width.Default;
                        switch (dimension) {
                            case Owl.Width.Inner:
                            case Owl.Width.Outer:
                                return this._width;
                            default:
                                return this._width - this.settings.stagePadding * 2 + this.settings.margin;
                        }
                    };

                    /**
                     * Refreshes the carousel primarily for adaptive purposes.
                     * @public
                     */
                    Owl.prototype.refresh = function() {
                        this.enter('refreshing');
                        this.trigger('refresh');

                        this.setup();

                        this.optionsLogic();

                        this.$element.addClass(this.options.refreshClass);

                        this.update();

                        this.$element.removeClass(this.options.refreshClass);

                        this.leave('refreshing');
                        this.trigger('refreshed');
                    };

                    /**
                     * Checks window `resize` event.
                     * @protected
                     */
                    Owl.prototype.onThrottledResize = function() {
                        window.clearTimeout(this.resizeTimer);
                        this.resizeTimer = window.setTimeout(this._handlers.onResize, this.settings.responsiveRefreshRate);
                    };

                    /**
                     * Checks window `resize` event.
                     * @protected
                     */
                    Owl.prototype.onResize = function() {
                        if (!this._items.length) {
                            return false;
                        }

                        if (this._width === this.$element.width()) {
                            return false;
                        }

                        if (!this.isVisible()) {
                            return false;
                        }

                        this.enter('resizing');

                        if (this.trigger('resize').isDefaultPrevented()) {
                            this.leave('resizing');
                            return false;
                        }

                        this.invalidate('width');

                        this.refresh();

                        this.leave('resizing');
                        this.trigger('resized');
                    };

                    /**
                     * Registers event handlers.
                     * @todo Check `msPointerEnabled`
                     * @todo #261
                     * @protected
                     */
                    Owl.prototype.registerEventHandlers = function() {
                        if ($.support.transition) {
                            this.$stage.on($.support.transition.end + '.owl.core', $.proxy(this.onTransitionEnd, this));
                        }

                        if (this.settings.responsive !== false) {
                            this.on(window, 'resize', this._handlers.onThrottledResize);
                        }

                        if (this.settings.mouseDrag) {
                            this.$element.addClass(this.options.dragClass);
                            this.$stage.on('mousedown.owl.core', $.proxy(this.onDragStart, this));
                            this.$stage.on('dragstart.owl.core selectstart.owl.core', function() { return false });
                        }

                        if (this.settings.touchDrag){
                            this.$stage.on('touchstart.owl.core', $.proxy(this.onDragStart, this));
                            this.$stage.on('touchcancel.owl.core', $.proxy(this.onDragEnd, this));
                        }
                    };

                    /**
                     * Handles `touchstart` and `mousedown` events.
                     * @todo Horizontal swipe threshold as option
                     * @todo #261
                     * @protected
                     * @param {Event} event - The event arguments.
                     */
                    Owl.prototype.onDragStart = function(event) {
                        var stage = null;

                        if (event.which === 3) {
                            return;
                        }

                        if ($.support.transform) {
                            stage = this.$stage.css('transform').replace(/.*\(|\)| /g, '').split(',');
                            stage = {
                                x: stage[stage.length === 16 ? 12 : 4],
                                y: stage[stage.length === 16 ? 13 : 5]
                            };
                        } else {
                            stage = this.$stage.position();
                            stage = {
                                x: this.settings.rtl ?
                                    stage.left + this.$stage.width() - this.width() + this.settings.margin :
                                    stage.left,
                                y: stage.top
                            };
                        }

                        if (this.is('animating')) {
                            $.support.transform ? this.animate(stage.x) : this.$stage.stop()
                            this.invalidate('position');
                        }

                        this.$element.toggleClass(this.options.grabClass, event.type === 'mousedown');

                        this.speed(0);

                        this._drag.time = new Date().getTime();
                        this._drag.target = $(event.target);
                        this._drag.stage.start = stage;
                        this._drag.stage.current = stage;
                        this._drag.pointer = this.pointer(event);

                        $(document).on('mouseup.owl.core touchend.owl.core', $.proxy(this.onDragEnd, this));

                        $(document).one('mousemove.owl.core touchmove.owl.core', $.proxy(function(event) {
                            var delta = this.difference(this._drag.pointer, this.pointer(event));

                            $(document).on('mousemove.owl.core touchmove.owl.core', $.proxy(this.onDragMove, this));

                            if (Math.abs(delta.x) < Math.abs(delta.y) && this.is('valid')) {
                                return;
                            }

                            event.preventDefault();

                            this.enter('dragging');
                            this.trigger('drag');
                        }, this));
                    };

                    /**
                     * Handles the `touchmove` and `mousemove` events.
                     * @todo #261
                     * @protected
                     * @param {Event} event - The event arguments.
                     */
                    Owl.prototype.onDragMove = function(event) {
                        var minimum = null,
                            maximum = null,
                            pull = null,
                            delta = this.difference(this._drag.pointer, this.pointer(event)),
                            stage = this.difference(this._drag.stage.start, delta);

                        if (!this.is('dragging')) {
                            return;
                        }

                        event.preventDefault();

                        if (this.settings.loop) {
                            minimum = this.coordinates(this.minimum());
                            maximum = this.coordinates(this.maximum() + 1) - minimum;
                            stage.x = (((stage.x - minimum) % maximum + maximum) % maximum) + minimum;
                        } else {
                            minimum = this.settings.rtl ? this.coordinates(this.maximum()) : this.coordinates(this.minimum());
                            maximum = this.settings.rtl ? this.coordinates(this.minimum()) : this.coordinates(this.maximum());
                            pull = this.settings.pullDrag ? -1 * delta.x / 5 : 0;
                            stage.x = Math.max(Math.min(stage.x, minimum + pull), maximum + pull);
                        }

                        this._drag.stage.current = stage;

                        this.animate(stage.x);
                    };

                    /**
                     * Handles the `touchend` and `mouseup` events.
                     * @todo #261
                     * @todo Threshold for click event
                     * @protected
                     * @param {Event} event - The event arguments.
                     */
                    Owl.prototype.onDragEnd = function(event) {
                        var delta = this.difference(this._drag.pointer, this.pointer(event)),
                            stage = this._drag.stage.current,
                            direction = delta.x > 0 ^ this.settings.rtl ? 'left' : 'right';

                        $(document).off('.owl.core');

                        this.$element.removeClass(this.options.grabClass);

                        if (delta.x !== 0 && this.is('dragging') || !this.is('valid')) {
                            this.speed(this.settings.dragEndSpeed || this.settings.smartSpeed);
                            this.current(this.closest(stage.x, delta.x !== 0 ? direction : this._drag.direction));
                            this.invalidate('position');
                            this.update();

                            this._drag.direction = direction;

                            if (Math.abs(delta.x) > 3 || new Date().getTime() - this._drag.time > 300) {
                                this._drag.target.one('click.owl.core', function() { return false; });
                            }
                        }

                        if (!this.is('dragging')) {
                            return;
                        }

                        this.leave('dragging');
                        this.trigger('dragged');
                    };

                    /**
                     * Gets absolute position of the closest item for a coordinate.
                     * @todo Setting `freeDrag` makes `closest` not reusable. See #165.
                     * @protected
                     * @param {Number} coordinate - The coordinate in pixel.
                     * @param {String} direction - The direction to check for the closest item. Ether `left` or `right`.
                     * @return {Number} - The absolute position of the closest item.
                     */
                    Owl.prototype.closest = function(coordinate, direction) {
                        var position = -1,
                            pull = 30,
                            width = this.width(),
                            coordinates = this.coordinates();

                        if (!this.settings.freeDrag) {
                            // check closest item
                            $.each(coordinates, $.proxy(function(index, value) {
                                // on a left pull, check on current index
                                if (direction === 'left' && coordinate > value - pull && coordinate < value + pull) {
                                    position = index;
                                    // on a right pull, check on previous index
                                    // to do so, subtract width from value and set position = index + 1
                                } else if (direction === 'right' && coordinate > value - width - pull && coordinate < value - width + pull) {
                                    position = index + 1;
                                } else if (this.op(coordinate, '<', value)
                                    && this.op(coordinate, '>', coordinates[index + 1] !== undefined ? coordinates[index + 1] : value - width)) {
                                    position = direction === 'left' ? index + 1 : index;
                                }
                                return position === -1;
                            }, this));
                        }

                        if (!this.settings.loop) {
                            // non loop boundries
                            if (this.op(coordinate, '>', coordinates[this.minimum()])) {
                                position = coordinate = this.minimum();
                            } else if (this.op(coordinate, '<', coordinates[this.maximum()])) {
                                position = coordinate = this.maximum();
                            }
                        }

                        return position;
                    };

                    /**
                     * Animates the stage.
                     * @todo #270
                     * @public
                     * @param {Number} coordinate - The coordinate in pixels.
                     */
                    Owl.prototype.animate = function(coordinate) {
                        var animate = this.speed() > 0;

                        this.is('animating') && this.onTransitionEnd();

                        if (animate) {
                            this.enter('animating');
                            this.trigger('translate');
                        }

                        if ($.support.transform3d && $.support.transition) {
                            this.$stage.css({
                                transform: 'translate3d(' + coordinate + 'px,0px,0px)',
                                transition: (this.speed() / 1000) + 's' + (
                                    this.settings.slideTransition ? ' ' + this.settings.slideTransition : ''
                                )
                            });
                        } else if (animate) {
                            this.$stage.animate({
                                left: coordinate + 'px'
                            }, this.speed(), this.settings.fallbackEasing, $.proxy(this.onTransitionEnd, this));
                        } else {
                            this.$stage.css({
                                left: coordinate + 'px'
                            });
                        }
                    };

                    /**
                     * Checks whether the carousel is in a specific state or not.
                     * @param {String} state - The state to check.
                     * @returns {Boolean} - The flag which indicates if the carousel is busy.
                     */
                    Owl.prototype.is = function(state) {
                        return this._states.current[state] && this._states.current[state] > 0;
                    };

                    /**
                     * Sets the absolute position of the current item.
                     * @public
                     * @param {Number} [position] - The new absolute position or nothing to leave it unchanged.
                     * @returns {Number} - The absolute position of the current item.
                     */
                    Owl.prototype.current = function(position) {
                        if (position === undefined) {
                            return this._current;
                        }

                        if (this._items.length === 0) {
                            return undefined;
                        }

                        position = this.normalize(position);

                        if (this._current !== position) {
                            var event = this.trigger('change', { property: { name: 'position', value: position } });

                            if (event.data !== undefined) {
                                position = this.normalize(event.data);
                            }

                            this._current = position;

                            this.invalidate('position');

                            this.trigger('changed', { property: { name: 'position', value: this._current } });
                        }

                        return this._current;
                    };

                    /**
                     * Invalidates the given part of the update routine.
                     * @param {String} [part] - The part to invalidate.
                     * @returns {Array.<String>} - The invalidated parts.
                     */
                    Owl.prototype.invalidate = function(part) {
                        if ($.type(part) === 'string') {
                            this._invalidated[part] = true;
                            this.is('valid') && this.leave('valid');
                        }
                        return $.map(this._invalidated, function(v, i) { return i });
                    };

                    /**
                     * Resets the absolute position of the current item.
                     * @public
                     * @param {Number} position - The absolute position of the new item.
                     */
                    Owl.prototype.reset = function(position) {
                        position = this.normalize(position);

                        if (position === undefined) {
                            return;
                        }

                        this._speed = 0;
                        this._current = position;

                        this.suppress([ 'translate', 'translated' ]);

                        this.animate(this.coordinates(position));

                        this.release([ 'translate', 'translated' ]);
                    };

                    /**
                     * Normalizes an absolute or a relative position of an item.
                     * @public
                     * @param {Number} position - The absolute or relative position to normalize.
                     * @param {Boolean} [relative=false] - Whether the given position is relative or not.
                     * @returns {Number} - The normalized position.
                     */
                    Owl.prototype.normalize = function(position, relative) {
                        var n = this._items.length,
                            m = relative ? 0 : this._clones.length;

                        if (!this.isNumeric(position) || n < 1) {
                            position = undefined;
                        } else if (position < 0 || position >= n + m) {
                            position = ((position - m / 2) % n + n) % n + m / 2;
                        }

                        return position;
                    };

                    /**
                     * Converts an absolute position of an item into a relative one.
                     * @public
                     * @param {Number} position - The absolute position to convert.
                     * @returns {Number} - The converted position.
                     */
                    Owl.prototype.relative = function(position) {
                        position -= this._clones.length / 2;
                        return this.normalize(position, true);
                    };

                    /**
                     * Gets the maximum position for the current item.
                     * @public
                     * @param {Boolean} [relative=false] - Whether to return an absolute position or a relative position.
                     * @returns {Number}
                     */
                    Owl.prototype.maximum = function(relative) {
                        var settings = this.settings,
                            maximum = this._coordinates.length,
                            iterator,
                            reciprocalItemsWidth,
                            elementWidth;

                        if (settings.loop) {
                            maximum = this._clones.length / 2 + this._items.length - 1;
                        } else if (settings.autoWidth || settings.merge) {
                            iterator = this._items.length;
                            if (iterator) {
                                reciprocalItemsWidth = this._items[--iterator].width();
                                elementWidth = this.$element.width();
                                while (iterator--) {
                                    reciprocalItemsWidth += this._items[iterator].width() + this.settings.margin;
                                    if (reciprocalItemsWidth > elementWidth) {
                                        break;
                                    }
                                }
                            }
                            maximum = iterator + 1;
                        } else if (settings.center) {
                            maximum = this._items.length - 1;
                        } else {
                            maximum = this._items.length - settings.items;
                        }

                        if (relative) {
                            maximum -= this._clones.length / 2;
                        }

                        return Math.max(maximum, 0);
                    };

                    /**
                     * Gets the minimum position for the current item.
                     * @public
                     * @param {Boolean} [relative=false] - Whether to return an absolute position or a relative position.
                     * @returns {Number}
                     */
                    Owl.prototype.minimum = function(relative) {
                        return relative ? 0 : this._clones.length / 2;
                    };

                    /**
                     * Gets an item at the specified relative position.
                     * @public
                     * @param {Number} [position] - The relative position of the item.
                     * @return {jQuery|Array.<jQuery>} - The item at the given position or all items if no position was given.
                     */
                    Owl.prototype.items = function(position) {
                        if (position === undefined) {
                            return this._items.slice();
                        }

                        position = this.normalize(position, true);
                        return this._items[position];
                    };

                    /**
                     * Gets an item at the specified relative position.
                     * @public
                     * @param {Number} [position] - The relative position of the item.
                     * @return {jQuery|Array.<jQuery>} - The item at the given position or all items if no position was given.
                     */
                    Owl.prototype.mergers = function(position) {
                        if (position === undefined) {
                            return this._mergers.slice();
                        }

                        position = this.normalize(position, true);
                        return this._mergers[position];
                    };

                    /**
                     * Gets the absolute positions of clones for an item.
                     * @public
                     * @param {Number} [position] - The relative position of the item.
                     * @returns {Array.<Number>} - The absolute positions of clones for the item or all if no position was given.
                     */
                    Owl.prototype.clones = function(position) {
                        var odd = this._clones.length / 2,
                            even = odd + this._items.length,
                            map = function(index) { return index % 2 === 0 ? even + index / 2 : odd - (index + 1) / 2 };

                        if (position === undefined) {
                            return $.map(this._clones, function(v, i) { return map(i) });
                        }

                        return $.map(this._clones, function(v, i) { return v === position ? map(i) : null });
                    };

                    /**
                     * Sets the current animation speed.
                     * @public
                     * @param {Number} [speed] - The animation speed in milliseconds or nothing to leave it unchanged.
                     * @returns {Number} - The current animation speed in milliseconds.
                     */
                    Owl.prototype.speed = function(speed) {
                        if (speed !== undefined) {
                            this._speed = speed;
                        }

                        return this._speed;
                    };

                    /**
                     * Gets the coordinate of an item.
                     * @todo The name of this method is missleanding.
                     * @public
                     * @param {Number} position - The absolute position of the item within `minimum()` and `maximum()`.
                     * @returns {Number|Array.<Number>} - The coordinate of the item in pixel or all coordinates.
                     */
                    Owl.prototype.coordinates = function(position) {
                        var multiplier = 1,
                            newPosition = position - 1,
                            coordinate;

                        if (position === undefined) {
                            return $.map(this._coordinates, $.proxy(function(coordinate, index) {
                                return this.coordinates(index);
                            }, this));
                        }

                        if (this.settings.center) {
                            if (this.settings.rtl) {
                                multiplier = -1;
                                newPosition = position + 1;
                            }

                            coordinate = this._coordinates[position];
                            coordinate += (this.width() - coordinate + (this._coordinates[newPosition] || 0)) / 2 * multiplier;
                        } else {
                            coordinate = this._coordinates[newPosition] || 0;
                        }

                        coordinate = Math.ceil(coordinate);

                        return coordinate;
                    };

                    /**
                     * Calculates the speed for a translation.
                     * @protected
                     * @param {Number} from - The absolute position of the start item.
                     * @param {Number} to - The absolute position of the target item.
                     * @param {Number} [factor=undefined] - The time factor in milliseconds.
                     * @returns {Number} - The time in milliseconds for the translation.
                     */
                    Owl.prototype.duration = function(from, to, factor) {
                        if (factor === 0) {
                            return 0;
                        }

                        return Math.min(Math.max(Math.abs(to - from), 1), 6) * Math.abs((factor || this.settings.smartSpeed));
                    };

                    /**
                     * Slides to the specified item.
                     * @public
                     * @param {Number} position - The position of the item.
                     * @param {Number} [speed] - The time in milliseconds for the transition.
                     */
                    Owl.prototype.to = function(position, speed) {
                        var current = this.current(),
                            revert = null,
                            distance = position - this.relative(current),
                            direction = (distance > 0) - (distance < 0),
                            items = this._items.length,
                            minimum = this.minimum(),
                            maximum = this.maximum();

                        if (this.settings.loop) {
                            if (!this.settings.rewind && Math.abs(distance) > items / 2) {
                                distance += direction * -1 * items;
                            }

                            position = current + distance;
                            revert = ((position - minimum) % items + items) % items + minimum;

                            if (revert !== position && revert - distance <= maximum && revert - distance > 0) {
                                current = revert - distance;
                                position = revert;
                                this.reset(current);
                            }
                        } else if (this.settings.rewind) {
                            maximum += 1;
                            position = (position % maximum + maximum) % maximum;
                        } else {
                            position = Math.max(minimum, Math.min(maximum, position));
                        }

                        this.speed(this.duration(current, position, speed));
                        this.current(position);

                        if (this.isVisible()) {
                            this.update();
                        }
                    };

                    /**
                     * Slides to the next item.
                     * @public
                     * @param {Number} [speed] - The time in milliseconds for the transition.
                     */
                    Owl.prototype.next = function(speed) {
                        speed = speed || false;
                        this.to(this.relative(this.current()) + 1, speed);
                    };

                    /**
                     * Slides to the previous item.
                     * @public
                     * @param {Number} [speed] - The time in milliseconds for the transition.
                     */
                    Owl.prototype.prev = function(speed) {
                        speed = speed || false;
                        this.to(this.relative(this.current()) - 1, speed);
                    };

                    /**
                     * Handles the end of an animation.
                     * @protected
                     * @param {Event} event - The event arguments.
                     */
                    Owl.prototype.onTransitionEnd = function(event) {

                        // if css2 animation then event object is undefined
                        if (event !== undefined) {
                            event.stopPropagation();

                            // Catch only owl-stage transitionEnd event
                            if ((event.target || event.srcElement || event.originalTarget) !== this.$stage.get(0)) {
                                return false;
                            }
                        }

                        this.leave('animating');
                        this.trigger('translated');
                    };

                    /**
                     * Gets viewport width.
                     * @protected
                     * @return {Number} - The width in pixel.
                     */
                    Owl.prototype.viewport = function() {
                        var width;
                        if (this.options.responsiveBaseElement !== window) {
                            width = $(this.options.responsiveBaseElement).width();
                        } else if (window.innerWidth) {
                            width = window.innerWidth;
                        } else if (document.documentElement && document.documentElement.clientWidth) {
                            width = document.documentElement.clientWidth;
                        } else {
                            console.warn('Can not detect viewport width.');
                        }
                        return width;
                    };

                    /**
                     * Replaces the current content.
                     * @public
                     * @param {HTMLElement|jQuery|String} content - The new content.
                     */
                    Owl.prototype.replace = function(content) {
                        this.$stage.empty();
                        this._items = [];

                        if (content) {
                            content = (content instanceof jQuery) ? content : $(content);
                        }

                        if (this.settings.nestedItemSelector) {
                            content = content.find('.' + this.settings.nestedItemSelector);
                        }

                        content.filter(function() {
                            return this.nodeType === 1;
                        }).each($.proxy(function(index, item) {
                            item = this.prepare(item);
                            this.$stage.append(item);
                            this._items.push(item);
                            this._mergers.push(item.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);
                        }, this));

                        this.reset(this.isNumeric(this.settings.startPosition) ? this.settings.startPosition : 0);

                        this.invalidate('items');
                    };

                    /**
                     * Adds an item.
                     * @todo Use `item` instead of `content` for the event arguments.
                     * @public
                     * @param {HTMLElement|jQuery|String} content - The item content to add.
                     * @param {Number} [position] - The relative position at which to insert the item otherwise the item will be added to the end.
                     */
                    Owl.prototype.add = function(content, position) {
                        var current = this.relative(this._current);

                        position = position === undefined ? this._items.length : this.normalize(position, true);
                        content = content instanceof jQuery ? content : $(content);

                        this.trigger('add', { content: content, position: position });

                        content = this.prepare(content);

                        if (this._items.length === 0 || position === this._items.length) {
                            this._items.length === 0 && this.$stage.append(content);
                            this._items.length !== 0 && this._items[position - 1].after(content);
                            this._items.push(content);
                            this._mergers.push(content.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);
                        } else {
                            this._items[position].before(content);
                            this._items.splice(position, 0, content);
                            this._mergers.splice(position, 0, content.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);
                        }

                        this._items[current] && this.reset(this._items[current].index());

                        this.invalidate('items');

                        this.trigger('added', { content: content, position: position });
                    };

                    /**
                     * Removes an item by its position.
                     * @todo Use `item` instead of `content` for the event arguments.
                     * @public
                     * @param {Number} position - The relative position of the item to remove.
                     */
                    Owl.prototype.remove = function(position) {
                        position = this.normalize(position, true);

                        if (position === undefined) {
                            return;
                        }

                        this.trigger('remove', { content: this._items[position], position: position });

                        this._items[position].remove();
                        this._items.splice(position, 1);
                        this._mergers.splice(position, 1);

                        this.invalidate('items');

                        this.trigger('removed', { content: null, position: position });
                    };

                    /**
                     * Preloads images with auto width.
                     * @todo Replace by a more generic approach
                     * @protected
                     */
                    Owl.prototype.preloadAutoWidthImages = function(images) {
                        images.each($.proxy(function(i, element) {
                            this.enter('pre-loading');
                            element = $(element);
                            $(new Image()).one('load', $.proxy(function(e) {
                                element.attr('src', e.target.src);
                                element.css('opacity', 1);
                                this.leave('pre-loading');
                                !this.is('pre-loading') && !this.is('initializing') && this.refresh();
                            }, this)).attr('src', element.attr('src') || element.attr('data-src') || element.attr('data-src-retina'));
                        }, this));
                    };

                    /**
                     * Destroys the carousel.
                     * @public
                     */
                    Owl.prototype.destroy = function() {

                        this.$element.off('.owl.core');
                        this.$stage.off('.owl.core');
                        $(document).off('.owl.core');

                        if (this.settings.responsive !== false) {
                            window.clearTimeout(this.resizeTimer);
                            this.off(window, 'resize', this._handlers.onThrottledResize);
                        }

                        for (var i in this._plugins) {
                            this._plugins[i].destroy();
                        }

                        this.$stage.children('.cloned').remove();

                        this.$stage.unwrap();
                        this.$stage.children().contents().unwrap();
                        this.$stage.children().unwrap();
                        this.$stage.remove();
                        this.$element
                            .removeClass(this.options.refreshClass)
                            .removeClass(this.options.loadingClass)
                            .removeClass(this.options.loadedClass)
                            .removeClass(this.options.rtlClass)
                            .removeClass(this.options.dragClass)
                            .removeClass(this.options.grabClass)
                            .attr('class', this.$element.attr('class').replace(new RegExp(this.options.responsiveClass + '-\\S+\\s', 'g'), ''))
                            .removeData('owl.carousel');
                    };

                    /**
                     * Operators to calculate right-to-left and left-to-right.
                     * @protected
                     * @param {Number} [a] - The left side operand.
                     * @param {String} [o] - The operator.
                     * @param {Number} [b] - The right side operand.
                     */
                    Owl.prototype.op = function(a, o, b) {
                        var rtl = this.settings.rtl;
                        switch (o) {
                            case '<':
                                return rtl ? a > b : a < b;
                            case '>':
                                return rtl ? a < b : a > b;
                            case '>=':
                                return rtl ? a <= b : a >= b;
                            case '<=':
                                return rtl ? a >= b : a <= b;
                            default:
                                break;
                        }
                    };

                    /**
                     * Attaches to an internal event.
                     * @protected
                     * @param {HTMLElement} element - The event source.
                     * @param {String} event - The event name.
                     * @param {Function} listener - The event handler to attach.
                     * @param {Boolean} capture - Wether the event should be handled at the capturing phase or not.
                     */
                    Owl.prototype.on = function(element, event, listener, capture) {
                        if (element.addEventListener) {
                            element.addEventListener(event, listener, capture);
                        } else if (element.attachEvent) {
                            element.attachEvent('on' + event, listener);
                        }
                    };

                    /**
                     * Detaches from an internal event.
                     * @protected
                     * @param {HTMLElement} element - The event source.
                     * @param {String} event - The event name.
                     * @param {Function} listener - The attached event handler to detach.
                     * @param {Boolean} capture - Wether the attached event handler was registered as a capturing listener or not.
                     */
                    Owl.prototype.off = function(element, event, listener, capture) {
                        if (element.removeEventListener) {
                            element.removeEventListener(event, listener, capture);
                        } else if (element.detachEvent) {
                            element.detachEvent('on' + event, listener);
                        }
                    };

                    /**
                     * Triggers a public event.
                     * @todo Remove `status`, `relatedTarget` should be used instead.
                     * @protected
                     * @param {String} name - The event name.
                     * @param {*} [data=null] - The event data.
                     * @param {String} [namespace=carousel] - The event namespace.
                     * @param {String} [state] - The state which is associated with the event.
                     * @param {Boolean} [enter=false] - Indicates if the call enters the specified state or not.
                     * @returns {Event} - The event arguments.
                     */
                    Owl.prototype.trigger = function(name, data, namespace, state, enter) {
                        var status = {
                            item: { count: this._items.length, index: this.current() }
                        }, handler = $.camelCase(
                            $.grep([ 'on', name, namespace ], function(v) { return v })
                                .join('-').toLowerCase()
                        ), event = $.Event(
                            [ name, 'owl', namespace || 'carousel' ].join('.').toLowerCase(),
                            $.extend({ relatedTarget: this }, status, data)
                        );

                        if (!this._supress[name]) {
                            $.each(this._plugins, function(name, plugin) {
                                if (plugin.onTrigger) {
                                    plugin.onTrigger(event);
                                }
                            });

                            this.register({ type: Owl.Type.Event, name: name });
                            this.$element.trigger(event);

                            if (this.settings && typeof this.settings[handler] === 'function') {
                                this.settings[handler].call(this, event);
                            }
                        }

                        return event;
                    };

                    /**
                     * Enters a state.
                     * @param name - The state name.
                     */
                    Owl.prototype.enter = function(name) {
                        $.each([ name ].concat(this._states.tags[name] || []), $.proxy(function(i, name) {
                            if (this._states.current[name] === undefined) {
                                this._states.current[name] = 0;
                            }

                            this._states.current[name]++;
                        }, this));
                    };

                    /**
                     * Leaves a state.
                     * @param name - The state name.
                     */
                    Owl.prototype.leave = function(name) {
                        $.each([ name ].concat(this._states.tags[name] || []), $.proxy(function(i, name) {
                            this._states.current[name]--;
                        }, this));
                    };

                    /**
                     * Registers an event or state.
                     * @public
                     * @param {Object} object - The event or state to register.
                     */
                    Owl.prototype.register = function(object) {
                        if (object.type === Owl.Type.Event) {
                            if (!$.event.special[object.name]) {
                                $.event.special[object.name] = {};
                            }

                            if (!$.event.special[object.name].owl) {
                                var _default = $.event.special[object.name]._default;
                                $.event.special[object.name]._default = function(e) {
                                    if (_default && _default.apply && (!e.namespace || e.namespace.indexOf('owl') === -1)) {
                                        return _default.apply(this, arguments);
                                    }
                                    return e.namespace && e.namespace.indexOf('owl') > -1;
                                };
                                $.event.special[object.name].owl = true;
                            }
                        } else if (object.type === Owl.Type.State) {
                            if (!this._states.tags[object.name]) {
                                this._states.tags[object.name] = object.tags;
                            } else {
                                this._states.tags[object.name] = this._states.tags[object.name].concat(object.tags);
                            }

                            this._states.tags[object.name] = $.grep(this._states.tags[object.name], $.proxy(function(tag, i) {
                                return $.inArray(tag, this._states.tags[object.name]) === i;
                            }, this));
                        }
                    };

                    /**
                     * Suppresses events.
                     * @protected
                     * @param {Array.<String>} events - The events to suppress.
                     */
                    Owl.prototype.suppress = function(events) {
                        $.each(events, $.proxy(function(index, event) {
                            this._supress[event] = true;
                        }, this));
                    };

                    /**
                     * Releases suppressed events.
                     * @protected
                     * @param {Array.<String>} events - The events to release.
                     */
                    Owl.prototype.release = function(events) {
                        $.each(events, $.proxy(function(index, event) {
                            delete this._supress[event];
                        }, this));
                    };

                    /**
                     * Gets unified pointer coordinates from event.
                     * @todo #261
                     * @protected
                     * @param {Event} - The `mousedown` or `touchstart` event.
                     * @returns {Object} - Contains `x` and `y` coordinates of current pointer position.
                     */
                    Owl.prototype.pointer = function(event) {
                        var result = { x: null, y: null };

                        event = event.originalEvent || event || window.event;

                        event = event.touches && event.touches.length ?
                            event.touches[0] : event.changedTouches && event.changedTouches.length ?
                                event.changedTouches[0] : event;

                        if (event.pageX) {
                            result.x = event.pageX;
                            result.y = event.pageY;
                        } else {
                            result.x = event.clientX;
                            result.y = event.clientY;
                        }

                        return result;
                    };

                    /**
                     * Determines if the input is a Number or something that can be coerced to a Number
                     * @protected
                     * @param {Number|String|Object|Array|Boolean|RegExp|Function|Symbol} - The input to be tested
                     * @returns {Boolean} - An indication if the input is a Number or can be coerced to a Number
                     */
                    Owl.prototype.isNumeric = function(number) {
                        return !isNaN(parseFloat(number));
                    };

                    /**
                     * Gets the difference of two vectors.
                     * @todo #261
                     * @protected
                     * @param {Object} - The first vector.
                     * @param {Object} - The second vector.
                     * @returns {Object} - The difference.
                     */
                    Owl.prototype.difference = function(first, second) {
                        return {
                            x: first.x - second.x,
                            y: first.y - second.y
                        };
                    };

                    /**
                     * The jQuery Plugin for the Owl Carousel
                     * @todo Navigation plugin `next` and `prev`
                     * @public
                     */
                    $.fn.owlCarousel = function(option) {
                        var args = Array.prototype.slice.call(arguments, 1);

                        return this.each(function() {
                            var $this = $(this),
                                data = $this.data('owl.carousel');

                            if (!data) {
                                data = new Owl(this, typeof option == 'object' && option);
                                $this.data('owl.carousel', data);

                                $.each([
                                    'next', 'prev', 'to', 'destroy', 'refresh', 'replace', 'add', 'remove'
                                ], function(i, event) {
                                    data.register({ type: Owl.Type.Event, name: event });
                                    data.$element.on(event + '.owl.carousel.core', $.proxy(function(e) {
                                        if (e.namespace && e.relatedTarget !== this) {
                                            this.suppress([ event ]);
                                            data[event].apply(this, [].slice.call(arguments, 1));
                                            this.release([ event ]);
                                        }
                                    }, data));
                                });
                            }

                            if (typeof option == 'string' && option.charAt(0) !== '_') {
                                data[option].apply(data, args);
                            }
                        });
                    };

                    /**
                     * The constructor for the jQuery Plugin
                     * @public
                     */
                    $.fn.owlCarousel.Constructor = Owl;

                })(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);

                /**
                 * AutoRefresh Plugin
                 * @version 2.3.4
                 * @author Artus Kolanowski
                 * @author David Deutsch
                 * @license The MIT License (MIT)
                 */
                ;(function($, window, document, undefined) {

                    /**
                     * Creates the auto refresh plugin.
                     * @class The Auto Refresh Plugin
                     * @param {Owl} carousel - The Owl Carousel
                     */
                    var AutoRefresh = function(carousel) {
                        /**
                         * Reference to the core.
                         * @protected
                         * @type {Owl}
                         */
                        this._core = carousel;

                        /**
                         * Refresh interval.
                         * @protected
                         * @type {number}
                         */
                        this._interval = null;

                        /**
                         * Whether the element is currently visible or not.
                         * @protected
                         * @type {Boolean}
                         */
                        this._visible = null;

                        /**
                         * All event handlers.
                         * @protected
                         * @type {Object}
                         */
                        this._handlers = {
                            'initialized.owl.carousel': $.proxy(function(e) {
                                if (e.namespace && this._core.settings.autoRefresh) {
                                    this.watch();
                                }
                            }, this)
                        };

                        // set default options
                        this._core.options = $.extend({}, AutoRefresh.Defaults, this._core.options);

                        // register event handlers
                        this._core.$element.on(this._handlers);
                    };

                    /**
                     * Default options.
                     * @public
                     */
                    AutoRefresh.Defaults = {
                        autoRefresh: true,
                        autoRefreshInterval: 500
                    };

                    /**
                     * Watches the element.
                     */
                    AutoRefresh.prototype.watch = function() {
                        if (this._interval) {
                            return;
                        }

                        this._visible = this._core.isVisible();
                        this._interval = window.setInterval($.proxy(this.refresh, this), this._core.settings.autoRefreshInterval);
                    };

                    /**
                     * Refreshes the element.
                     */
                    AutoRefresh.prototype.refresh = function() {
                        if (this._core.isVisible() === this._visible) {
                            return;
                        }

                        this._visible = !this._visible;

                        this._core.$element.toggleClass('owl-hidden', !this._visible);

                        this._visible && (this._core.invalidate('width') && this._core.refresh());
                    };

                    /**
                     * Destroys the plugin.
                     */
                    AutoRefresh.prototype.destroy = function() {
                        var handler, property;

                        window.clearInterval(this._interval);

                        for (handler in this._handlers) {
                            this._core.$element.off(handler, this._handlers[handler]);
                        }
                        for (property in Object.getOwnPropertyNames(this)) {
                            typeof this[property] != 'function' && (this[property] = null);
                        }
                    };

                    $.fn.owlCarousel.Constructor.Plugins.AutoRefresh = AutoRefresh;

                })(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);

                /**
                 * Lazy Plugin
                 * @version 2.3.4
                 * @author Bartosz Wojciechowski
                 * @author David Deutsch
                 * @license The MIT License (MIT)
                 */
                ;(function($, window, document, undefined) {

                    /**
                     * Creates the lazy plugin.
                     * @class The Lazy Plugin
                     * @param {Owl} carousel - The Owl Carousel
                     */
                    var Lazy = function(carousel) {

                        /**
                         * Reference to the core.
                         * @protected
                         * @type {Owl}
                         */
                        this._core = carousel;

                        /**
                         * Already loaded items.
                         * @protected
                         * @type {Array.<jQuery>}
                         */
                        this._loaded = [];

                        /**
                         * Event handlers.
                         * @protected
                         * @type {Object}
                         */
                        this._handlers = {
                            'initialized.owl.carousel change.owl.carousel resized.owl.carousel': $.proxy(function(e) {
                                if (!e.namespace) {
                                    return;
                                }

                                if (!this._core.settings || !this._core.settings.lazyLoad) {
                                    return;
                                }

                                if ((e.property && e.property.name == 'position') || e.type == 'initialized') {
                                    var settings = this._core.settings,
                                        n = (settings.center && Math.ceil(settings.items / 2) || settings.items),
                                        i = ((settings.center && n * -1) || 0),
                                        position = (e.property && e.property.value !== undefined ? e.property.value : this._core.current()) + i,
                                        clones = this._core.clones().length,
                                        load = $.proxy(function(i, v) { this.load(v) }, this);
                                    //TODO: Need documentation for this new option
                                    if (settings.lazyLoadEager > 0) {
                                        n += settings.lazyLoadEager;
                                        // If the carousel is looping also preload images that are to the "left"
                                        if (settings.loop) {
                                            position -= settings.lazyLoadEager;
                                            n++;
                                        }
                                    }

                                    while (i++ < n) {
                                        this.load(clones / 2 + this._core.relative(position));
                                        clones && $.each(this._core.clones(this._core.relative(position)), load);
                                        position++;
                                    }
                                }
                            }, this)
                        };

                        // set the default options
                        this._core.options = $.extend({}, Lazy.Defaults, this._core.options);

                        // register event handler
                        this._core.$element.on(this._handlers);
                    };

                    /**
                     * Default options.
                     * @public
                     */
                    Lazy.Defaults = {
                        lazyLoad: false,
                        lazyLoadEager: 0
                    };

                    /**
                     * Loads all resources of an item at the specified position.
                     * @param {Number} position - The absolute position of the item.
                     * @protected
                     */
                    Lazy.prototype.load = function(position) {
                        var $item = this._core.$stage.children().eq(position),
                            $elements = $item && $item.find('.owl-lazy');

                        if (!$elements || $.inArray($item.get(0), this._loaded) > -1) {
                            return;
                        }

                        $elements.each($.proxy(function(index, element) {
                            var $element = $(element), image,
                                url = (window.devicePixelRatio > 1 && $element.attr('data-src-retina')) || $element.attr('data-src') || $element.attr('data-srcset');

                            this._core.trigger('load', { element: $element, url: url }, 'lazy');

                            if ($element.is('img')) {
                                $element.one('load.owl.lazy', $.proxy(function() {
                                    $element.css('opacity', 1);
                                    this._core.trigger('loaded', { element: $element, url: url }, 'lazy');
                                }, this)).attr('src', url);
                            } else if ($element.is('source')) {
                                $element.one('load.owl.lazy', $.proxy(function() {
                                    this._core.trigger('loaded', { element: $element, url: url }, 'lazy');
                                }, this)).attr('srcset', url);
                            } else {
                                image = new Image();
                                image.onload = $.proxy(function() {
                                    $element.css({
                                        'background-image': 'url("' + url + '")',
                                        'opacity': '1'
                                    });
                                    this._core.trigger('loaded', { element: $element, url: url }, 'lazy');
                                }, this);
                                image.src = url;
                            }
                        }, this));

                        this._loaded.push($item.get(0));
                    };

                    /**
                     * Destroys the plugin.
                     * @public
                     */
                    Lazy.prototype.destroy = function() {
                        var handler, property;

                        for (handler in this.handlers) {
                            this._core.$element.off(handler, this.handlers[handler]);
                        }
                        for (property in Object.getOwnPropertyNames(this)) {
                            typeof this[property] != 'function' && (this[property] = null);
                        }
                    };

                    $.fn.owlCarousel.Constructor.Plugins.Lazy = Lazy;

                })(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);

                /**
                 * AutoHeight Plugin
                 * @version 2.3.4
                 * @author Bartosz Wojciechowski
                 * @author David Deutsch
                 * @license The MIT License (MIT)
                 */
                ;(function($, window, document, undefined) {

                    /**
                     * Creates the auto height plugin.
                     * @class The Auto Height Plugin
                     * @param {Owl} carousel - The Owl Carousel
                     */
                    var AutoHeight = function(carousel) {
                        /**
                         * Reference to the core.
                         * @protected
                         * @type {Owl}
                         */
                        this._core = carousel;

                        this._previousHeight = null;

                        /**
                         * All event handlers.
                         * @protected
                         * @type {Object}
                         */
                        this._handlers = {
                            'initialized.owl.carousel refreshed.owl.carousel': $.proxy(function(e) {
                                if (e.namespace && this._core.settings.autoHeight) {
                                    this.update();
                                }
                            }, this),
                            'changed.owl.carousel': $.proxy(function(e) {
                                if (e.namespace && this._core.settings.autoHeight && e.property.name === 'position'){
                                    this.update();
                                }
                            }, this),
                            'loaded.owl.lazy': $.proxy(function(e) {
                                if (e.namespace && this._core.settings.autoHeight
                                    && e.element.closest('.' + this._core.settings.itemClass).index() === this._core.current()) {
                                    this.update();
                                }
                            }, this)
                        };

                        // set default options
                        this._core.options = $.extend({}, AutoHeight.Defaults, this._core.options);

                        // register event handlers
                        this._core.$element.on(this._handlers);
                        this._intervalId = null;
                        var refThis = this;

                        // These changes have been taken from a PR by gavrochelegnou proposed in #1575
                        // and have been made compatible with the latest jQuery version
                        $(window).on('load', function() {
                            if (refThis._core.settings.autoHeight) {
                                refThis.update();
                            }
                        });

                        // Autoresize the height of the carousel when window is resized
                        // When carousel has images, the height is dependent on the width
                        // and should also change on resize
                        $(window).resize(function() {
                            if (refThis._core.settings.autoHeight) {
                                if (refThis._intervalId != null) {
                                    clearTimeout(refThis._intervalId);
                                }

                                refThis._intervalId = setTimeout(function() {
                                    refThis.update();
                                }, 250);
                            }
                        });

                    };

                    /**
                     * Default options.
                     * @public
                     */
                    AutoHeight.Defaults = {
                        autoHeight: false,
                        autoHeightClass: 'owl-height'
                    };

                    /**
                     * Updates the view.
                     */
                    AutoHeight.prototype.update = function() {
                        var start = this._core._current,
                            end = start + this._core.settings.items,
                            lazyLoadEnabled = this._core.settings.lazyLoad,
                            visible = this._core.$stage.children().toArray().slice(start, end),
                            heights = [],
                            maxheight = 0;

                        $.each(visible, function(index, item) {
                            heights.push($(item).height());
                        });

                        maxheight = Math.max.apply(null, heights);

                        if (maxheight <= 1 && lazyLoadEnabled && this._previousHeight) {
                            maxheight = this._previousHeight;
                        }

                        this._previousHeight = maxheight;

                        this._core.$stage.parent()
                            .height(maxheight)
                            .addClass(this._core.settings.autoHeightClass);
                    };

                    AutoHeight.prototype.destroy = function() {
                        var handler, property;

                        for (handler in this._handlers) {
                            this._core.$element.off(handler, this._handlers[handler]);
                        }
                        for (property in Object.getOwnPropertyNames(this)) {
                            typeof this[property] !== 'function' && (this[property] = null);
                        }
                    };

                    $.fn.owlCarousel.Constructor.Plugins.AutoHeight = AutoHeight;

                })(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);

                /**
                 * Video Plugin
                 * @version 2.3.4
                 * @author Bartosz Wojciechowski
                 * @author David Deutsch
                 * @license The MIT License (MIT)
                 */
                ;(function($, window, document, undefined) {

                    /**
                     * Creates the video plugin.
                     * @class The Video Plugin
                     * @param {Owl} carousel - The Owl Carousel
                     */
                    var Video = function(carousel) {
                        /**
                         * Reference to the core.
                         * @protected
                         * @type {Owl}
                         */
                        this._core = carousel;

                        /**
                         * Cache all video URLs.
                         * @protected
                         * @type {Object}
                         */
                        this._videos = {};

                        /**
                         * Current playing item.
                         * @protected
                         * @type {jQuery}
                         */
                        this._playing = null;

                        /**
                         * All event handlers.
                         * @todo The cloned content removale is too late
                         * @protected
                         * @type {Object}
                         */
                        this._handlers = {
                            'initialized.owl.carousel': $.proxy(function(e) {
                                if (e.namespace) {
                                    this._core.register({ type: 'state', name: 'playing', tags: [ 'interacting' ] });
                                }
                            }, this),
                            'resize.owl.carousel': $.proxy(function(e) {
                                if (e.namespace && this._core.settings.video && this.isInFullScreen()) {
                                    e.preventDefault();
                                }
                            }, this),
                            'refreshed.owl.carousel': $.proxy(function(e) {
                                if (e.namespace && this._core.is('resizing')) {
                                    this._core.$stage.find('.cloned .owl-video-frame').remove();
                                }
                            }, this),
                            'changed.owl.carousel': $.proxy(function(e) {
                                if (e.namespace && e.property.name === 'position' && this._playing) {
                                    this.stop();
                                }
                            }, this),
                            'prepared.owl.carousel': $.proxy(function(e) {
                                if (!e.namespace) {
                                    return;
                                }

                                var $element = $(e.content).find('.owl-video');

                                if ($element.length) {
                                    $element.css('display', 'none');
                                    this.fetch($element, $(e.content));
                                }
                            }, this)
                        };

                        // set default options
                        this._core.options = $.extend({}, Video.Defaults, this._core.options);

                        // register event handlers
                        this._core.$element.on(this._handlers);

                        this._core.$element.on('click.owl.video', '.owl-video-play-icon', $.proxy(function(e) {
                            this.play(e);
                        }, this));
                    };

                    /**
                     * Default options.
                     * @public
                     */
                    Video.Defaults = {
                        video: false,
                        videoHeight: false,
                        videoWidth: false
                    };

                    /**
                     * Gets the video ID and the type (YouTube/Vimeo/vzaar only).
                     * @protected
                     * @param {jQuery} target - The target containing the video data.
                     * @param {jQuery} item - The item containing the video.
                     */
                    Video.prototype.fetch = function(target, item) {
                        var type = (function() {
                                if (target.attr('data-vimeo-id')) {
                                    return 'vimeo';
                                } else if (target.attr('data-vzaar-id')) {
                                    return 'vzaar'
                                } else {
                                    return 'youtube';
                                }
                            })(),
                            id = target.attr('data-vimeo-id') || target.attr('data-youtube-id') || target.attr('data-vzaar-id'),
                            width = target.attr('data-width') || this._core.settings.videoWidth,
                            height = target.attr('data-height') || this._core.settings.videoHeight,
                            url = target.attr('href');

                        if (url) {

                            /*
					Parses the id's out of the following urls (and probably more):
					https://www.youtube.com/watch?v=:id
					https://youtu.be/:id
					https://vimeo.com/:id
					https://vimeo.com/channels/:channel/:id
					https://vimeo.com/groups/:group/videos/:id
					https://app.vzaar.com/videos/:id

					Visual example: https://regexper.com/#(http%3A%7Chttps%3A%7C)%5C%2F%5C%2F(player.%7Cwww.%7Capp.)%3F(vimeo%5C.com%7Cyoutu(be%5C.com%7C%5C.be%7Cbe%5C.googleapis%5C.com)%7Cvzaar%5C.com)%5C%2F(video%5C%2F%7Cvideos%5C%2F%7Cembed%5C%2F%7Cchannels%5C%2F.%2B%5C%2F%7Cgroups%5C%2F.%2B%5C%2F%7Cwatch%5C%3Fv%3D%7Cv%5C%2F)%3F(%5BA-Za-z0-9._%25-%5D*)(%5C%26%5CS%2B)%3F
			*/

                            id = url.match(/(http:|https:|)\/\/(player.|www.|app.)?(vimeo\.com|youtu(be\.com|\.be|be\.googleapis\.com|be\-nocookie\.com)|vzaar\.com)\/(video\/|videos\/|embed\/|channels\/.+\/|groups\/.+\/|watch\?v=|v\/)?([A-Za-z0-9._%-]*)(\&\S+)?/);

                            if (id[3].indexOf('youtu') > -1) {
                                type = 'youtube';
                            } else if (id[3].indexOf('vimeo') > -1) {
                                type = 'vimeo';
                            } else if (id[3].indexOf('vzaar') > -1) {
                                type = 'vzaar';
                            } else {
                                throw new Error('Video URL not supported.');
                            }
                            id = id[6];
                        } else {
                            throw new Error('Missing video URL.');
                        }

                        this._videos[url] = {
                            type: type,
                            id: id,
                            width: width,
                            height: height
                        };

                        item.attr('data-video', url);

                        this.thumbnail(target, this._videos[url]);
                    };

                    /**
                     * Creates video thumbnail.
                     * @protected
                     * @param {jQuery} target - The target containing the video data.
                     * @param {Object} info - The video info object.
                     * @see `fetch`
                     */
                    Video.prototype.thumbnail = function(target, video) {
                        var tnLink,
                            icon,
                            path,
                            dimensions = video.width && video.height ? 'width:' + video.width + 'px;height:' + video.height + 'px;' : '',
                            customTn = target.find('img'),
                            srcType = 'src',
                            lazyClass = '',
                            settings = this._core.settings,
                            create = function(path) {
                                icon = '<div class="owl-video-play-icon"></div>';

                                if (settings.lazyLoad) {
                                    tnLink = $('<div/>',{
                                        "class": 'owl-video-tn ' + lazyClass,
                                        "srcType": path
                                    });
                                } else {
                                    tnLink = $( '<div/>', {
                                        "class": "owl-video-tn",
                                        "style": 'opacity:1;background-image:url(' + path + ')'
                                    });
                                }
                                target.after(tnLink);
                                target.after(icon);
                            };

                        // wrap video content into owl-video-wrapper div
                        target.wrap( $( '<div/>', {
                            "class": "owl-video-wrapper",
                            "style": dimensions
                        }));

                        if (this._core.settings.lazyLoad) {
                            srcType = 'data-src';
                            lazyClass = 'owl-lazy';
                        }

                        // custom thumbnail
                        if (customTn.length) {
                            create(customTn.attr(srcType));
                            customTn.remove();
                            return false;
                        }

                        if (video.type === 'youtube') {
                            path = "//img.youtube.com/vi/" + video.id + "/hqdefault.jpg";
                            create(path);
                        } else if (video.type === 'vimeo') {
                            $.ajax({
                                type: 'GET',
                                url: '//vimeo.com/api/v2/video/' + video.id + '.json',
                                jsonp: 'callback',
                                dataType: 'jsonp',
                                success: function(data) {
                                    path = data[0].thumbnail_large;
                                    create(path);
                                }
                            });
                        } else if (video.type === 'vzaar') {
                            $.ajax({
                                type: 'GET',
                                url: '//vzaar.com/api/videos/' + video.id + '.json',
                                jsonp: 'callback',
                                dataType: 'jsonp',
                                success: function(data) {
                                    path = data.framegrab_url;
                                    create(path);
                                }
                            });
                        }
                    };

                    /**
                     * Stops the current video.
                     * @public
                     */
                    Video.prototype.stop = function() {
                        this._core.trigger('stop', null, 'video');
                        this._playing.find('.owl-video-frame').remove();
                        this._playing.removeClass('owl-video-playing');
                        this._playing = null;
                        this._core.leave('playing');
                        this._core.trigger('stopped', null, 'video');
                    };

                    /**
                     * Starts the current video.
                     * @public
                     * @param {Event} event - The event arguments.
                     */
                    Video.prototype.play = function(event) {
                        var target = $(event.target),
                            item = target.closest('.' + this._core.settings.itemClass),
                            video = this._videos[item.attr('data-video')],
                            width = video.width || '100%',
                            height = video.height || this._core.$stage.height(),
                            html,
                            iframe;

                        if (this._playing) {
                            return;
                        }

                        this._core.enter('playing');
                        this._core.trigger('play', null, 'video');

                        item = this._core.items(this._core.relative(item.index()));

                        this._core.reset(item.index());

                        html = $( '<iframe frameborder="0" allowfullscreen mozallowfullscreen webkitAllowFullScreen ></iframe>' );
                        html.attr( 'height', height );
                        html.attr( 'width', width );
                        if (video.type === 'youtube') {
                            html.attr( 'src', '//www.youtube.com/embed/' + video.id + '?autoplay=1&rel=0&v=' + video.id );
                        } else if (video.type === 'vimeo') {
                            html.attr( 'src', '//player.vimeo.com/video/' + video.id + '?autoplay=1' );
                        } else if (video.type === 'vzaar') {
                            html.attr( 'src', '//view.vzaar.com/' + video.id + '/player?autoplay=true' );
                        }

                        iframe = $(html).wrap( '<div class="owl-video-frame" />' ).insertAfter(item.find('.owl-video'));

                        this._playing = item.addClass('owl-video-playing');
                    };

                    /**
                     * Checks whether an video is currently in full screen mode or not.
                     * @todo Bad style because looks like a readonly method but changes members.
                     * @protected
                     * @returns {Boolean}
                     */
                    Video.prototype.isInFullScreen = function() {
                        var element = document.fullscreenElement || document.mozFullScreenElement ||
                            document.webkitFullscreenElement;

                        return element && $(element).parent().hasClass('owl-video-frame');
                    };

                    /**
                     * Destroys the plugin.
                     */
                    Video.prototype.destroy = function() {
                        var handler, property;

                        this._core.$element.off('click.owl.video');

                        for (handler in this._handlers) {
                            this._core.$element.off(handler, this._handlers[handler]);
                        }
                        for (property in Object.getOwnPropertyNames(this)) {
                            typeof this[property] != 'function' && (this[property] = null);
                        }
                    };

                    $.fn.owlCarousel.Constructor.Plugins.Video = Video;

                })(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);

                /**
                 * Animate Plugin
                 * @version 2.3.4
                 * @author Bartosz Wojciechowski
                 * @author David Deutsch
                 * @license The MIT License (MIT)
                 */
                ;(function($, window, document, undefined) {

                    /**
                     * Creates the animate plugin.
                     * @class The Navigation Plugin
                     * @param {Owl} scope - The Owl Carousel
                     */
                    var Animate = function(scope) {
                        this.core = scope;
                        this.core.options = $.extend({}, Animate.Defaults, this.core.options);
                        this.swapping = true;
                        this.previous = undefined;
                        this.next = undefined;

                        this.handlers = {
                            'change.owl.carousel': $.proxy(function(e) {
                                if (e.namespace && e.property.name == 'position') {
                                    this.previous = this.core.current();
                                    this.next = e.property.value;
                                }
                            }, this),
                            'drag.owl.carousel dragged.owl.carousel translated.owl.carousel': $.proxy(function(e) {
                                if (e.namespace) {
                                    this.swapping = e.type == 'translated';
                                }
                            }, this),
                            'translate.owl.carousel': $.proxy(function(e) {
                                if (e.namespace && this.swapping && (this.core.options.animateOut || this.core.options.animateIn)) {
                                    this.swap();
                                }
                            }, this)
                        };

                        this.core.$element.on(this.handlers);
                    };

                    /**
                     * Default options.
                     * @public
                     */
                    Animate.Defaults = {
                        animateOut: false,
                        animateIn: false
                    };

                    /**
                     * Toggles the animation classes whenever an translations starts.
                     * @protected
                     * @returns {Boolean|undefined}
                     */
                    Animate.prototype.swap = function() {

                        if (this.core.settings.items !== 1) {
                            return;
                        }

                        if (!$.support.animation || !$.support.transition) {
                            return;
                        }

                        this.core.speed(0);

                        var left,
                            clear = $.proxy(this.clear, this),
                            previous = this.core.$stage.children().eq(this.previous),
                            next = this.core.$stage.children().eq(this.next),
                            incoming = this.core.settings.animateIn,
                            outgoing = this.core.settings.animateOut;

                        if (this.core.current() === this.previous) {
                            return;
                        }

                        if (outgoing) {
                            left = this.core.coordinates(this.previous) - this.core.coordinates(this.next);
                            previous.one($.support.animation.end, clear)
                                .css( { 'left': left + 'px' } )
                                .addClass('animated owl-animated-out')
                                .addClass(outgoing);
                        }

                        if (incoming) {
                            next.one($.support.animation.end, clear)
                                .addClass('animated owl-animated-in')
                                .addClass(incoming);
                        }
                    };

                    Animate.prototype.clear = function(e) {
                        $(e.target).css( { 'left': '' } )
                            .removeClass('animated owl-animated-out owl-animated-in')
                            .removeClass(this.core.settings.animateIn)
                            .removeClass(this.core.settings.animateOut);
                        this.core.onTransitionEnd();
                    };

                    /**
                     * Destroys the plugin.
                     * @public
                     */
                    Animate.prototype.destroy = function() {
                        var handler, property;

                        for (handler in this.handlers) {
                            this.core.$element.off(handler, this.handlers[handler]);
                        }
                        for (property in Object.getOwnPropertyNames(this)) {
                            typeof this[property] != 'function' && (this[property] = null);
                        }
                    };

                    $.fn.owlCarousel.Constructor.Plugins.Animate = Animate;

                })(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);

                /**
                 * Autoplay Plugin
                 * @version 2.3.4
                 * @author Bartosz Wojciechowski
                 * @author Artus Kolanowski
                 * @author David Deutsch
                 * @author Tom De Caluwé
                 * @license The MIT License (MIT)
                 */
                ;(function($, window, document, undefined) {

                    /**
                     * Creates the autoplay plugin.
                     * @class The Autoplay Plugin
                     * @param {Owl} scope - The Owl Carousel
                     */
                    var Autoplay = function(carousel) {
                        /**
                         * Reference to the core.
                         * @protected
                         * @type {Owl}
                         */
                        this._core = carousel;

                        /**
                         * The autoplay timeout id.
                         * @type {Number}
                         */
                        this._call = null;

                        /**
                         * Depending on the state of the plugin, this variable contains either
                         * the start time of the timer or the current timer value if it's
                         * paused. Since we start in a paused state we initialize the timer
                         * value.
                         * @type {Number}
                         */
                        this._time = 0;

                        /**
                         * Stores the timeout currently used.
                         * @type {Number}
                         */
                        this._timeout = 0;

                        /**
                         * Indicates whenever the autoplay is paused.
                         * @type {Boolean}
                         */
                        this._paused = true;

                        /**
                         * All event handlers.
                         * @protected
                         * @type {Object}
                         */
                        this._handlers = {
                            'changed.owl.carousel': $.proxy(function(e) {
                                if (e.namespace && e.property.name === 'settings') {
                                    if (this._core.settings.autoplay) {
                                        this.play();
                                    } else {
                                        this.stop();
                                    }
                                } else if (e.namespace && e.property.name === 'position' && this._paused) {
                                    // Reset the timer. This code is triggered when the position
                                    // of the carousel was changed through user interaction.
                                    this._time = 0;
                                }
                            }, this),
                            'initialized.owl.carousel': $.proxy(function(e) {
                                if (e.namespace && this._core.settings.autoplay) {
                                    this.play();
                                }
                            }, this),
                            'play.owl.autoplay': $.proxy(function(e, t, s) {
                                if (e.namespace) {
                                    this.play(t, s);
                                }
                            }, this),
                            'stop.owl.autoplay': $.proxy(function(e) {
                                if (e.namespace) {
                                    this.stop();
                                }
                            }, this),
                            'mouseover.owl.autoplay': $.proxy(function() {
                                if (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {
                                    this.pause();
                                }
                            }, this),
                            'mouseleave.owl.autoplay': $.proxy(function() {
                                if (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {
                                    this.play();
                                }
                            }, this),
                            'touchstart.owl.core': $.proxy(function() {
                                if (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {
                                    this.pause();
                                }
                            }, this),
                            'touchend.owl.core': $.proxy(function() {
                                if (this._core.settings.autoplayHoverPause) {
                                    this.play();
                                }
                            }, this)
                        };

                        // register event handlers
                        this._core.$element.on(this._handlers);

                        // set default options
                        this._core.options = $.extend({}, Autoplay.Defaults, this._core.options);
                    };

                    /**
                     * Default options.
                     * @public
                     */
                    Autoplay.Defaults = {
                        autoplay: false,
                        autoplayTimeout: 5000,
                        autoplayHoverPause: false,
                        autoplaySpeed: false
                    };

                    /**
                     * Transition to the next slide and set a timeout for the next transition.
                     * @private
                     * @param {Number} [speed] - The animation speed for the animations.
                     */
                    Autoplay.prototype._next = function(speed) {
                        this._call = window.setTimeout(
                            $.proxy(this._next, this, speed),
                            this._timeout * (Math.round(this.read() / this._timeout) + 1) - this.read()
                        );

                        if (this._core.is('interacting') || document.hidden) {
                            return;
                        }
                        this._core.next(speed || this._core.settings.autoplaySpeed);
                    }

                    /**
                     * Reads the current timer value when the timer is playing.
                     * @public
                     */
                    Autoplay.prototype.read = function() {
                        return new Date().getTime() - this._time;
                    };

                    /**
                     * Starts the autoplay.
                     * @public
                     * @param {Number} [timeout] - The interval before the next animation starts.
                     * @param {Number} [speed] - The animation speed for the animations.
                     */
                    Autoplay.prototype.play = function(timeout, speed) {
                        var elapsed;

                        if (!this._core.is('rotating')) {
                            this._core.enter('rotating');
                        }

                        timeout = timeout || this._core.settings.autoplayTimeout;

                        // Calculate the elapsed time since the last transition. If the carousel
                        // wasn't playing this calculation will yield zero.
                        elapsed = Math.min(this._time % (this._timeout || timeout), timeout);

                        if (this._paused) {
                            // Start the clock.
                            this._time = this.read();
                            this._paused = false;
                        } else {
                            // Clear the active timeout to allow replacement.
                            window.clearTimeout(this._call);
                        }

                        // Adjust the origin of the timer to match the new timeout value.
                        this._time += this.read() % timeout - elapsed;

                        this._timeout = timeout;
                        this._call = window.setTimeout($.proxy(this._next, this, speed), timeout - elapsed);
                    };

                    /**
                     * Stops the autoplay.
                     * @public
                     */
                    Autoplay.prototype.stop = function() {
                        if (this._core.is('rotating')) {
                            // Reset the clock.
                            this._time = 0;
                            this._paused = true;

                            window.clearTimeout(this._call);
                            this._core.leave('rotating');
                        }
                    };

                    /**
                     * Pauses the autoplay.
                     * @public
                     */
                    Autoplay.prototype.pause = function() {
                        if (this._core.is('rotating') && !this._paused) {
                            // Pause the clock.
                            this._time = this.read();
                            this._paused = true;

                            window.clearTimeout(this._call);
                        }
                    };

                    /**
                     * Destroys the plugin.
                     */
                    Autoplay.prototype.destroy = function() {
                        var handler, property;

                        this.stop();

                        for (handler in this._handlers) {
                            this._core.$element.off(handler, this._handlers[handler]);
                        }
                        for (property in Object.getOwnPropertyNames(this)) {
                            typeof this[property] != 'function' && (this[property] = null);
                        }
                    };

                    $.fn.owlCarousel.Constructor.Plugins.autoplay = Autoplay;

                })(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);

                /**
                 * Navigation Plugin
                 * @version 2.3.4
                 * @author Artus Kolanowski
                 * @author David Deutsch
                 * @license The MIT License (MIT)
                 */
                ;(function($, window, document, undefined) {
                    'use strict';

                    /**
                     * Creates the navigation plugin.
                     * @class The Navigation Plugin
                     * @param {Owl} carousel - The Owl Carousel.
                     */
                    var Navigation = function(carousel) {
                        /**
                         * Reference to the core.
                         * @protected
                         * @type {Owl}
                         */
                        this._core = carousel;

                        /**
                         * Indicates whether the plugin is initialized or not.
                         * @protected
                         * @type {Boolean}
                         */
                        this._initialized = false;

                        /**
                         * The current paging indexes.
                         * @protected
                         * @type {Array}
                         */
                        this._pages = [];

                        /**
                         * All DOM elements of the user interface.
                         * @protected
                         * @type {Object}
                         */
                        this._controls = {};

                        /**
                         * Markup for an indicator.
                         * @protected
                         * @type {Array.<String>}
                         */
                        this._templates = [];

                        /**
                         * The carousel element.
                         * @type {jQuery}
                         */
                        this.$element = this._core.$element;

                        /**
                         * Overridden methods of the carousel.
                         * @protected
                         * @type {Object}
                         */
                        this._overrides = {
                            next: this._core.next,
                            prev: this._core.prev,
                            to: this._core.to
                        };

                        /**
                         * All event handlers.
                         * @protected
                         * @type {Object}
                         */
                        this._handlers = {
                            'prepared.owl.carousel': $.proxy(function(e) {
                                if (e.namespace && this._core.settings.dotsData) {
                                    this._templates.push('<div class="' + this._core.settings.dotClass + '">' +
                                        $(e.content).find('[data-dot]').addBack('[data-dot]').attr('data-dot') + '</div>');
                                }
                            }, this),
                            'added.owl.carousel': $.proxy(function(e) {
                                if (e.namespace && this._core.settings.dotsData) {
                                    this._templates.splice(e.position, 0, this._templates.pop());
                                }
                            }, this),
                            'remove.owl.carousel': $.proxy(function(e) {
                                if (e.namespace && this._core.settings.dotsData) {
                                    this._templates.splice(e.position, 1);
                                }
                            }, this),
                            'changed.owl.carousel': $.proxy(function(e) {
                                if (e.namespace && e.property.name == 'position') {
                                    this.draw();
                                }
                            }, this),
                            'initialized.owl.carousel': $.proxy(function(e) {
                                if (e.namespace && !this._initialized) {
                                    this._core.trigger('initialize', null, 'navigation');
                                    this.initialize();
                                    this.update();
                                    this.draw();
                                    this._initialized = true;
                                    this._core.trigger('initialized', null, 'navigation');
                                }
                            }, this),
                            'refreshed.owl.carousel': $.proxy(function(e) {
                                if (e.namespace && this._initialized) {
                                    this._core.trigger('refresh', null, 'navigation');
                                    this.update();
                                    this.draw();
                                    this._core.trigger('refreshed', null, 'navigation');
                                }
                            }, this)
                        };

                        // set default options
                        this._core.options = $.extend({}, Navigation.Defaults, this._core.options);

                        // register event handlers
                        this.$element.on(this._handlers);
                    };

                    /**
                     * Default options.
                     * @public
                     * @todo Rename `slideBy` to `navBy`
                     */
                    Navigation.Defaults = {
                        nav: false,
                        navText: [
                            '<span aria-label="' + 'Previous' + '">&#x2039;</span>',
                            '<span aria-label="' + 'Next' + '">&#x203a;</span>'
                        ],
                        navSpeed: false,
                        navElement: 'button type="button" role="presentation"',
                        navContainer: false,
                        navContainerClass: 'owl-nav',
                        navClass: [
                            'owl-prev',
                            'owl-next'
                        ],
                        slideBy: 1,
                        dotClass: 'owl-dot',
                        dotsClass: 'owl-dots',
                        dots: true,
                        dotsEach: false,
                        dotsData: false,
                        dotsSpeed: false,
                        dotsContainer: false
                    };

                    /**
                     * Initializes the layout of the plugin and extends the carousel.
                     * @protected
                     */
                    Navigation.prototype.initialize = function() {
                        var override,
                            settings = this._core.settings;

                        // create DOM structure for relative navigation
                        this._controls.$relative = (settings.navContainer ? $(settings.navContainer)
                            : $('<div>').addClass(settings.navContainerClass).appendTo(this.$element)).addClass('disabled');

                        this._controls.$previous = $('<' + settings.navElement + '>')
                            .addClass(settings.navClass[0])
                            .html(settings.navText[0])
                            .prependTo(this._controls.$relative)
                            .on('click', $.proxy(function(e) {
                                this.prev(settings.navSpeed);
                            }, this));
                        this._controls.$next = $('<' + settings.navElement + '>')
                            .addClass(settings.navClass[1])
                            .html(settings.navText[1])
                            .appendTo(this._controls.$relative)
                            .on('click', $.proxy(function(e) {
                                this.next(settings.navSpeed);
                            }, this));

                        // create DOM structure for absolute navigation
                        if (!settings.dotsData) {
                            this._templates = [ $('<button role="button">')
                                .addClass(settings.dotClass)
                                .append($('<span>'))
                                .prop('outerHTML') ];
                        }

                        this._controls.$absolute = (settings.dotsContainer ? $(settings.dotsContainer)
                            : $('<div>').addClass(settings.dotsClass).appendTo(this.$element)).addClass('disabled');

                        this._controls.$absolute.on('click', 'button', $.proxy(function(e) {
                            var index = $(e.target).parent().is(this._controls.$absolute)
                                ? $(e.target).index() : $(e.target).parent().index();

                            e.preventDefault();

                            this.to(index, settings.dotsSpeed);
                        }, this));

                        /*$el.on('focusin', function() {
			$(document).off(".carousel");

			$(document).on('keydown.carousel', function(e) {
				if(e.keyCode == 37) {
					$el.trigger('prev.owl')
				}
				if(e.keyCode == 39) {
					$el.trigger('next.owl')
				}
			});
		});*/

                        // override public methods of the carousel
                        for (override in this._overrides) {
                            this._core[override] = $.proxy(this[override], this);
                        }
                    };

                    /**
                     * Destroys the plugin.
                     * @protected
                     */
                    Navigation.prototype.destroy = function() {
                        var handler, control, property, override, settings;
                        settings = this._core.settings;

                        for (handler in this._handlers) {
                            this.$element.off(handler, this._handlers[handler]);
                        }
                        for (control in this._controls) {
                            if (control === '$relative' && settings.navContainer) {
                                this._controls[control].html('');
                            } else {
                                this._controls[control].remove();
                            }
                        }
                        for (override in this.overides) {
                            this._core[override] = this._overrides[override];
                        }
                        for (property in Object.getOwnPropertyNames(this)) {
                            typeof this[property] != 'function' && (this[property] = null);
                        }
                    };

                    /**
                     * Updates the internal state.
                     * @protected
                     */
                    Navigation.prototype.update = function() {
                        var i, j, k,
                            lower = this._core.clones().length / 2,
                            upper = lower + this._core.items().length,
                            maximum = this._core.maximum(true),
                            settings = this._core.settings,
                            size = settings.center || settings.autoWidth || settings.dotsData
                                ? 1 : settings.dotsEach || settings.items;

                        if (settings.slideBy !== 'page') {
                            settings.slideBy = Math.min(settings.slideBy, settings.items);
                        }

                        if (settings.dots || settings.slideBy == 'page') {
                            this._pages = [];

                            for (i = lower, j = 0, k = 0; i < upper; i++) {
                                if (j >= size || j === 0) {
                                    this._pages.push({
                                        start: Math.min(maximum, i - lower),
                                        end: i - lower + size - 1
                                    });
                                    if (Math.min(maximum, i - lower) === maximum) {
                                        break;
                                    }
                                    j = 0, ++k;
                                }
                                j += this._core.mergers(this._core.relative(i));
                            }
                        }
                    };

                    /**
                     * Draws the user interface.
                     * @todo The option `dotsData` wont work.
                     * @protected
                     */
                    Navigation.prototype.draw = function() {
                        var difference,
                            settings = this._core.settings,
                            disabled = this._core.items().length <= settings.items,
                            index = this._core.relative(this._core.current()),
                            loop = settings.loop || settings.rewind;

                        this._controls.$relative.toggleClass('disabled', !settings.nav || disabled);

                        if (settings.nav) {
                            this._controls.$previous.toggleClass('disabled', !loop && index <= this._core.minimum(true));
                            this._controls.$next.toggleClass('disabled', !loop && index >= this._core.maximum(true));
                        }

                        this._controls.$absolute.toggleClass('disabled', !settings.dots || disabled);

                        if (settings.dots) {
                            difference = this._pages.length - this._controls.$absolute.children().length;

                            if (settings.dotsData && difference !== 0) {
                                this._controls.$absolute.html(this._templates.join(''));
                            } else if (difference > 0) {
                                this._controls.$absolute.append(new Array(difference + 1).join(this._templates[0]));
                            } else if (difference < 0) {
                                this._controls.$absolute.children().slice(difference).remove();
                            }

                            this._controls.$absolute.find('.active').removeClass('active');
                            this._controls.$absolute.children().eq($.inArray(this.current(), this._pages)).addClass('active');
                        }
                    };

                    /**
                     * Extends event data.
                     * @protected
                     * @param {Event} event - The event object which gets thrown.
                     */
                    Navigation.prototype.onTrigger = function(event) {
                        var settings = this._core.settings;

                        event.page = {
                            index: $.inArray(this.current(), this._pages),
                            count: this._pages.length,
                            size: settings && (settings.center || settings.autoWidth || settings.dotsData
                                ? 1 : settings.dotsEach || settings.items)
                        };
                    };

                    /**
                     * Gets the current page position of the carousel.
                     * @protected
                     * @returns {Number}
                     */
                    Navigation.prototype.current = function() {
                        var current = this._core.relative(this._core.current());
                        return $.grep(this._pages, $.proxy(function(page, index) {
                            return page.start <= current && page.end >= current;
                        }, this)).pop();
                    };

                    /**
                     * Gets the current succesor/predecessor position.
                     * @protected
                     * @returns {Number}
                     */
                    Navigation.prototype.getPosition = function(successor) {
                        var position, length,
                            settings = this._core.settings;

                        if (settings.slideBy == 'page') {
                            position = $.inArray(this.current(), this._pages);
                            length = this._pages.length;
                            successor ? ++position : --position;
                            position = this._pages[((position % length) + length) % length].start;
                        } else {
                            position = this._core.relative(this._core.current());
                            length = this._core.items().length;
                            successor ? position += settings.slideBy : position -= settings.slideBy;
                        }

                        return position;
                    };

                    /**
                     * Slides to the next item or page.
                     * @public
                     * @param {Number} [speed=false] - The time in milliseconds for the transition.
                     */
                    Navigation.prototype.next = function(speed) {
                        $.proxy(this._overrides.to, this._core)(this.getPosition(true), speed);
                    };

                    /**
                     * Slides to the previous item or page.
                     * @public
                     * @param {Number} [speed=false] - The time in milliseconds for the transition.
                     */
                    Navigation.prototype.prev = function(speed) {
                        $.proxy(this._overrides.to, this._core)(this.getPosition(false), speed);
                    };

                    /**
                     * Slides to the specified item or page.
                     * @public
                     * @param {Number} position - The position of the item or page.
                     * @param {Number} [speed] - The time in milliseconds for the transition.
                     * @param {Boolean} [standard=false] - Whether to use the standard behaviour or not.
                     */
                    Navigation.prototype.to = function(position, speed, standard) {
                        var length;

                        if (!standard && this._pages.length) {
                            length = this._pages.length;
                            $.proxy(this._overrides.to, this._core)(this._pages[((position % length) + length) % length].start, speed);
                        } else {
                            $.proxy(this._overrides.to, this._core)(position, speed);
                        }
                    };

                    $.fn.owlCarousel.Constructor.Plugins.Navigation = Navigation;

                })(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);

                /**
                 * Hash Plugin
                 * @version 2.3.4
                 * @author Artus Kolanowski
                 * @author David Deutsch
                 * @license The MIT License (MIT)
                 */
                ;(function($, window, document, undefined) {
                    'use strict';

                    /**
                     * Creates the hash plugin.
                     * @class The Hash Plugin
                     * @param {Owl} carousel - The Owl Carousel
                     */
                    var Hash = function(carousel) {
                        /**
                         * Reference to the core.
                         * @protected
                         * @type {Owl}
                         */
                        this._core = carousel;

                        /**
                         * Hash index for the items.
                         * @protected
                         * @type {Object}
                         */
                        this._hashes = {};

                        /**
                         * The carousel element.
                         * @type {jQuery}
                         */
                        this.$element = this._core.$element;

                        /**
                         * All event handlers.
                         * @protected
                         * @type {Object}
                         */
                        this._handlers = {
                            'initialized.owl.carousel': $.proxy(function(e) {
                                if (e.namespace && this._core.settings.startPosition === 'URLHash') {
                                    $(window).trigger('hashchange.owl.navigation');
                                }
                            }, this),
                            'prepared.owl.carousel': $.proxy(function(e) {
                                if (e.namespace) {
                                    var hash = $(e.content).find('[data-hash]').addBack('[data-hash]').attr('data-hash');

                                    if (!hash) {
                                        return;
                                    }

                                    this._hashes[hash] = e.content;
                                }
                            }, this),
                            'changed.owl.carousel': $.proxy(function(e) {
                                if (e.namespace && e.property.name === 'position') {
                                    var current = this._core.items(this._core.relative(this._core.current())),
                                        hash = $.map(this._hashes, function(item, hash) {
                                            return item === current ? hash : null;
                                        }).join();

                                    if (!hash || window.location.hash.slice(1) === hash) {
                                        return;
                                    }

                                    window.location.hash = hash;
                                }
                            }, this)
                        };

                        // set default options
                        this._core.options = $.extend({}, Hash.Defaults, this._core.options);

                        // register the event handlers
                        this.$element.on(this._handlers);

                        // register event listener for hash navigation
                        $(window).on('hashchange.owl.navigation', $.proxy(function(e) {
                            var hash = window.location.hash.substring(1),
                                items = this._core.$stage.children(),
                                position = this._hashes[hash] && items.index(this._hashes[hash]);

                            if (position === undefined || position === this._core.current()) {
                                return;
                            }

                            this._core.to(this._core.relative(position), false, true);
                        }, this));
                    };

                    /**
                     * Default options.
                     * @public
                     */
                    Hash.Defaults = {
                        URLhashListener: false
                    };

                    /**
                     * Destroys the plugin.
                     * @public
                     */
                    Hash.prototype.destroy = function() {
                        var handler, property;

                        $(window).off('hashchange.owl.navigation');

                        for (handler in this._handlers) {
                            this._core.$element.off(handler, this._handlers[handler]);
                        }
                        for (property in Object.getOwnPropertyNames(this)) {
                            typeof this[property] != 'function' && (this[property] = null);
                        }
                    };

                    $.fn.owlCarousel.Constructor.Plugins.Hash = Hash;

                })(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);

                /**
                 * Support Plugin
                 *
                 * @version 2.3.4
                 * @author Vivid Planet Software GmbH
                 * @author Artus Kolanowski
                 * @author David Deutsch
                 * @license The MIT License (MIT)
                 */
                ;(function($, window, document, undefined) {

                    var style = $('<support>').get(0).style,
                        prefixes = 'Webkit Moz O ms'.split(' '),
                        events = {
                            transition: {
                                end: {
                                    WebkitTransition: 'webkitTransitionEnd',
                                    MozTransition: 'transitionend',
                                    OTransition: 'oTransitionEnd',
                                    transition: 'transitionend'
                                }
                            },
                            animation: {
                                end: {
                                    WebkitAnimation: 'webkitAnimationEnd',
                                    MozAnimation: 'animationend',
                                    OAnimation: 'oAnimationEnd',
                                    animation: 'animationend'
                                }
                            }
                        },
                        tests = {
                            csstransforms: function() {
                                return !!test('transform');
                            },
                            csstransforms3d: function() {
                                return !!test('perspective');
                            },
                            csstransitions: function() {
                                return !!test('transition');
                            },
                            cssanimations: function() {
                                return !!test('animation');
                            }
                        };

                    function test(property, prefixed) {
                        var result = false,
                            upper = property.charAt(0).toUpperCase() + property.slice(1);

                        $.each((property + ' ' + prefixes.join(upper + ' ') + upper).split(' '), function(i, property) {
                            if (style[property] !== undefined) {
                                result = prefixed ? property : true;
                                return false;
                            }
                        });

                        return result;
                    }

                    function prefixed(property) {
                        return test(property, true);
                    }

                    if (tests.csstransitions()) {
                        /* jshint -W053 */
                        $.support.transition = new String(prefixed('transition'))
                        $.support.transition.end = events.transition.end[ $.support.transition ];
                    }

                    if (tests.cssanimations()) {
                        /* jshint -W053 */
                        $.support.animation = new String(prefixed('animation'))
                        $.support.animation.end = events.animation.end[ $.support.animation ];
                    }

                    if (tests.csstransforms()) {
                        /* jshint -W053 */
                        $.support.transform = new String(prefixed('transform'));
                        $.support.transform3d = tests.csstransforms3d();
                    }

                })(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);

                /* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js"), __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

            /***/ }),

        /***/ "./node_modules/select2/dist/js/select2.js":
        /*!*************************************************!*\
  !*** ./node_modules/select2/dist/js/select2.js ***!
  \*************************************************/
        /*! no static exports found */
        /***/ (function(module, exports, __webpack_require__) {

            /* WEBPACK VAR INJECTION */(function($) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var require;var require;/*!
 * Select2 4.0.13
 * https://select2.github.io
 *
 * Released under the MIT license
 * https://github.com/select2/select2/blob/master/LICENSE.md
 */
                ;(function (factory) {
                    if (true) {
                        // AMD. Register as an anonymous module.
                        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                            __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                                (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                        __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                    } else {}
                } (function (jQuery) {
                    // This is needed so we can catch the AMD loader configuration and use it
                    // The inner file should be wrapped (by `banner.start.js`) in a function that
                    // returns the AMD loader references.
                    var S2 =(function () {
                        // Restore the Select2 AMD loader so it can be used
                        // Needed mostly in the language files, where the loader is not inserted
                        if (jQuery && jQuery.fn && jQuery.fn.select2 && jQuery.fn.select2.amd) {
                            var S2 = jQuery.fn.select2.amd;
                        }
                        var S2;(function () { if (!S2 || !S2.requirejs) {
                            if (!S2) { S2 = {}; } else { require = S2; }
                            /**
                             * @license almond 0.3.3 Copyright jQuery Foundation and other contributors.
                             * Released under MIT license, http://github.com/requirejs/almond/LICENSE
                             */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
                            /*global setTimeout: false */

                            var requirejs, require, define;
                            (function (undef) {
                                var main, req, makeMap, handlers,
                                    defined = {},
                                    waiting = {},
                                    config = {},
                                    defining = {},
                                    hasOwn = Object.prototype.hasOwnProperty,
                                    aps = [].slice,
                                    jsSuffixRegExp = /\.js$/;

                                function hasProp(obj, prop) {
                                    return hasOwn.call(obj, prop);
                                }

                                /**
                                 * Given a relative module name, like ./something, normalize it to
                                 * a real name that can be mapped to a path.
                                 * @param {String} name the relative name
                                 * @param {String} baseName a real name that the name arg is relative
                                 * to.
                                 * @returns {String} normalized name
                                 */
                                function normalize(name, baseName) {
                                    var nameParts, nameSegment, mapValue, foundMap, lastIndex,
                                        foundI, foundStarMap, starI, i, j, part, normalizedBaseParts,
                                        baseParts = baseName && baseName.split("/"),
                                        map = config.map,
                                        starMap = (map && map['*']) || {};

                                    //Adjust any relative paths.
                                    if (name) {
                                        name = name.split('/');
                                        lastIndex = name.length - 1;

                                        // If wanting node ID compatibility, strip .js from end
                                        // of IDs. Have to do this here, and not in nameToUrl
                                        // because node allows either .js or non .js to map
                                        // to same file.
                                        if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                                            name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                                        }

                                        // Starts with a '.' so need the baseName
                                        if (name[0].charAt(0) === '.' && baseParts) {
                                            //Convert baseName to array, and lop off the last part,
                                            //so that . matches that 'directory' and not name of the baseName's
                                            //module. For instance, baseName of 'one/two/three', maps to
                                            //'one/two/three.js', but we want the directory, 'one/two' for
                                            //this normalization.
                                            normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
                                            name = normalizedBaseParts.concat(name);
                                        }

                                        //start trimDots
                                        for (i = 0; i < name.length; i++) {
                                            part = name[i];
                                            if (part === '.') {
                                                name.splice(i, 1);
                                                i -= 1;
                                            } else if (part === '..') {
                                                // If at the start, or previous value is still ..,
                                                // keep them so that when converted to a path it may
                                                // still work when converted to a path, even though
                                                // as an ID it is less than ideal. In larger point
                                                // releases, may be better to just kick out an error.
                                                if (i === 0 || (i === 1 && name[2] === '..') || name[i - 1] === '..') {
                                                    continue;
                                                } else if (i > 0) {
                                                    name.splice(i - 1, 2);
                                                    i -= 2;
                                                }
                                            }
                                        }
                                        //end trimDots

                                        name = name.join('/');
                                    }

                                    //Apply map config if available.
                                    if ((baseParts || starMap) && map) {
                                        nameParts = name.split('/');

                                        for (i = nameParts.length; i > 0; i -= 1) {
                                            nameSegment = nameParts.slice(0, i).join("/");

                                            if (baseParts) {
                                                //Find the longest baseName segment match in the config.
                                                //So, do joins on the biggest to smallest lengths of baseParts.
                                                for (j = baseParts.length; j > 0; j -= 1) {
                                                    mapValue = map[baseParts.slice(0, j).join('/')];

                                                    //baseName segment has  config, find if it has one for
                                                    //this name.
                                                    if (mapValue) {
                                                        mapValue = mapValue[nameSegment];
                                                        if (mapValue) {
                                                            //Match, update name to the new value.
                                                            foundMap = mapValue;
                                                            foundI = i;
                                                            break;
                                                        }
                                                    }
                                                }
                                            }

                                            if (foundMap) {
                                                break;
                                            }

                                            //Check for a star map match, but just hold on to it,
                                            //if there is a shorter segment match later in a matching
                                            //config, then favor over this star map.
                                            if (!foundStarMap && starMap && starMap[nameSegment]) {
                                                foundStarMap = starMap[nameSegment];
                                                starI = i;
                                            }
                                        }

                                        if (!foundMap && foundStarMap) {
                                            foundMap = foundStarMap;
                                            foundI = starI;
                                        }

                                        if (foundMap) {
                                            nameParts.splice(0, foundI, foundMap);
                                            name = nameParts.join('/');
                                        }
                                    }

                                    return name;
                                }

                                function makeRequire(relName, forceSync) {
                                    return function () {
                                        //A version of a require function that passes a moduleName
                                        //value for items that may need to
                                        //look up paths relative to the moduleName
                                        var args = aps.call(arguments, 0);

                                        //If first arg is not require('string'), and there is only
                                        //one arg, it is the array form without a callback. Insert
                                        //a null so that the following concat is correct.
                                        if (typeof args[0] !== 'string' && args.length === 1) {
                                            args.push(null);
                                        }
                                        return req.apply(undef, args.concat([relName, forceSync]));
                                    };
                                }

                                function makeNormalize(relName) {
                                    return function (name) {
                                        return normalize(name, relName);
                                    };
                                }

                                function makeLoad(depName) {
                                    return function (value) {
                                        defined[depName] = value;
                                    };
                                }

                                function callDep(name) {
                                    if (hasProp(waiting, name)) {
                                        var args = waiting[name];
                                        delete waiting[name];
                                        defining[name] = true;
                                        main.apply(undef, args);
                                    }

                                    if (!hasProp(defined, name) && !hasProp(defining, name)) {
                                        throw new Error('No ' + name);
                                    }
                                    return defined[name];
                                }

                                //Turns a plugin!resource to [plugin, resource]
                                //with the plugin being undefined if the name
                                //did not have a plugin prefix.
                                function splitPrefix(name) {
                                    var prefix,
                                        index = name ? name.indexOf('!') : -1;
                                    if (index > -1) {
                                        prefix = name.substring(0, index);
                                        name = name.substring(index + 1, name.length);
                                    }
                                    return [prefix, name];
                                }

                                //Creates a parts array for a relName where first part is plugin ID,
                                //second part is resource ID. Assumes relName has already been normalized.
                                function makeRelParts(relName) {
                                    return relName ? splitPrefix(relName) : [];
                                }

                                /**
                                 * Makes a name map, normalizing the name, and using a plugin
                                 * for normalization if necessary. Grabs a ref to plugin
                                 * too, as an optimization.
                                 */
                                makeMap = function (name, relParts) {
                                    var plugin,
                                        parts = splitPrefix(name),
                                        prefix = parts[0],
                                        relResourceName = relParts[1];

                                    name = parts[1];

                                    if (prefix) {
                                        prefix = normalize(prefix, relResourceName);
                                        plugin = callDep(prefix);
                                    }

                                    //Normalize according
                                    if (prefix) {
                                        if (plugin && plugin.normalize) {
                                            name = plugin.normalize(name, makeNormalize(relResourceName));
                                        } else {
                                            name = normalize(name, relResourceName);
                                        }
                                    } else {
                                        name = normalize(name, relResourceName);
                                        parts = splitPrefix(name);
                                        prefix = parts[0];
                                        name = parts[1];
                                        if (prefix) {
                                            plugin = callDep(prefix);
                                        }
                                    }

                                    //Using ridiculous property names for space reasons
                                    return {
                                        f: prefix ? prefix + '!' + name : name, //fullName
                                        n: name,
                                        pr: prefix,
                                        p: plugin
                                    };
                                };

                                function makeConfig(name) {
                                    return function () {
                                        return (config && config.config && config.config[name]) || {};
                                    };
                                }

                                handlers = {
                                    require: function (name) {
                                        return makeRequire(name);
                                    },
                                    exports: function (name) {
                                        var e = defined[name];
                                        if (typeof e !== 'undefined') {
                                            return e;
                                        } else {
                                            return (defined[name] = {});
                                        }
                                    },
                                    module: function (name) {
                                        return {
                                            id: name,
                                            uri: '',
                                            exports: defined[name],
                                            config: makeConfig(name)
                                        };
                                    }
                                };

                                main = function (name, deps, callback, relName) {
                                    var cjsModule, depName, ret, map, i, relParts,
                                        args = [],
                                        callbackType = typeof callback,
                                        usingExports;

                                    //Use name if no relName
                                    relName = relName || name;
                                    relParts = makeRelParts(relName);

                                    //Call the callback to define the module, if necessary.
                                    if (callbackType === 'undefined' || callbackType === 'function') {
                                        //Pull out the defined dependencies and pass the ordered
                                        //values to the callback.
                                        //Default to [require, exports, module] if no deps
                                        deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
                                        for (i = 0; i < deps.length; i += 1) {
                                            map = makeMap(deps[i], relParts);
                                            depName = map.f;

                                            //Fast path CommonJS standard dependencies.
                                            if (depName === "require") {
                                                args[i] = handlers.require(name);
                                            } else if (depName === "exports") {
                                                //CommonJS module spec 1.1
                                                args[i] = handlers.exports(name);
                                                usingExports = true;
                                            } else if (depName === "module") {
                                                //CommonJS module spec 1.1
                                                cjsModule = args[i] = handlers.module(name);
                                            } else if (hasProp(defined, depName) ||
                                                hasProp(waiting, depName) ||
                                                hasProp(defining, depName)) {
                                                args[i] = callDep(depName);
                                            } else if (map.p) {
                                                map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                                                args[i] = defined[depName];
                                            } else {
                                                throw new Error(name + ' missing ' + depName);
                                            }
                                        }

                                        ret = callback ? callback.apply(defined[name], args) : undefined;

                                        if (name) {
                                            //If setting exports via "module" is in play,
                                            //favor that over return value and exports. After that,
                                            //favor a non-undefined return value over exports use.
                                            if (cjsModule && cjsModule.exports !== undef &&
                                                cjsModule.exports !== defined[name]) {
                                                defined[name] = cjsModule.exports;
                                            } else if (ret !== undef || !usingExports) {
                                                //Use the return value from the function.
                                                defined[name] = ret;
                                            }
                                        }
                                    } else if (name) {
                                        //May just be an object definition for the module. Only
                                        //worry about defining if have a module name.
                                        defined[name] = callback;
                                    }
                                };

                                requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
                                    if (typeof deps === "string") {
                                        if (handlers[deps]) {
                                            //callback in this case is really relName
                                            return handlers[deps](callback);
                                        }
                                        //Just return the module wanted. In this scenario, the
                                        //deps arg is the module name, and second arg (if passed)
                                        //is just the relName.
                                        //Normalize module name, if it contains . or ..
                                        return callDep(makeMap(deps, makeRelParts(callback)).f);
                                    } else if (!deps.splice) {
                                        //deps is a config object, not an array.
                                        config = deps;
                                        if (config.deps) {
                                            req(config.deps, config.callback);
                                        }
                                        if (!callback) {
                                            return;
                                        }

                                        if (callback.splice) {
                                            //callback is an array, which means it is a dependency list.
                                            //Adjust args if there are dependencies
                                            deps = callback;
                                            callback = relName;
                                            relName = null;
                                        } else {
                                            deps = undef;
                                        }
                                    }

                                    //Support require(['a'])
                                    callback = callback || function () {};

                                    //If relName is a function, it is an errback handler,
                                    //so remove it.
                                    if (typeof relName === 'function') {
                                        relName = forceSync;
                                        forceSync = alt;
                                    }

                                    //Simulate async callback;
                                    if (forceSync) {
                                        main(undef, deps, callback, relName);
                                    } else {
                                        //Using a non-zero value because of concern for what old browsers
                                        //do, and latest browsers "upgrade" to 4 if lower value is used:
                                        //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
                                        //If want a value immediately, use require('id') instead -- something
                                        //that works in almond on the global level, but not guaranteed and
                                        //unlikely to work in other AMD implementations.
                                        setTimeout(function () {
                                            main(undef, deps, callback, relName);
                                        }, 4);
                                    }

                                    return req;
                                };

                                /**
                                 * Just drops the config on the floor, but returns req in case
                                 * the config return value is used.
                                 */
                                req.config = function (cfg) {
                                    return req(cfg);
                                };

                                /**
                                 * Expose module registry for debugging and tooling
                                 */
                                requirejs._defined = defined;

                                define = function (name, deps, callback) {
                                    if (typeof name !== 'string') {
                                        throw new Error('See almond README: incorrect module build, no module name');
                                    }

                                    //This module may not have dependencies
                                    if (!deps.splice) {
                                        //deps is not an array, so probably means
                                        //an object literal or factory function for
                                        //the value. Adjust args.
                                        callback = deps;
                                        deps = [];
                                    }

                                    if (!hasProp(defined, name) && !hasProp(waiting, name)) {
                                        waiting[name] = [name, deps, callback];
                                    }
                                };

                                define.amd = {
                                    jQuery: true
                                };
                            }());

                            S2.requirejs = requirejs;S2.require = require;S2.define = define;
                        }
                        }());
                        S2.define("almond", function(){});

                        /* global jQuery:false, $:false */
                        S2.define('jquery',[],function () {
                            var _$ = jQuery || $;

                            if (_$ == null && console && console.error) {
                                console.error(
                                    'Select2: An instance of jQuery or a jQuery-compatible library was not ' +
                                    'found. Make sure that you are including jQuery before Select2 on your ' +
                                    'web page.'
                                );
                            }

                            return _$;
                        });

                        S2.define('select2/utils',[
                            'jquery'
                        ], function ($) {
                            var Utils = {};

                            Utils.Extend = function (ChildClass, SuperClass) {
                                var __hasProp = {}.hasOwnProperty;

                                function BaseConstructor () {
                                    this.constructor = ChildClass;
                                }

                                for (var key in SuperClass) {
                                    if (__hasProp.call(SuperClass, key)) {
                                        ChildClass[key] = SuperClass[key];
                                    }
                                }

                                BaseConstructor.prototype = SuperClass.prototype;
                                ChildClass.prototype = new BaseConstructor();
                                ChildClass.__super__ = SuperClass.prototype;

                                return ChildClass;
                            };

                            function getMethods (theClass) {
                                var proto = theClass.prototype;

                                var methods = [];

                                for (var methodName in proto) {
                                    var m = proto[methodName];

                                    if (typeof m !== 'function') {
                                        continue;
                                    }

                                    if (methodName === 'constructor') {
                                        continue;
                                    }

                                    methods.push(methodName);
                                }

                                return methods;
                            }

                            Utils.Decorate = function (SuperClass, DecoratorClass) {
                                var decoratedMethods = getMethods(DecoratorClass);
                                var superMethods = getMethods(SuperClass);

                                function DecoratedClass () {
                                    var unshift = Array.prototype.unshift;

                                    var argCount = DecoratorClass.prototype.constructor.length;

                                    var calledConstructor = SuperClass.prototype.constructor;

                                    if (argCount > 0) {
                                        unshift.call(arguments, SuperClass.prototype.constructor);

                                        calledConstructor = DecoratorClass.prototype.constructor;
                                    }

                                    calledConstructor.apply(this, arguments);
                                }

                                DecoratorClass.displayName = SuperClass.displayName;

                                function ctr () {
                                    this.constructor = DecoratedClass;
                                }

                                DecoratedClass.prototype = new ctr();

                                for (var m = 0; m < superMethods.length; m++) {
                                    var superMethod = superMethods[m];

                                    DecoratedClass.prototype[superMethod] =
                                        SuperClass.prototype[superMethod];
                                }

                                var calledMethod = function (methodName) {
                                    // Stub out the original method if it's not decorating an actual method
                                    var originalMethod = function () {};

                                    if (methodName in DecoratedClass.prototype) {
                                        originalMethod = DecoratedClass.prototype[methodName];
                                    }

                                    var decoratedMethod = DecoratorClass.prototype[methodName];

                                    return function () {
                                        var unshift = Array.prototype.unshift;

                                        unshift.call(arguments, originalMethod);

                                        return decoratedMethod.apply(this, arguments);
                                    };
                                };

                                for (var d = 0; d < decoratedMethods.length; d++) {
                                    var decoratedMethod = decoratedMethods[d];

                                    DecoratedClass.prototype[decoratedMethod] = calledMethod(decoratedMethod);
                                }

                                return DecoratedClass;
                            };

                            var Observable = function () {
                                this.listeners = {};
                            };

                            Observable.prototype.on = function (event, callback) {
                                this.listeners = this.listeners || {};

                                if (event in this.listeners) {
                                    this.listeners[event].push(callback);
                                } else {
                                    this.listeners[event] = [callback];
                                }
                            };

                            Observable.prototype.trigger = function (event) {
                                var slice = Array.prototype.slice;
                                var params = slice.call(arguments, 1);

                                this.listeners = this.listeners || {};

                                // Params should always come in as an array
                                if (params == null) {
                                    params = [];
                                }

                                // If there are no arguments to the event, use a temporary object
                                if (params.length === 0) {
                                    params.push({});
                                }

                                // Set the `_type` of the first object to the event
                                params[0]._type = event;

                                if (event in this.listeners) {
                                    this.invoke(this.listeners[event], slice.call(arguments, 1));
                                }

                                if ('*' in this.listeners) {
                                    this.invoke(this.listeners['*'], arguments);
                                }
                            };

                            Observable.prototype.invoke = function (listeners, params) {
                                for (var i = 0, len = listeners.length; i < len; i++) {
                                    listeners[i].apply(this, params);
                                }
                            };

                            Utils.Observable = Observable;

                            Utils.generateChars = function (length) {
                                var chars = '';

                                for (var i = 0; i < length; i++) {
                                    var randomChar = Math.floor(Math.random() * 36);
                                    chars += randomChar.toString(36);
                                }

                                return chars;
                            };

                            Utils.bind = function (func, context) {
                                return function () {
                                    func.apply(context, arguments);
                                };
                            };

                            Utils._convertData = function (data) {
                                for (var originalKey in data) {
                                    var keys = originalKey.split('-');

                                    var dataLevel = data;

                                    if (keys.length === 1) {
                                        continue;
                                    }

                                    for (var k = 0; k < keys.length; k++) {
                                        var key = keys[k];

                                        // Lowercase the first letter
                                        // By default, dash-separated becomes camelCase
                                        key = key.substring(0, 1).toLowerCase() + key.substring(1);

                                        if (!(key in dataLevel)) {
                                            dataLevel[key] = {};
                                        }

                                        if (k == keys.length - 1) {
                                            dataLevel[key] = data[originalKey];
                                        }

                                        dataLevel = dataLevel[key];
                                    }

                                    delete data[originalKey];
                                }

                                return data;
                            };

                            Utils.hasScroll = function (index, el) {
                                // Adapted from the function created by @ShadowScripter
                                // and adapted by @BillBarry on the Stack Exchange Code Review website.
                                // The original code can be found at
                                // http://codereview.stackexchange.com/q/13338
                                // and was designed to be used with the Sizzle selector engine.

                                var $el = $(el);
                                var overflowX = el.style.overflowX;
                                var overflowY = el.style.overflowY;

                                //Check both x and y declarations
                                if (overflowX === overflowY &&
                                    (overflowY === 'hidden' || overflowY === 'visible')) {
                                    return false;
                                }

                                if (overflowX === 'scroll' || overflowY === 'scroll') {
                                    return true;
                                }

                                return ($el.innerHeight() < el.scrollHeight ||
                                    $el.innerWidth() < el.scrollWidth);
                            };

                            Utils.escapeMarkup = function (markup) {
                                var replaceMap = {
                                    '\\': '&#92;',
                                    '&': '&amp;',
                                    '<': '&lt;',
                                    '>': '&gt;',
                                    '"': '&quot;',
                                    '\'': '&#39;',
                                    '/': '&#47;'
                                };

                                // Do not try to escape the markup if it's not a string
                                if (typeof markup !== 'string') {
                                    return markup;
                                }

                                return String(markup).replace(/[&<>"'\/\\]/g, function (match) {
                                    return replaceMap[match];
                                });
                            };

                            // Append an array of jQuery nodes to a given element.
                            Utils.appendMany = function ($element, $nodes) {
                                // jQuery 1.7.x does not support $.fn.append() with an array
                                // Fall back to a jQuery object collection using $.fn.add()
                                if ($.fn.jquery.substr(0, 3) === '1.7') {
                                    var $jqNodes = $();

                                    $.map($nodes, function (node) {
                                        $jqNodes = $jqNodes.add(node);
                                    });

                                    $nodes = $jqNodes;
                                }

                                $element.append($nodes);
                            };

                            // Cache objects in Utils.__cache instead of $.data (see #4346)
                            Utils.__cache = {};

                            var id = 0;
                            Utils.GetUniqueElementId = function (element) {
                                // Get a unique element Id. If element has no id,
                                // creates a new unique number, stores it in the id
                                // attribute and returns the new id.
                                // If an id already exists, it simply returns it.

                                var select2Id = element.getAttribute('data-select2-id');
                                if (select2Id == null) {
                                    // If element has id, use it.
                                    if (element.id) {
                                        select2Id = element.id;
                                        element.setAttribute('data-select2-id', select2Id);
                                    } else {
                                        element.setAttribute('data-select2-id', ++id);
                                        select2Id = id.toString();
                                    }
                                }
                                return select2Id;
                            };

                            Utils.StoreData = function (element, name, value) {
                                // Stores an item in the cache for a specified element.
                                // name is the cache key.
                                var id = Utils.GetUniqueElementId(element);
                                if (!Utils.__cache[id]) {
                                    Utils.__cache[id] = {};
                                }

                                Utils.__cache[id][name] = value;
                            };

                            Utils.GetData = function (element, name) {
                                // Retrieves a value from the cache by its key (name)
                                // name is optional. If no name specified, return
                                // all cache items for the specified element.
                                // and for a specified element.
                                var id = Utils.GetUniqueElementId(element);
                                if (name) {
                                    if (Utils.__cache[id]) {
                                        if (Utils.__cache[id][name] != null) {
                                            return Utils.__cache[id][name];
                                        }
                                        return $(element).data(name); // Fallback to HTML5 data attribs.
                                    }
                                    return $(element).data(name); // Fallback to HTML5 data attribs.
                                } else {
                                    return Utils.__cache[id];
                                }
                            };

                            Utils.RemoveData = function (element) {
                                // Removes all cached items for a specified element.
                                var id = Utils.GetUniqueElementId(element);
                                if (Utils.__cache[id] != null) {
                                    delete Utils.__cache[id];
                                }

                                element.removeAttribute('data-select2-id');
                            };

                            return Utils;
                        });

                        S2.define('select2/results',[
                            'jquery',
                            './utils'
                        ], function ($, Utils) {
                            function Results ($element, options, dataAdapter) {
                                this.$element = $element;
                                this.data = dataAdapter;
                                this.options = options;

                                Results.__super__.constructor.call(this);
                            }

                            Utils.Extend(Results, Utils.Observable);

                            Results.prototype.render = function () {
                                var $results = $(
                                    '<ul class="select2-results__options" role="listbox"></ul>'
                                );

                                if (this.options.get('multiple')) {
                                    $results.attr('aria-multiselectable', 'true');
                                }

                                this.$results = $results;

                                return $results;
                            };

                            Results.prototype.clear = function () {
                                this.$results.empty();
                            };

                            Results.prototype.displayMessage = function (params) {
                                var escapeMarkup = this.options.get('escapeMarkup');

                                this.clear();
                                this.hideLoading();

                                var $message = $(
                                    '<li role="alert" aria-live="assertive"' +
                                    ' class="select2-results__option"></li>'
                                );

                                var message = this.options.get('translations').get(params.message);

                                $message.append(
                                    escapeMarkup(
                                        message(params.args)
                                    )
                                );

                                $message[0].className += ' select2-results__message';

                                this.$results.append($message);
                            };

                            Results.prototype.hideMessages = function () {
                                this.$results.find('.select2-results__message').remove();
                            };

                            Results.prototype.append = function (data) {
                                this.hideLoading();

                                var $options = [];

                                if (data.results == null || data.results.length === 0) {
                                    if (this.$results.children().length === 0) {
                                        this.trigger('results:message', {
                                            message: 'noResults'
                                        });
                                    }

                                    return;
                                }

                                data.results = this.sort(data.results);

                                for (var d = 0; d < data.results.length; d++) {
                                    var item = data.results[d];

                                    var $option = this.option(item);

                                    $options.push($option);
                                }

                                this.$results.append($options);
                            };

                            Results.prototype.position = function ($results, $dropdown) {
                                var $resultsContainer = $dropdown.find('.select2-results');
                                $resultsContainer.append($results);
                            };

                            Results.prototype.sort = function (data) {
                                var sorter = this.options.get('sorter');

                                return sorter(data);
                            };

                            Results.prototype.highlightFirstItem = function () {
                                var $options = this.$results
                                    .find('.select2-results__option[aria-selected]');

                                var $selected = $options.filter('[aria-selected=true]');

                                // Check if there are any selected options
                                if ($selected.length > 0) {
                                    // If there are selected options, highlight the first
                                    $selected.first().trigger('mouseenter');
                                } else {
                                    // If there are no selected options, highlight the first option
                                    // in the dropdown
                                    $options.first().trigger('mouseenter');
                                }

                                this.ensureHighlightVisible();
                            };

                            Results.prototype.setClasses = function () {
                                var self = this;

                                this.data.current(function (selected) {
                                    var selectedIds = $.map(selected, function (s) {
                                        return s.id.toString();
                                    });

                                    var $options = self.$results
                                        .find('.select2-results__option[aria-selected]');

                                    $options.each(function () {
                                        var $option = $(this);

                                        var item = Utils.GetData(this, 'data');

                                        // id needs to be converted to a string when comparing
                                        var id = '' + item.id;

                                        if ((item.element != null && item.element.selected) ||
                                            (item.element == null && $.inArray(id, selectedIds) > -1)) {
                                            $option.attr('aria-selected', 'true');
                                        } else {
                                            $option.attr('aria-selected', 'false');
                                        }
                                    });

                                });
                            };

                            Results.prototype.showLoading = function (params) {
                                this.hideLoading();

                                var loadingMore = this.options.get('translations').get('searching');

                                var loading = {
                                    disabled: true,
                                    loading: true,
                                    text: loadingMore(params)
                                };
                                var $loading = this.option(loading);
                                $loading.className += ' loading-results';

                                this.$results.prepend($loading);
                            };

                            Results.prototype.hideLoading = function () {
                                this.$results.find('.loading-results').remove();
                            };

                            Results.prototype.option = function (data) {
                                var option = document.createElement('li');
                                option.className = 'select2-results__option';

                                var attrs = {
                                    'role': 'option',
                                    'aria-selected': 'false'
                                };

                                var matches = window.Element.prototype.matches ||
                                    window.Element.prototype.msMatchesSelector ||
                                    window.Element.prototype.webkitMatchesSelector;

                                if ((data.element != null && matches.call(data.element, ':disabled')) ||
                                    (data.element == null && data.disabled)) {
                                    delete attrs['aria-selected'];
                                    attrs['aria-disabled'] = 'true';
                                }

                                if (data.id == null) {
                                    delete attrs['aria-selected'];
                                }

                                if (data._resultId != null) {
                                    option.id = data._resultId;
                                }

                                if (data.title) {
                                    option.title = data.title;
                                }

                                if (data.children) {
                                    attrs.role = 'group';
                                    attrs['aria-label'] = data.text;
                                    delete attrs['aria-selected'];
                                }

                                for (var attr in attrs) {
                                    var val = attrs[attr];

                                    option.setAttribute(attr, val);
                                }

                                if (data.children) {
                                    var $option = $(option);

                                    var label = document.createElement('strong');
                                    label.className = 'select2-results__group';

                                    var $label = $(label);
                                    this.template(data, label);

                                    var $children = [];

                                    for (var c = 0; c < data.children.length; c++) {
                                        var child = data.children[c];

                                        var $child = this.option(child);

                                        $children.push($child);
                                    }

                                    var $childrenContainer = $('<ul></ul>', {
                                        'class': 'select2-results__options select2-results__options--nested'
                                    });

                                    $childrenContainer.append($children);

                                    $option.append(label);
                                    $option.append($childrenContainer);
                                } else {
                                    this.template(data, option);
                                }

                                Utils.StoreData(option, 'data', data);

                                return option;
                            };

                            Results.prototype.bind = function (container, $container) {
                                var self = this;

                                var id = container.id + '-results';

                                this.$results.attr('id', id);

                                container.on('results:all', function (params) {
                                    self.clear();
                                    self.append(params.data);

                                    if (container.isOpen()) {
                                        self.setClasses();
                                        self.highlightFirstItem();
                                    }
                                });

                                container.on('results:append', function (params) {
                                    self.append(params.data);

                                    if (container.isOpen()) {
                                        self.setClasses();
                                    }
                                });

                                container.on('query', function (params) {
                                    self.hideMessages();
                                    self.showLoading(params);
                                });

                                container.on('select', function () {
                                    if (!container.isOpen()) {
                                        return;
                                    }

                                    self.setClasses();

                                    if (self.options.get('scrollAfterSelect')) {
                                        self.highlightFirstItem();
                                    }
                                });

                                container.on('unselect', function () {
                                    if (!container.isOpen()) {
                                        return;
                                    }

                                    self.setClasses();

                                    if (self.options.get('scrollAfterSelect')) {
                                        self.highlightFirstItem();
                                    }
                                });

                                container.on('open', function () {
                                    // When the dropdown is open, aria-expended="true"
                                    self.$results.attr('aria-expanded', 'true');
                                    self.$results.attr('aria-hidden', 'false');

                                    self.setClasses();
                                    self.ensureHighlightVisible();
                                });

                                container.on('close', function () {
                                    // When the dropdown is closed, aria-expended="false"
                                    self.$results.attr('aria-expanded', 'false');
                                    self.$results.attr('aria-hidden', 'true');
                                    self.$results.removeAttr('aria-activedescendant');
                                });

                                container.on('results:toggle', function () {
                                    var $highlighted = self.getHighlightedResults();

                                    if ($highlighted.length === 0) {
                                        return;
                                    }

                                    $highlighted.trigger('mouseup');
                                });

                                container.on('results:select', function () {
                                    var $highlighted = self.getHighlightedResults();

                                    if ($highlighted.length === 0) {
                                        return;
                                    }

                                    var data = Utils.GetData($highlighted[0], 'data');

                                    if ($highlighted.attr('aria-selected') == 'true') {
                                        self.trigger('close', {});
                                    } else {
                                        self.trigger('select', {
                                            data: data
                                        });
                                    }
                                });

                                container.on('results:previous', function () {
                                    var $highlighted = self.getHighlightedResults();

                                    var $options = self.$results.find('[aria-selected]');

                                    var currentIndex = $options.index($highlighted);

                                    // If we are already at the top, don't move further
                                    // If no options, currentIndex will be -1
                                    if (currentIndex <= 0) {
                                        return;
                                    }

                                    var nextIndex = currentIndex - 1;

                                    // If none are highlighted, highlight the first
                                    if ($highlighted.length === 0) {
                                        nextIndex = 0;
                                    }

                                    var $next = $options.eq(nextIndex);

                                    $next.trigger('mouseenter');

                                    var currentOffset = self.$results.offset().top;
                                    var nextTop = $next.offset().top;
                                    var nextOffset = self.$results.scrollTop() + (nextTop - currentOffset);

                                    if (nextIndex === 0) {
                                        self.$results.scrollTop(0);
                                    } else if (nextTop - currentOffset < 0) {
                                        self.$results.scrollTop(nextOffset);
                                    }
                                });

                                container.on('results:next', function () {
                                    var $highlighted = self.getHighlightedResults();

                                    var $options = self.$results.find('[aria-selected]');

                                    var currentIndex = $options.index($highlighted);

                                    var nextIndex = currentIndex + 1;

                                    // If we are at the last option, stay there
                                    if (nextIndex >= $options.length) {
                                        return;
                                    }

                                    var $next = $options.eq(nextIndex);

                                    $next.trigger('mouseenter');

                                    var currentOffset = self.$results.offset().top +
                                        self.$results.outerHeight(false);
                                    var nextBottom = $next.offset().top + $next.outerHeight(false);
                                    var nextOffset = self.$results.scrollTop() + nextBottom - currentOffset;

                                    if (nextIndex === 0) {
                                        self.$results.scrollTop(0);
                                    } else if (nextBottom > currentOffset) {
                                        self.$results.scrollTop(nextOffset);
                                    }
                                });

                                container.on('results:focus', function (params) {
                                    params.element.addClass('select2-results__option--highlighted');
                                });

                                container.on('results:message', function (params) {
                                    self.displayMessage(params);
                                });

                                if ($.fn.mousewheel) {
                                    this.$results.on('mousewheel', function (e) {
                                        var top = self.$results.scrollTop();

                                        var bottom = self.$results.get(0).scrollHeight - top + e.deltaY;

                                        var isAtTop = e.deltaY > 0 && top - e.deltaY <= 0;
                                        var isAtBottom = e.deltaY < 0 && bottom <= self.$results.height();

                                        if (isAtTop) {
                                            self.$results.scrollTop(0);

                                            e.preventDefault();
                                            e.stopPropagation();
                                        } else if (isAtBottom) {
                                            self.$results.scrollTop(
                                                self.$results.get(0).scrollHeight - self.$results.height()
                                            );

                                            e.preventDefault();
                                            e.stopPropagation();
                                        }
                                    });
                                }

                                this.$results.on('mouseup', '.select2-results__option[aria-selected]',
                                    function (evt) {
                                        var $this = $(this);

                                        var data = Utils.GetData(this, 'data');

                                        if ($this.attr('aria-selected') === 'true') {
                                            if (self.options.get('multiple')) {
                                                self.trigger('unselect', {
                                                    originalEvent: evt,
                                                    data: data
                                                });
                                            } else {
                                                self.trigger('close', {});
                                            }

                                            return;
                                        }

                                        self.trigger('select', {
                                            originalEvent: evt,
                                            data: data
                                        });
                                    });

                                this.$results.on('mouseenter', '.select2-results__option[aria-selected]',
                                    function (evt) {
                                        var data = Utils.GetData(this, 'data');

                                        self.getHighlightedResults()
                                            .removeClass('select2-results__option--highlighted');

                                        self.trigger('results:focus', {
                                            data: data,
                                            element: $(this)
                                        });
                                    });
                            };

                            Results.prototype.getHighlightedResults = function () {
                                var $highlighted = this.$results
                                    .find('.select2-results__option--highlighted');

                                return $highlighted;
                            };

                            Results.prototype.destroy = function () {
                                this.$results.remove();
                            };

                            Results.prototype.ensureHighlightVisible = function () {
                                var $highlighted = this.getHighlightedResults();

                                if ($highlighted.length === 0) {
                                    return;
                                }

                                var $options = this.$results.find('[aria-selected]');

                                var currentIndex = $options.index($highlighted);

                                var currentOffset = this.$results.offset().top;
                                var nextTop = $highlighted.offset().top;
                                var nextOffset = this.$results.scrollTop() + (nextTop - currentOffset);

                                var offsetDelta = nextTop - currentOffset;
                                nextOffset -= $highlighted.outerHeight(false) * 2;

                                if (currentIndex <= 2) {
                                    this.$results.scrollTop(0);
                                } else if (offsetDelta > this.$results.outerHeight() || offsetDelta < 0) {
                                    this.$results.scrollTop(nextOffset);
                                }
                            };

                            Results.prototype.template = function (result, container) {
                                var template = this.options.get('templateResult');
                                var escapeMarkup = this.options.get('escapeMarkup');

                                var content = template(result, container);

                                if (content == null) {
                                    container.style.display = 'none';
                                } else if (typeof content === 'string') {
                                    container.innerHTML = escapeMarkup(content);
                                } else {
                                    $(container).append(content);
                                }
                            };

                            return Results;
                        });

                        S2.define('select2/keys',[

                        ], function () {
                            var KEYS = {
                                BACKSPACE: 8,
                                TAB: 9,
                                ENTER: 13,
                                SHIFT: 16,
                                CTRL: 17,
                                ALT: 18,
                                ESC: 27,
                                SPACE: 32,
                                PAGE_UP: 33,
                                PAGE_DOWN: 34,
                                END: 35,
                                HOME: 36,
                                LEFT: 37,
                                UP: 38,
                                RIGHT: 39,
                                DOWN: 40,
                                DELETE: 46
                            };

                            return KEYS;
                        });

                        S2.define('select2/selection/base',[
                            'jquery',
                            '../utils',
                            '../keys'
                        ], function ($, Utils, KEYS) {
                            function BaseSelection ($element, options) {
                                this.$element = $element;
                                this.options = options;

                                BaseSelection.__super__.constructor.call(this);
                            }

                            Utils.Extend(BaseSelection, Utils.Observable);

                            BaseSelection.prototype.render = function () {
                                var $selection = $(
                                    '<span class="select2-selection" role="combobox" ' +
                                    ' aria-haspopup="true" aria-expanded="false">' +
                                    '</span>'
                                );

                                this._tabindex = 0;

                                if (Utils.GetData(this.$element[0], 'old-tabindex') != null) {
                                    this._tabindex = Utils.GetData(this.$element[0], 'old-tabindex');
                                } else if (this.$element.attr('tabindex') != null) {
                                    this._tabindex = this.$element.attr('tabindex');
                                }

                                $selection.attr('title', this.$element.attr('title'));
                                $selection.attr('tabindex', this._tabindex);
                                $selection.attr('aria-disabled', 'false');

                                this.$selection = $selection;

                                return $selection;
                            };

                            BaseSelection.prototype.bind = function (container, $container) {
                                var self = this;

                                var resultsId = container.id + '-results';

                                this.container = container;

                                this.$selection.on('focus', function (evt) {
                                    self.trigger('focus', evt);
                                });

                                this.$selection.on('blur', function (evt) {
                                    self._handleBlur(evt);
                                });

                                this.$selection.on('keydown', function (evt) {
                                    self.trigger('keypress', evt);

                                    if (evt.which === KEYS.SPACE) {
                                        evt.preventDefault();
                                    }
                                });

                                container.on('results:focus', function (params) {
                                    self.$selection.attr('aria-activedescendant', params.data._resultId);
                                });

                                container.on('selection:update', function (params) {
                                    self.update(params.data);
                                });

                                container.on('open', function () {
                                    // When the dropdown is open, aria-expanded="true"
                                    self.$selection.attr('aria-expanded', 'true');
                                    self.$selection.attr('aria-owns', resultsId);

                                    self._attachCloseHandler(container);
                                });

                                container.on('close', function () {
                                    // When the dropdown is closed, aria-expanded="false"
                                    self.$selection.attr('aria-expanded', 'false');
                                    self.$selection.removeAttr('aria-activedescendant');
                                    self.$selection.removeAttr('aria-owns');

                                    self.$selection.trigger('focus');

                                    self._detachCloseHandler(container);
                                });

                                container.on('enable', function () {
                                    self.$selection.attr('tabindex', self._tabindex);
                                    self.$selection.attr('aria-disabled', 'false');
                                });

                                container.on('disable', function () {
                                    self.$selection.attr('tabindex', '-1');
                                    self.$selection.attr('aria-disabled', 'true');
                                });
                            };

                            BaseSelection.prototype._handleBlur = function (evt) {
                                var self = this;

                                // This needs to be delayed as the active element is the body when the tab
                                // key is pressed, possibly along with others.
                                window.setTimeout(function () {
                                    // Don't trigger `blur` if the focus is still in the selection
                                    if (
                                        (document.activeElement == self.$selection[0]) ||
                                        ($.contains(self.$selection[0], document.activeElement))
                                    ) {
                                        return;
                                    }

                                    self.trigger('blur', evt);
                                }, 1);
                            };

                            BaseSelection.prototype._attachCloseHandler = function (container) {

                                $(document.body).on('mousedown.select2.' + container.id, function (e) {
                                    var $target = $(e.target);

                                    var $select = $target.closest('.select2');

                                    var $all = $('.select2.select2-container--open');

                                    $all.each(function () {
                                        if (this == $select[0]) {
                                            return;
                                        }

                                        var $element = Utils.GetData(this, 'element');

                                        $element.select2('close');
                                    });
                                });
                            };

                            BaseSelection.prototype._detachCloseHandler = function (container) {
                                $(document.body).off('mousedown.select2.' + container.id);
                            };

                            BaseSelection.prototype.position = function ($selection, $container) {
                                var $selectionContainer = $container.find('.selection');
                                $selectionContainer.append($selection);
                            };

                            BaseSelection.prototype.destroy = function () {
                                this._detachCloseHandler(this.container);
                            };

                            BaseSelection.prototype.update = function (data) {
                                throw new Error('The `update` method must be defined in child classes.');
                            };

                            /**
                             * Helper method to abstract the "enabled" (not "disabled") state of this
                             * object.
                             *
                             * @return {true} if the instance is not disabled.
                             * @return {false} if the instance is disabled.
                             */
                            BaseSelection.prototype.isEnabled = function () {
                                return !this.isDisabled();
                            };

                            /**
                             * Helper method to abstract the "disabled" state of this object.
                             *
                             * @return {true} if the disabled option is true.
                             * @return {false} if the disabled option is false.
                             */
                            BaseSelection.prototype.isDisabled = function () {
                                return this.options.get('disabled');
                            };

                            return BaseSelection;
                        });

                        S2.define('select2/selection/single',[
                            'jquery',
                            './base',
                            '../utils',
                            '../keys'
                        ], function ($, BaseSelection, Utils, KEYS) {
                            function SingleSelection () {
                                SingleSelection.__super__.constructor.apply(this, arguments);
                            }

                            Utils.Extend(SingleSelection, BaseSelection);

                            SingleSelection.prototype.render = function () {
                                var $selection = SingleSelection.__super__.render.call(this);

                                $selection.addClass('select2-selection--single');

                                $selection.html(
                                    '<span class="select2-selection__rendered"></span>' +
                                    '<span class="select2-selection__arrow" role="presentation">' +
                                    '<b role="presentation"></b>' +
                                    '</span>'
                                );

                                return $selection;
                            };

                            SingleSelection.prototype.bind = function (container, $container) {
                                var self = this;

                                SingleSelection.__super__.bind.apply(this, arguments);

                                var id = container.id + '-container';

                                this.$selection.find('.select2-selection__rendered')
                                    .attr('id', id)
                                    .attr('role', 'textbox')
                                    .attr('aria-readonly', 'true');
                                this.$selection.attr('aria-labelledby', id);

                                this.$selection.on('mousedown', function (evt) {
                                    // Only respond to left clicks
                                    if (evt.which !== 1) {
                                        return;
                                    }

                                    self.trigger('toggle', {
                                        originalEvent: evt
                                    });
                                });

                                this.$selection.on('focus', function (evt) {
                                    // User focuses on the container
                                });

                                this.$selection.on('blur', function (evt) {
                                    // User exits the container
                                });

                                container.on('focus', function (evt) {
                                    if (!container.isOpen()) {
                                        self.$selection.trigger('focus');
                                    }
                                });
                            };

                            SingleSelection.prototype.clear = function () {
                                var $rendered = this.$selection.find('.select2-selection__rendered');
                                $rendered.empty();
                                $rendered.removeAttr('title'); // clear tooltip on empty
                            };

                            SingleSelection.prototype.display = function (data, container) {
                                var template = this.options.get('templateSelection');
                                var escapeMarkup = this.options.get('escapeMarkup');

                                return escapeMarkup(template(data, container));
                            };

                            SingleSelection.prototype.selectionContainer = function () {
                                return $('<span></span>');
                            };

                            SingleSelection.prototype.update = function (data) {
                                if (data.length === 0) {
                                    this.clear();
                                    return;
                                }

                                var selection = data[0];

                                var $rendered = this.$selection.find('.select2-selection__rendered');
                                var formatted = this.display(selection, $rendered);

                                $rendered.empty().append(formatted);

                                var title = selection.title || selection.text;

                                if (title) {
                                    $rendered.attr('title', title);
                                } else {
                                    $rendered.removeAttr('title');
                                }
                            };

                            return SingleSelection;
                        });

                        S2.define('select2/selection/multiple',[
                            'jquery',
                            './base',
                            '../utils'
                        ], function ($, BaseSelection, Utils) {
                            function MultipleSelection ($element, options) {
                                MultipleSelection.__super__.constructor.apply(this, arguments);
                            }

                            Utils.Extend(MultipleSelection, BaseSelection);

                            MultipleSelection.prototype.render = function () {
                                var $selection = MultipleSelection.__super__.render.call(this);

                                $selection.addClass('select2-selection--multiple');

                                $selection.html(
                                    '<ul class="select2-selection__rendered"></ul>'
                                );

                                return $selection;
                            };

                            MultipleSelection.prototype.bind = function (container, $container) {
                                var self = this;

                                MultipleSelection.__super__.bind.apply(this, arguments);

                                this.$selection.on('click', function (evt) {
                                    self.trigger('toggle', {
                                        originalEvent: evt
                                    });
                                });

                                this.$selection.on(
                                    'click',
                                    '.select2-selection__choice__remove',
                                    function (evt) {
                                        // Ignore the event if it is disabled
                                        if (self.isDisabled()) {
                                            return;
                                        }

                                        var $remove = $(this);
                                        var $selection = $remove.parent();

                                        var data = Utils.GetData($selection[0], 'data');

                                        self.trigger('unselect', {
                                            originalEvent: evt,
                                            data: data
                                        });
                                    }
                                );
                            };

                            MultipleSelection.prototype.clear = function () {
                                var $rendered = this.$selection.find('.select2-selection__rendered');
                                $rendered.empty();
                                $rendered.removeAttr('title');
                            };

                            MultipleSelection.prototype.display = function (data, container) {
                                var template = this.options.get('templateSelection');
                                var escapeMarkup = this.options.get('escapeMarkup');

                                return escapeMarkup(template(data, container));
                            };

                            MultipleSelection.prototype.selectionContainer = function () {
                                var $container = $(
                                    '<li class="select2-selection__choice">' +
                                    '<span class="select2-selection__choice__remove" role="presentation">' +
                                    '&times;' +
                                    '</span>' +
                                    '</li>'
                                );

                                return $container;
                            };

                            MultipleSelection.prototype.update = function (data) {
                                this.clear();

                                if (data.length === 0) {
                                    return;
                                }

                                var $selections = [];

                                for (var d = 0; d < data.length; d++) {
                                    var selection = data[d];

                                    var $selection = this.selectionContainer();
                                    var formatted = this.display(selection, $selection);

                                    $selection.append(formatted);

                                    var title = selection.title || selection.text;

                                    if (title) {
                                        $selection.attr('title', title);
                                    }

                                    Utils.StoreData($selection[0], 'data', selection);

                                    $selections.push($selection);
                                }

                                var $rendered = this.$selection.find('.select2-selection__rendered');

                                Utils.appendMany($rendered, $selections);
                            };

                            return MultipleSelection;
                        });

                        S2.define('select2/selection/placeholder',[
                            '../utils'
                        ], function (Utils) {
                            function Placeholder (decorated, $element, options) {
                                this.placeholder = this.normalizePlaceholder(options.get('placeholder'));

                                decorated.call(this, $element, options);
                            }

                            Placeholder.prototype.normalizePlaceholder = function (_, placeholder) {
                                if (typeof placeholder === 'string') {
                                    placeholder = {
                                        id: '',
                                        text: placeholder
                                    };
                                }

                                return placeholder;
                            };

                            Placeholder.prototype.createPlaceholder = function (decorated, placeholder) {
                                var $placeholder = this.selectionContainer();

                                $placeholder.html(this.display(placeholder));
                                $placeholder.addClass('select2-selection__placeholder')
                                    .removeClass('select2-selection__choice');

                                return $placeholder;
                            };

                            Placeholder.prototype.update = function (decorated, data) {
                                var singlePlaceholder = (
                                    data.length == 1 && data[0].id != this.placeholder.id
                                );
                                var multipleSelections = data.length > 1;

                                if (multipleSelections || singlePlaceholder) {
                                    return decorated.call(this, data);
                                }

                                this.clear();

                                var $placeholder = this.createPlaceholder(this.placeholder);

                                this.$selection.find('.select2-selection__rendered').append($placeholder);
                            };

                            return Placeholder;
                        });

                        S2.define('select2/selection/allowClear',[
                            'jquery',
                            '../keys',
                            '../utils'
                        ], function ($, KEYS, Utils) {
                            function AllowClear () { }

                            AllowClear.prototype.bind = function (decorated, container, $container) {
                                var self = this;

                                decorated.call(this, container, $container);

                                if (this.placeholder == null) {
                                    if (this.options.get('debug') && window.console && console.error) {
                                        console.error(
                                            'Select2: The `allowClear` option should be used in combination ' +
                                            'with the `placeholder` option.'
                                        );
                                    }
                                }

                                this.$selection.on('mousedown', '.select2-selection__clear',
                                    function (evt) {
                                        self._handleClear(evt);
                                    });

                                container.on('keypress', function (evt) {
                                    self._handleKeyboardClear(evt, container);
                                });
                            };

                            AllowClear.prototype._handleClear = function (_, evt) {
                                // Ignore the event if it is disabled
                                if (this.isDisabled()) {
                                    return;
                                }

                                var $clear = this.$selection.find('.select2-selection__clear');

                                // Ignore the event if nothing has been selected
                                if ($clear.length === 0) {
                                    return;
                                }

                                evt.stopPropagation();

                                var data = Utils.GetData($clear[0], 'data');

                                var previousVal = this.$element.val();
                                this.$element.val(this.placeholder.id);

                                var unselectData = {
                                    data: data
                                };
                                this.trigger('clear', unselectData);
                                if (unselectData.prevented) {
                                    this.$element.val(previousVal);
                                    return;
                                }

                                for (var d = 0; d < data.length; d++) {
                                    unselectData = {
                                        data: data[d]
                                    };

                                    // Trigger the `unselect` event, so people can prevent it from being
                                    // cleared.
                                    this.trigger('unselect', unselectData);

                                    // If the event was prevented, don't clear it out.
                                    if (unselectData.prevented) {
                                        this.$element.val(previousVal);
                                        return;
                                    }
                                }

                                this.$element.trigger('input').trigger('change');

                                this.trigger('toggle', {});
                            };

                            AllowClear.prototype._handleKeyboardClear = function (_, evt, container) {
                                if (container.isOpen()) {
                                    return;
                                }

                                if (evt.which == KEYS.DELETE || evt.which == KEYS.BACKSPACE) {
                                    this._handleClear(evt);
                                }
                            };

                            AllowClear.prototype.update = function (decorated, data) {
                                decorated.call(this, data);

                                if (this.$selection.find('.select2-selection__placeholder').length > 0 ||
                                    data.length === 0) {
                                    return;
                                }

                                var removeAll = this.options.get('translations').get('removeAllItems');

                                var $remove = $(
                                    '<span class="select2-selection__clear" title="' + removeAll() +'">' +
                                    '&times;' +
                                    '</span>'
                                );
                                Utils.StoreData($remove[0], 'data', data);

                                this.$selection.find('.select2-selection__rendered').prepend($remove);
                            };

                            return AllowClear;
                        });

                        S2.define('select2/selection/search',[
                            'jquery',
                            '../utils',
                            '../keys'
                        ], function ($, Utils, KEYS) {
                            function Search (decorated, $element, options) {
                                decorated.call(this, $element, options);
                            }

                            Search.prototype.render = function (decorated) {
                                var $search = $(
                                    '<li class="select2-search select2-search--inline">' +
                                    '<input class="select2-search__field" type="search" tabindex="-1"' +
                                    ' autocomplete="off" autocorrect="off" autocapitalize="none"' +
                                    ' spellcheck="false" role="searchbox" aria-autocomplete="list" />' +
                                    '</li>'
                                );

                                this.$searchContainer = $search;
                                this.$search = $search.find('input');

                                var $rendered = decorated.call(this);

                                this._transferTabIndex();

                                return $rendered;
                            };

                            Search.prototype.bind = function (decorated, container, $container) {
                                var self = this;

                                var resultsId = container.id + '-results';

                                decorated.call(this, container, $container);

                                container.on('open', function () {
                                    self.$search.attr('aria-controls', resultsId);
                                    self.$search.trigger('focus');
                                });

                                container.on('close', function () {
                                    self.$search.val('');
                                    self.$search.removeAttr('aria-controls');
                                    self.$search.removeAttr('aria-activedescendant');
                                    self.$search.trigger('focus');
                                });

                                container.on('enable', function () {
                                    self.$search.prop('disabled', false);

                                    self._transferTabIndex();
                                });

                                container.on('disable', function () {
                                    self.$search.prop('disabled', true);
                                });

                                container.on('focus', function (evt) {
                                    self.$search.trigger('focus');
                                });

                                container.on('results:focus', function (params) {
                                    if (params.data._resultId) {
                                        self.$search.attr('aria-activedescendant', params.data._resultId);
                                    } else {
                                        self.$search.removeAttr('aria-activedescendant');
                                    }
                                });

                                this.$selection.on('focusin', '.select2-search--inline', function (evt) {
                                    self.trigger('focus', evt);
                                });

                                this.$selection.on('focusout', '.select2-search--inline', function (evt) {
                                    self._handleBlur(evt);
                                });

                                this.$selection.on('keydown', '.select2-search--inline', function (evt) {
                                    evt.stopPropagation();

                                    self.trigger('keypress', evt);

                                    self._keyUpPrevented = evt.isDefaultPrevented();

                                    var key = evt.which;

                                    if (key === KEYS.BACKSPACE && self.$search.val() === '') {
                                        var $previousChoice = self.$searchContainer
                                            .prev('.select2-selection__choice');

                                        if ($previousChoice.length > 0) {
                                            var item = Utils.GetData($previousChoice[0], 'data');

                                            self.searchRemoveChoice(item);

                                            evt.preventDefault();
                                        }
                                    }
                                });

                                this.$selection.on('click', '.select2-search--inline', function (evt) {
                                    if (self.$search.val()) {
                                        evt.stopPropagation();
                                    }
                                });

                                // Try to detect the IE version should the `documentMode` property that
                                // is stored on the document. This is only implemented in IE and is
                                // slightly cleaner than doing a user agent check.
                                // This property is not available in Edge, but Edge also doesn't have
                                // this bug.
                                var msie = document.documentMode;
                                var disableInputEvents = msie && msie <= 11;

                                // Workaround for browsers which do not support the `input` event
                                // This will prevent double-triggering of events for browsers which support
                                // both the `keyup` and `input` events.
                                this.$selection.on(
                                    'input.searchcheck',
                                    '.select2-search--inline',
                                    function (evt) {
                                        // IE will trigger the `input` event when a placeholder is used on a
                                        // search box. To get around this issue, we are forced to ignore all
                                        // `input` events in IE and keep using `keyup`.
                                        if (disableInputEvents) {
                                            self.$selection.off('input.search input.searchcheck');
                                            return;
                                        }

                                        // Unbind the duplicated `keyup` event
                                        self.$selection.off('keyup.search');
                                    }
                                );

                                this.$selection.on(
                                    'keyup.search input.search',
                                    '.select2-search--inline',
                                    function (evt) {
                                        // IE will trigger the `input` event when a placeholder is used on a
                                        // search box. To get around this issue, we are forced to ignore all
                                        // `input` events in IE and keep using `keyup`.
                                        if (disableInputEvents && evt.type === 'input') {
                                            self.$selection.off('input.search input.searchcheck');
                                            return;
                                        }

                                        var key = evt.which;

                                        // We can freely ignore events from modifier keys
                                        if (key == KEYS.SHIFT || key == KEYS.CTRL || key == KEYS.ALT) {
                                            return;
                                        }

                                        // Tabbing will be handled during the `keydown` phase
                                        if (key == KEYS.TAB) {
                                            return;
                                        }

                                        self.handleSearch(evt);
                                    }
                                );
                            };

                            /**
                             * This method will transfer the tabindex attribute from the rendered
                             * selection to the search box. This allows for the search box to be used as
                             * the primary focus instead of the selection container.
                             *
                             * @private
                             */
                            Search.prototype._transferTabIndex = function (decorated) {
                                this.$search.attr('tabindex', this.$selection.attr('tabindex'));
                                this.$selection.attr('tabindex', '-1');
                            };

                            Search.prototype.createPlaceholder = function (decorated, placeholder) {
                                this.$search.attr('placeholder', placeholder.text);
                            };

                            Search.prototype.update = function (decorated, data) {
                                var searchHadFocus = this.$search[0] == document.activeElement;

                                this.$search.attr('placeholder', '');

                                decorated.call(this, data);

                                this.$selection.find('.select2-selection__rendered')
                                    .append(this.$searchContainer);

                                this.resizeSearch();
                                if (searchHadFocus) {
                                    this.$search.trigger('focus');
                                }
                            };

                            Search.prototype.handleSearch = function () {
                                this.resizeSearch();

                                if (!this._keyUpPrevented) {
                                    var input = this.$search.val();

                                    this.trigger('query', {
                                        term: input
                                    });
                                }

                                this._keyUpPrevented = false;
                            };

                            Search.prototype.searchRemoveChoice = function (decorated, item) {
                                this.trigger('unselect', {
                                    data: item
                                });

                                this.$search.val(item.text);
                                this.handleSearch();
                            };

                            Search.prototype.resizeSearch = function () {
                                this.$search.css('width', '25px');

                                var width = '';

                                if (this.$search.attr('placeholder') !== '') {
                                    width = this.$selection.find('.select2-selection__rendered').width();
                                } else {
                                    var minimumWidth = this.$search.val().length + 1;

                                    width = (minimumWidth * 0.75) + 'em';
                                }

                                this.$search.css('width', width);
                            };

                            return Search;
                        });

                        S2.define('select2/selection/eventRelay',[
                            'jquery'
                        ], function ($) {
                            function EventRelay () { }

                            EventRelay.prototype.bind = function (decorated, container, $container) {
                                var self = this;
                                var relayEvents = [
                                    'open', 'opening',
                                    'close', 'closing',
                                    'select', 'selecting',
                                    'unselect', 'unselecting',
                                    'clear', 'clearing'
                                ];

                                var preventableEvents = [
                                    'opening', 'closing', 'selecting', 'unselecting', 'clearing'
                                ];

                                decorated.call(this, container, $container);

                                container.on('*', function (name, params) {
                                    // Ignore events that should not be relayed
                                    if ($.inArray(name, relayEvents) === -1) {
                                        return;
                                    }

                                    // The parameters should always be an object
                                    params = params || {};

                                    // Generate the jQuery event for the Select2 event
                                    var evt = $.Event('select2:' + name, {
                                        params: params
                                    });

                                    self.$element.trigger(evt);

                                    // Only handle preventable events if it was one
                                    if ($.inArray(name, preventableEvents) === -1) {
                                        return;
                                    }

                                    params.prevented = evt.isDefaultPrevented();
                                });
                            };

                            return EventRelay;
                        });

                        S2.define('select2/translation',[
                            'jquery',
                            'require'
                        ], function ($, require) {
                            function Translation (dict) {
                                this.dict = dict || {};
                            }

                            Translation.prototype.all = function () {
                                return this.dict;
                            };

                            Translation.prototype.get = function (key) {
                                return this.dict[key];
                            };

                            Translation.prototype.extend = function (translation) {
                                this.dict = $.extend({}, translation.all(), this.dict);
                            };

                            // Static functions

                            Translation._cache = {};

                            Translation.loadPath = function (path) {
                                if (!(path in Translation._cache)) {
                                    var translations = require(path);

                                    Translation._cache[path] = translations;
                                }

                                return new Translation(Translation._cache[path]);
                            };

                            return Translation;
                        });

                        S2.define('select2/diacritics',[

                        ], function () {
                            var diacritics = {
                                '\u24B6': 'A',
                                '\uFF21': 'A',
                                '\u00C0': 'A',
                                '\u00C1': 'A',
                                '\u00C2': 'A',
                                '\u1EA6': 'A',
                                '\u1EA4': 'A',
                                '\u1EAA': 'A',
                                '\u1EA8': 'A',
                                '\u00C3': 'A',
                                '\u0100': 'A',
                                '\u0102': 'A',
                                '\u1EB0': 'A',
                                '\u1EAE': 'A',
                                '\u1EB4': 'A',
                                '\u1EB2': 'A',
                                '\u0226': 'A',
                                '\u01E0': 'A',
                                '\u00C4': 'A',
                                '\u01DE': 'A',
                                '\u1EA2': 'A',
                                '\u00C5': 'A',
                                '\u01FA': 'A',
                                '\u01CD': 'A',
                                '\u0200': 'A',
                                '\u0202': 'A',
                                '\u1EA0': 'A',
                                '\u1EAC': 'A',
                                '\u1EB6': 'A',
                                '\u1E00': 'A',
                                '\u0104': 'A',
                                '\u023A': 'A',
                                '\u2C6F': 'A',
                                '\uA732': 'AA',
                                '\u00C6': 'AE',
                                '\u01FC': 'AE',
                                '\u01E2': 'AE',
                                '\uA734': 'AO',
                                '\uA736': 'AU',
                                '\uA738': 'AV',
                                '\uA73A': 'AV',
                                '\uA73C': 'AY',
                                '\u24B7': 'B',
                                '\uFF22': 'B',
                                '\u1E02': 'B',
                                '\u1E04': 'B',
                                '\u1E06': 'B',
                                '\u0243': 'B',
                                '\u0182': 'B',
                                '\u0181': 'B',
                                '\u24B8': 'C',
                                '\uFF23': 'C',
                                '\u0106': 'C',
                                '\u0108': 'C',
                                '\u010A': 'C',
                                '\u010C': 'C',
                                '\u00C7': 'C',
                                '\u1E08': 'C',
                                '\u0187': 'C',
                                '\u023B': 'C',
                                '\uA73E': 'C',
                                '\u24B9': 'D',
                                '\uFF24': 'D',
                                '\u1E0A': 'D',
                                '\u010E': 'D',
                                '\u1E0C': 'D',
                                '\u1E10': 'D',
                                '\u1E12': 'D',
                                '\u1E0E': 'D',
                                '\u0110': 'D',
                                '\u018B': 'D',
                                '\u018A': 'D',
                                '\u0189': 'D',
                                '\uA779': 'D',
                                '\u01F1': 'DZ',
                                '\u01C4': 'DZ',
                                '\u01F2': 'Dz',
                                '\u01C5': 'Dz',
                                '\u24BA': 'E',
                                '\uFF25': 'E',
                                '\u00C8': 'E',
                                '\u00C9': 'E',
                                '\u00CA': 'E',
                                '\u1EC0': 'E',
                                '\u1EBE': 'E',
                                '\u1EC4': 'E',
                                '\u1EC2': 'E',
                                '\u1EBC': 'E',
                                '\u0112': 'E',
                                '\u1E14': 'E',
                                '\u1E16': 'E',
                                '\u0114': 'E',
                                '\u0116': 'E',
                                '\u00CB': 'E',
                                '\u1EBA': 'E',
                                '\u011A': 'E',
                                '\u0204': 'E',
                                '\u0206': 'E',
                                '\u1EB8': 'E',
                                '\u1EC6': 'E',
                                '\u0228': 'E',
                                '\u1E1C': 'E',
                                '\u0118': 'E',
                                '\u1E18': 'E',
                                '\u1E1A': 'E',
                                '\u0190': 'E',
                                '\u018E': 'E',
                                '\u24BB': 'F',
                                '\uFF26': 'F',
                                '\u1E1E': 'F',
                                '\u0191': 'F',
                                '\uA77B': 'F',
                                '\u24BC': 'G',
                                '\uFF27': 'G',
                                '\u01F4': 'G',
                                '\u011C': 'G',
                                '\u1E20': 'G',
                                '\u011E': 'G',
                                '\u0120': 'G',
                                '\u01E6': 'G',
                                '\u0122': 'G',
                                '\u01E4': 'G',
                                '\u0193': 'G',
                                '\uA7A0': 'G',
                                '\uA77D': 'G',
                                '\uA77E': 'G',
                                '\u24BD': 'H',
                                '\uFF28': 'H',
                                '\u0124': 'H',
                                '\u1E22': 'H',
                                '\u1E26': 'H',
                                '\u021E': 'H',
                                '\u1E24': 'H',
                                '\u1E28': 'H',
                                '\u1E2A': 'H',
                                '\u0126': 'H',
                                '\u2C67': 'H',
                                '\u2C75': 'H',
                                '\uA78D': 'H',
                                '\u24BE': 'I',
                                '\uFF29': 'I',
                                '\u00CC': 'I',
                                '\u00CD': 'I',
                                '\u00CE': 'I',
                                '\u0128': 'I',
                                '\u012A': 'I',
                                '\u012C': 'I',
                                '\u0130': 'I',
                                '\u00CF': 'I',
                                '\u1E2E': 'I',
                                '\u1EC8': 'I',
                                '\u01CF': 'I',
                                '\u0208': 'I',
                                '\u020A': 'I',
                                '\u1ECA': 'I',
                                '\u012E': 'I',
                                '\u1E2C': 'I',
                                '\u0197': 'I',
                                '\u24BF': 'J',
                                '\uFF2A': 'J',
                                '\u0134': 'J',
                                '\u0248': 'J',
                                '\u24C0': 'K',
                                '\uFF2B': 'K',
                                '\u1E30': 'K',
                                '\u01E8': 'K',
                                '\u1E32': 'K',
                                '\u0136': 'K',
                                '\u1E34': 'K',
                                '\u0198': 'K',
                                '\u2C69': 'K',
                                '\uA740': 'K',
                                '\uA742': 'K',
                                '\uA744': 'K',
                                '\uA7A2': 'K',
                                '\u24C1': 'L',
                                '\uFF2C': 'L',
                                '\u013F': 'L',
                                '\u0139': 'L',
                                '\u013D': 'L',
                                '\u1E36': 'L',
                                '\u1E38': 'L',
                                '\u013B': 'L',
                                '\u1E3C': 'L',
                                '\u1E3A': 'L',
                                '\u0141': 'L',
                                '\u023D': 'L',
                                '\u2C62': 'L',
                                '\u2C60': 'L',
                                '\uA748': 'L',
                                '\uA746': 'L',
                                '\uA780': 'L',
                                '\u01C7': 'LJ',
                                '\u01C8': 'Lj',
                                '\u24C2': 'M',
                                '\uFF2D': 'M',
                                '\u1E3E': 'M',
                                '\u1E40': 'M',
                                '\u1E42': 'M',
                                '\u2C6E': 'M',
                                '\u019C': 'M',
                                '\u24C3': 'N',
                                '\uFF2E': 'N',
                                '\u01F8': 'N',
                                '\u0143': 'N',
                                '\u00D1': 'N',
                                '\u1E44': 'N',
                                '\u0147': 'N',
                                '\u1E46': 'N',
                                '\u0145': 'N',
                                '\u1E4A': 'N',
                                '\u1E48': 'N',
                                '\u0220': 'N',
                                '\u019D': 'N',
                                '\uA790': 'N',
                                '\uA7A4': 'N',
                                '\u01CA': 'NJ',
                                '\u01CB': 'Nj',
                                '\u24C4': 'O',
                                '\uFF2F': 'O',
                                '\u00D2': 'O',
                                '\u00D3': 'O',
                                '\u00D4': 'O',
                                '\u1ED2': 'O',
                                '\u1ED0': 'O',
                                '\u1ED6': 'O',
                                '\u1ED4': 'O',
                                '\u00D5': 'O',
                                '\u1E4C': 'O',
                                '\u022C': 'O',
                                '\u1E4E': 'O',
                                '\u014C': 'O',
                                '\u1E50': 'O',
                                '\u1E52': 'O',
                                '\u014E': 'O',
                                '\u022E': 'O',
                                '\u0230': 'O',
                                '\u00D6': 'O',
                                '\u022A': 'O',
                                '\u1ECE': 'O',
                                '\u0150': 'O',
                                '\u01D1': 'O',
                                '\u020C': 'O',
                                '\u020E': 'O',
                                '\u01A0': 'O',
                                '\u1EDC': 'O',
                                '\u1EDA': 'O',
                                '\u1EE0': 'O',
                                '\u1EDE': 'O',
                                '\u1EE2': 'O',
                                '\u1ECC': 'O',
                                '\u1ED8': 'O',
                                '\u01EA': 'O',
                                '\u01EC': 'O',
                                '\u00D8': 'O',
                                '\u01FE': 'O',
                                '\u0186': 'O',
                                '\u019F': 'O',
                                '\uA74A': 'O',
                                '\uA74C': 'O',
                                '\u0152': 'OE',
                                '\u01A2': 'OI',
                                '\uA74E': 'OO',
                                '\u0222': 'OU',
                                '\u24C5': 'P',
                                '\uFF30': 'P',
                                '\u1E54': 'P',
                                '\u1E56': 'P',
                                '\u01A4': 'P',
                                '\u2C63': 'P',
                                '\uA750': 'P',
                                '\uA752': 'P',
                                '\uA754': 'P',
                                '\u24C6': 'Q',
                                '\uFF31': 'Q',
                                '\uA756': 'Q',
                                '\uA758': 'Q',
                                '\u024A': 'Q',
                                '\u24C7': 'R',
                                '\uFF32': 'R',
                                '\u0154': 'R',
                                '\u1E58': 'R',
                                '\u0158': 'R',
                                '\u0210': 'R',
                                '\u0212': 'R',
                                '\u1E5A': 'R',
                                '\u1E5C': 'R',
                                '\u0156': 'R',
                                '\u1E5E': 'R',
                                '\u024C': 'R',
                                '\u2C64': 'R',
                                '\uA75A': 'R',
                                '\uA7A6': 'R',
                                '\uA782': 'R',
                                '\u24C8': 'S',
                                '\uFF33': 'S',
                                '\u1E9E': 'S',
                                '\u015A': 'S',
                                '\u1E64': 'S',
                                '\u015C': 'S',
                                '\u1E60': 'S',
                                '\u0160': 'S',
                                '\u1E66': 'S',
                                '\u1E62': 'S',
                                '\u1E68': 'S',
                                '\u0218': 'S',
                                '\u015E': 'S',
                                '\u2C7E': 'S',
                                '\uA7A8': 'S',
                                '\uA784': 'S',
                                '\u24C9': 'T',
                                '\uFF34': 'T',
                                '\u1E6A': 'T',
                                '\u0164': 'T',
                                '\u1E6C': 'T',
                                '\u021A': 'T',
                                '\u0162': 'T',
                                '\u1E70': 'T',
                                '\u1E6E': 'T',
                                '\u0166': 'T',
                                '\u01AC': 'T',
                                '\u01AE': 'T',
                                '\u023E': 'T',
                                '\uA786': 'T',
                                '\uA728': 'TZ',
                                '\u24CA': 'U',
                                '\uFF35': 'U',
                                '\u00D9': 'U',
                                '\u00DA': 'U',
                                '\u00DB': 'U',
                                '\u0168': 'U',
                                '\u1E78': 'U',
                                '\u016A': 'U',
                                '\u1E7A': 'U',
                                '\u016C': 'U',
                                '\u00DC': 'U',
                                '\u01DB': 'U',
                                '\u01D7': 'U',
                                '\u01D5': 'U',
                                '\u01D9': 'U',
                                '\u1EE6': 'U',
                                '\u016E': 'U',
                                '\u0170': 'U',
                                '\u01D3': 'U',
                                '\u0214': 'U',
                                '\u0216': 'U',
                                '\u01AF': 'U',
                                '\u1EEA': 'U',
                                '\u1EE8': 'U',
                                '\u1EEE': 'U',
                                '\u1EEC': 'U',
                                '\u1EF0': 'U',
                                '\u1EE4': 'U',
                                '\u1E72': 'U',
                                '\u0172': 'U',
                                '\u1E76': 'U',
                                '\u1E74': 'U',
                                '\u0244': 'U',
                                '\u24CB': 'V',
                                '\uFF36': 'V',
                                '\u1E7C': 'V',
                                '\u1E7E': 'V',
                                '\u01B2': 'V',
                                '\uA75E': 'V',
                                '\u0245': 'V',
                                '\uA760': 'VY',
                                '\u24CC': 'W',
                                '\uFF37': 'W',
                                '\u1E80': 'W',
                                '\u1E82': 'W',
                                '\u0174': 'W',
                                '\u1E86': 'W',
                                '\u1E84': 'W',
                                '\u1E88': 'W',
                                '\u2C72': 'W',
                                '\u24CD': 'X',
                                '\uFF38': 'X',
                                '\u1E8A': 'X',
                                '\u1E8C': 'X',
                                '\u24CE': 'Y',
                                '\uFF39': 'Y',
                                '\u1EF2': 'Y',
                                '\u00DD': 'Y',
                                '\u0176': 'Y',
                                '\u1EF8': 'Y',
                                '\u0232': 'Y',
                                '\u1E8E': 'Y',
                                '\u0178': 'Y',
                                '\u1EF6': 'Y',
                                '\u1EF4': 'Y',
                                '\u01B3': 'Y',
                                '\u024E': 'Y',
                                '\u1EFE': 'Y',
                                '\u24CF': 'Z',
                                '\uFF3A': 'Z',
                                '\u0179': 'Z',
                                '\u1E90': 'Z',
                                '\u017B': 'Z',
                                '\u017D': 'Z',
                                '\u1E92': 'Z',
                                '\u1E94': 'Z',
                                '\u01B5': 'Z',
                                '\u0224': 'Z',
                                '\u2C7F': 'Z',
                                '\u2C6B': 'Z',
                                '\uA762': 'Z',
                                '\u24D0': 'a',
                                '\uFF41': 'a',
                                '\u1E9A': 'a',
                                '\u00E0': 'a',
                                '\u00E1': 'a',
                                '\u00E2': 'a',
                                '\u1EA7': 'a',
                                '\u1EA5': 'a',
                                '\u1EAB': 'a',
                                '\u1EA9': 'a',
                                '\u00E3': 'a',
                                '\u0101': 'a',
                                '\u0103': 'a',
                                '\u1EB1': 'a',
                                '\u1EAF': 'a',
                                '\u1EB5': 'a',
                                '\u1EB3': 'a',
                                '\u0227': 'a',
                                '\u01E1': 'a',
                                '\u00E4': 'a',
                                '\u01DF': 'a',
                                '\u1EA3': 'a',
                                '\u00E5': 'a',
                                '\u01FB': 'a',
                                '\u01CE': 'a',
                                '\u0201': 'a',
                                '\u0203': 'a',
                                '\u1EA1': 'a',
                                '\u1EAD': 'a',
                                '\u1EB7': 'a',
                                '\u1E01': 'a',
                                '\u0105': 'a',
                                '\u2C65': 'a',
                                '\u0250': 'a',
                                '\uA733': 'aa',
                                '\u00E6': 'ae',
                                '\u01FD': 'ae',
                                '\u01E3': 'ae',
                                '\uA735': 'ao',
                                '\uA737': 'au',
                                '\uA739': 'av',
                                '\uA73B': 'av',
                                '\uA73D': 'ay',
                                '\u24D1': 'b',
                                '\uFF42': 'b',
                                '\u1E03': 'b',
                                '\u1E05': 'b',
                                '\u1E07': 'b',
                                '\u0180': 'b',
                                '\u0183': 'b',
                                '\u0253': 'b',
                                '\u24D2': 'c',
                                '\uFF43': 'c',
                                '\u0107': 'c',
                                '\u0109': 'c',
                                '\u010B': 'c',
                                '\u010D': 'c',
                                '\u00E7': 'c',
                                '\u1E09': 'c',
                                '\u0188': 'c',
                                '\u023C': 'c',
                                '\uA73F': 'c',
                                '\u2184': 'c',
                                '\u24D3': 'd',
                                '\uFF44': 'd',
                                '\u1E0B': 'd',
                                '\u010F': 'd',
                                '\u1E0D': 'd',
                                '\u1E11': 'd',
                                '\u1E13': 'd',
                                '\u1E0F': 'd',
                                '\u0111': 'd',
                                '\u018C': 'd',
                                '\u0256': 'd',
                                '\u0257': 'd',
                                '\uA77A': 'd',
                                '\u01F3': 'dz',
                                '\u01C6': 'dz',
                                '\u24D4': 'e',
                                '\uFF45': 'e',
                                '\u00E8': 'e',
                                '\u00E9': 'e',
                                '\u00EA': 'e',
                                '\u1EC1': 'e',
                                '\u1EBF': 'e',
                                '\u1EC5': 'e',
                                '\u1EC3': 'e',
                                '\u1EBD': 'e',
                                '\u0113': 'e',
                                '\u1E15': 'e',
                                '\u1E17': 'e',
                                '\u0115': 'e',
                                '\u0117': 'e',
                                '\u00EB': 'e',
                                '\u1EBB': 'e',
                                '\u011B': 'e',
                                '\u0205': 'e',
                                '\u0207': 'e',
                                '\u1EB9': 'e',
                                '\u1EC7': 'e',
                                '\u0229': 'e',
                                '\u1E1D': 'e',
                                '\u0119': 'e',
                                '\u1E19': 'e',
                                '\u1E1B': 'e',
                                '\u0247': 'e',
                                '\u025B': 'e',
                                '\u01DD': 'e',
                                '\u24D5': 'f',
                                '\uFF46': 'f',
                                '\u1E1F': 'f',
                                '\u0192': 'f',
                                '\uA77C': 'f',
                                '\u24D6': 'g',
                                '\uFF47': 'g',
                                '\u01F5': 'g',
                                '\u011D': 'g',
                                '\u1E21': 'g',
                                '\u011F': 'g',
                                '\u0121': 'g',
                                '\u01E7': 'g',
                                '\u0123': 'g',
                                '\u01E5': 'g',
                                '\u0260': 'g',
                                '\uA7A1': 'g',
                                '\u1D79': 'g',
                                '\uA77F': 'g',
                                '\u24D7': 'h',
                                '\uFF48': 'h',
                                '\u0125': 'h',
                                '\u1E23': 'h',
                                '\u1E27': 'h',
                                '\u021F': 'h',
                                '\u1E25': 'h',
                                '\u1E29': 'h',
                                '\u1E2B': 'h',
                                '\u1E96': 'h',
                                '\u0127': 'h',
                                '\u2C68': 'h',
                                '\u2C76': 'h',
                                '\u0265': 'h',
                                '\u0195': 'hv',
                                '\u24D8': 'i',
                                '\uFF49': 'i',
                                '\u00EC': 'i',
                                '\u00ED': 'i',
                                '\u00EE': 'i',
                                '\u0129': 'i',
                                '\u012B': 'i',
                                '\u012D': 'i',
                                '\u00EF': 'i',
                                '\u1E2F': 'i',
                                '\u1EC9': 'i',
                                '\u01D0': 'i',
                                '\u0209': 'i',
                                '\u020B': 'i',
                                '\u1ECB': 'i',
                                '\u012F': 'i',
                                '\u1E2D': 'i',
                                '\u0268': 'i',
                                '\u0131': 'i',
                                '\u24D9': 'j',
                                '\uFF4A': 'j',
                                '\u0135': 'j',
                                '\u01F0': 'j',
                                '\u0249': 'j',
                                '\u24DA': 'k',
                                '\uFF4B': 'k',
                                '\u1E31': 'k',
                                '\u01E9': 'k',
                                '\u1E33': 'k',
                                '\u0137': 'k',
                                '\u1E35': 'k',
                                '\u0199': 'k',
                                '\u2C6A': 'k',
                                '\uA741': 'k',
                                '\uA743': 'k',
                                '\uA745': 'k',
                                '\uA7A3': 'k',
                                '\u24DB': 'l',
                                '\uFF4C': 'l',
                                '\u0140': 'l',
                                '\u013A': 'l',
                                '\u013E': 'l',
                                '\u1E37': 'l',
                                '\u1E39': 'l',
                                '\u013C': 'l',
                                '\u1E3D': 'l',
                                '\u1E3B': 'l',
                                '\u017F': 'l',
                                '\u0142': 'l',
                                '\u019A': 'l',
                                '\u026B': 'l',
                                '\u2C61': 'l',
                                '\uA749': 'l',
                                '\uA781': 'l',
                                '\uA747': 'l',
                                '\u01C9': 'lj',
                                '\u24DC': 'm',
                                '\uFF4D': 'm',
                                '\u1E3F': 'm',
                                '\u1E41': 'm',
                                '\u1E43': 'm',
                                '\u0271': 'm',
                                '\u026F': 'm',
                                '\u24DD': 'n',
                                '\uFF4E': 'n',
                                '\u01F9': 'n',
                                '\u0144': 'n',
                                '\u00F1': 'n',
                                '\u1E45': 'n',
                                '\u0148': 'n',
                                '\u1E47': 'n',
                                '\u0146': 'n',
                                '\u1E4B': 'n',
                                '\u1E49': 'n',
                                '\u019E': 'n',
                                '\u0272': 'n',
                                '\u0149': 'n',
                                '\uA791': 'n',
                                '\uA7A5': 'n',
                                '\u01CC': 'nj',
                                '\u24DE': 'o',
                                '\uFF4F': 'o',
                                '\u00F2': 'o',
                                '\u00F3': 'o',
                                '\u00F4': 'o',
                                '\u1ED3': 'o',
                                '\u1ED1': 'o',
                                '\u1ED7': 'o',
                                '\u1ED5': 'o',
                                '\u00F5': 'o',
                                '\u1E4D': 'o',
                                '\u022D': 'o',
                                '\u1E4F': 'o',
                                '\u014D': 'o',
                                '\u1E51': 'o',
                                '\u1E53': 'o',
                                '\u014F': 'o',
                                '\u022F': 'o',
                                '\u0231': 'o',
                                '\u00F6': 'o',
                                '\u022B': 'o',
                                '\u1ECF': 'o',
                                '\u0151': 'o',
                                '\u01D2': 'o',
                                '\u020D': 'o',
                                '\u020F': 'o',
                                '\u01A1': 'o',
                                '\u1EDD': 'o',
                                '\u1EDB': 'o',
                                '\u1EE1': 'o',
                                '\u1EDF': 'o',
                                '\u1EE3': 'o',
                                '\u1ECD': 'o',
                                '\u1ED9': 'o',
                                '\u01EB': 'o',
                                '\u01ED': 'o',
                                '\u00F8': 'o',
                                '\u01FF': 'o',
                                '\u0254': 'o',
                                '\uA74B': 'o',
                                '\uA74D': 'o',
                                '\u0275': 'o',
                                '\u0153': 'oe',
                                '\u01A3': 'oi',
                                '\u0223': 'ou',
                                '\uA74F': 'oo',
                                '\u24DF': 'p',
                                '\uFF50': 'p',
                                '\u1E55': 'p',
                                '\u1E57': 'p',
                                '\u01A5': 'p',
                                '\u1D7D': 'p',
                                '\uA751': 'p',
                                '\uA753': 'p',
                                '\uA755': 'p',
                                '\u24E0': 'q',
                                '\uFF51': 'q',
                                '\u024B': 'q',
                                '\uA757': 'q',
                                '\uA759': 'q',
                                '\u24E1': 'r',
                                '\uFF52': 'r',
                                '\u0155': 'r',
                                '\u1E59': 'r',
                                '\u0159': 'r',
                                '\u0211': 'r',
                                '\u0213': 'r',
                                '\u1E5B': 'r',
                                '\u1E5D': 'r',
                                '\u0157': 'r',
                                '\u1E5F': 'r',
                                '\u024D': 'r',
                                '\u027D': 'r',
                                '\uA75B': 'r',
                                '\uA7A7': 'r',
                                '\uA783': 'r',
                                '\u24E2': 's',
                                '\uFF53': 's',
                                '\u00DF': 's',
                                '\u015B': 's',
                                '\u1E65': 's',
                                '\u015D': 's',
                                '\u1E61': 's',
                                '\u0161': 's',
                                '\u1E67': 's',
                                '\u1E63': 's',
                                '\u1E69': 's',
                                '\u0219': 's',
                                '\u015F': 's',
                                '\u023F': 's',
                                '\uA7A9': 's',
                                '\uA785': 's',
                                '\u1E9B': 's',
                                '\u24E3': 't',
                                '\uFF54': 't',
                                '\u1E6B': 't',
                                '\u1E97': 't',
                                '\u0165': 't',
                                '\u1E6D': 't',
                                '\u021B': 't',
                                '\u0163': 't',
                                '\u1E71': 't',
                                '\u1E6F': 't',
                                '\u0167': 't',
                                '\u01AD': 't',
                                '\u0288': 't',
                                '\u2C66': 't',
                                '\uA787': 't',
                                '\uA729': 'tz',
                                '\u24E4': 'u',
                                '\uFF55': 'u',
                                '\u00F9': 'u',
                                '\u00FA': 'u',
                                '\u00FB': 'u',
                                '\u0169': 'u',
                                '\u1E79': 'u',
                                '\u016B': 'u',
                                '\u1E7B': 'u',
                                '\u016D': 'u',
                                '\u00FC': 'u',
                                '\u01DC': 'u',
                                '\u01D8': 'u',
                                '\u01D6': 'u',
                                '\u01DA': 'u',
                                '\u1EE7': 'u',
                                '\u016F': 'u',
                                '\u0171': 'u',
                                '\u01D4': 'u',
                                '\u0215': 'u',
                                '\u0217': 'u',
                                '\u01B0': 'u',
                                '\u1EEB': 'u',
                                '\u1EE9': 'u',
                                '\u1EEF': 'u',
                                '\u1EED': 'u',
                                '\u1EF1': 'u',
                                '\u1EE5': 'u',
                                '\u1E73': 'u',
                                '\u0173': 'u',
                                '\u1E77': 'u',
                                '\u1E75': 'u',
                                '\u0289': 'u',
                                '\u24E5': 'v',
                                '\uFF56': 'v',
                                '\u1E7D': 'v',
                                '\u1E7F': 'v',
                                '\u028B': 'v',
                                '\uA75F': 'v',
                                '\u028C': 'v',
                                '\uA761': 'vy',
                                '\u24E6': 'w',
                                '\uFF57': 'w',
                                '\u1E81': 'w',
                                '\u1E83': 'w',
                                '\u0175': 'w',
                                '\u1E87': 'w',
                                '\u1E85': 'w',
                                '\u1E98': 'w',
                                '\u1E89': 'w',
                                '\u2C73': 'w',
                                '\u24E7': 'x',
                                '\uFF58': 'x',
                                '\u1E8B': 'x',
                                '\u1E8D': 'x',
                                '\u24E8': 'y',
                                '\uFF59': 'y',
                                '\u1EF3': 'y',
                                '\u00FD': 'y',
                                '\u0177': 'y',
                                '\u1EF9': 'y',
                                '\u0233': 'y',
                                '\u1E8F': 'y',
                                '\u00FF': 'y',
                                '\u1EF7': 'y',
                                '\u1E99': 'y',
                                '\u1EF5': 'y',
                                '\u01B4': 'y',
                                '\u024F': 'y',
                                '\u1EFF': 'y',
                                '\u24E9': 'z',
                                '\uFF5A': 'z',
                                '\u017A': 'z',
                                '\u1E91': 'z',
                                '\u017C': 'z',
                                '\u017E': 'z',
                                '\u1E93': 'z',
                                '\u1E95': 'z',
                                '\u01B6': 'z',
                                '\u0225': 'z',
                                '\u0240': 'z',
                                '\u2C6C': 'z',
                                '\uA763': 'z',
                                '\u0386': '\u0391',
                                '\u0388': '\u0395',
                                '\u0389': '\u0397',
                                '\u038A': '\u0399',
                                '\u03AA': '\u0399',
                                '\u038C': '\u039F',
                                '\u038E': '\u03A5',
                                '\u03AB': '\u03A5',
                                '\u038F': '\u03A9',
                                '\u03AC': '\u03B1',
                                '\u03AD': '\u03B5',
                                '\u03AE': '\u03B7',
                                '\u03AF': '\u03B9',
                                '\u03CA': '\u03B9',
                                '\u0390': '\u03B9',
                                '\u03CC': '\u03BF',
                                '\u03CD': '\u03C5',
                                '\u03CB': '\u03C5',
                                '\u03B0': '\u03C5',
                                '\u03CE': '\u03C9',
                                '\u03C2': '\u03C3',
                                '\u2019': '\''
                            };

                            return diacritics;
                        });

                        S2.define('select2/data/base',[
                            '../utils'
                        ], function (Utils) {
                            function BaseAdapter ($element, options) {
                                BaseAdapter.__super__.constructor.call(this);
                            }

                            Utils.Extend(BaseAdapter, Utils.Observable);

                            BaseAdapter.prototype.current = function (callback) {
                                throw new Error('The `current` method must be defined in child classes.');
                            };

                            BaseAdapter.prototype.query = function (params, callback) {
                                throw new Error('The `query` method must be defined in child classes.');
                            };

                            BaseAdapter.prototype.bind = function (container, $container) {
                                // Can be implemented in subclasses
                            };

                            BaseAdapter.prototype.destroy = function () {
                                // Can be implemented in subclasses
                            };

                            BaseAdapter.prototype.generateResultId = function (container, data) {
                                var id = container.id + '-result-';

                                id += Utils.generateChars(4);

                                if (data.id != null) {
                                    id += '-' + data.id.toString();
                                } else {
                                    id += '-' + Utils.generateChars(4);
                                }
                                return id;
                            };

                            return BaseAdapter;
                        });

                        S2.define('select2/data/select',[
                            './base',
                            '../utils',
                            'jquery'
                        ], function (BaseAdapter, Utils, $) {
                            function SelectAdapter ($element, options) {
                                this.$element = $element;
                                this.options = options;

                                SelectAdapter.__super__.constructor.call(this);
                            }

                            Utils.Extend(SelectAdapter, BaseAdapter);

                            SelectAdapter.prototype.current = function (callback) {
                                var data = [];
                                var self = this;

                                this.$element.find(':selected').each(function () {
                                    var $option = $(this);

                                    var option = self.item($option);

                                    data.push(option);
                                });

                                callback(data);
                            };

                            SelectAdapter.prototype.select = function (data) {
                                var self = this;

                                data.selected = true;

                                // If data.element is a DOM node, use it instead
                                if ($(data.element).is('option')) {
                                    data.element.selected = true;

                                    this.$element.trigger('input').trigger('change');

                                    return;
                                }

                                if (this.$element.prop('multiple')) {
                                    this.current(function (currentData) {
                                        var val = [];

                                        data = [data];
                                        data.push.apply(data, currentData);

                                        for (var d = 0; d < data.length; d++) {
                                            var id = data[d].id;

                                            if ($.inArray(id, val) === -1) {
                                                val.push(id);
                                            }
                                        }

                                        self.$element.val(val);
                                        self.$element.trigger('input').trigger('change');
                                    });
                                } else {
                                    var val = data.id;

                                    this.$element.val(val);
                                    this.$element.trigger('input').trigger('change');
                                }
                            };

                            SelectAdapter.prototype.unselect = function (data) {
                                var self = this;

                                if (!this.$element.prop('multiple')) {
                                    return;
                                }

                                data.selected = false;

                                if ($(data.element).is('option')) {
                                    data.element.selected = false;

                                    this.$element.trigger('input').trigger('change');

                                    return;
                                }

                                this.current(function (currentData) {
                                    var val = [];

                                    for (var d = 0; d < currentData.length; d++) {
                                        var id = currentData[d].id;

                                        if (id !== data.id && $.inArray(id, val) === -1) {
                                            val.push(id);
                                        }
                                    }

                                    self.$element.val(val);

                                    self.$element.trigger('input').trigger('change');
                                });
                            };

                            SelectAdapter.prototype.bind = function (container, $container) {
                                var self = this;

                                this.container = container;

                                container.on('select', function (params) {
                                    self.select(params.data);
                                });

                                container.on('unselect', function (params) {
                                    self.unselect(params.data);
                                });
                            };

                            SelectAdapter.prototype.destroy = function () {
                                // Remove anything added to child elements
                                this.$element.find('*').each(function () {
                                    // Remove any custom data set by Select2
                                    Utils.RemoveData(this);
                                });
                            };

                            SelectAdapter.prototype.query = function (params, callback) {
                                var data = [];
                                var self = this;

                                var $options = this.$element.children();

                                $options.each(function () {
                                    var $option = $(this);

                                    if (!$option.is('option') && !$option.is('optgroup')) {
                                        return;
                                    }

                                    var option = self.item($option);

                                    var matches = self.matches(params, option);

                                    if (matches !== null) {
                                        data.push(matches);
                                    }
                                });

                                callback({
                                    results: data
                                });
                            };

                            SelectAdapter.prototype.addOptions = function ($options) {
                                Utils.appendMany(this.$element, $options);
                            };

                            SelectAdapter.prototype.option = function (data) {
                                var option;

                                if (data.children) {
                                    option = document.createElement('optgroup');
                                    option.label = data.text;
                                } else {
                                    option = document.createElement('option');

                                    if (option.textContent !== undefined) {
                                        option.textContent = data.text;
                                    } else {
                                        option.innerText = data.text;
                                    }
                                }

                                if (data.id !== undefined) {
                                    option.value = data.id;
                                }

                                if (data.disabled) {
                                    option.disabled = true;
                                }

                                if (data.selected) {
                                    option.selected = true;
                                }

                                if (data.title) {
                                    option.title = data.title;
                                }

                                var $option = $(option);

                                var normalizedData = this._normalizeItem(data);
                                normalizedData.element = option;

                                // Override the option's data with the combined data
                                Utils.StoreData(option, 'data', normalizedData);

                                return $option;
                            };

                            SelectAdapter.prototype.item = function ($option) {
                                var data = {};

                                data = Utils.GetData($option[0], 'data');

                                if (data != null) {
                                    return data;
                                }

                                if ($option.is('option')) {
                                    data = {
                                        id: $option.val(),
                                        text: $option.text(),
                                        disabled: $option.prop('disabled'),
                                        selected: $option.prop('selected'),
                                        title: $option.prop('title')
                                    };
                                } else if ($option.is('optgroup')) {
                                    data = {
                                        text: $option.prop('label'),
                                        children: [],
                                        title: $option.prop('title')
                                    };

                                    var $children = $option.children('option');
                                    var children = [];

                                    for (var c = 0; c < $children.length; c++) {
                                        var $child = $($children[c]);

                                        var child = this.item($child);

                                        children.push(child);
                                    }

                                    data.children = children;
                                }

                                data = this._normalizeItem(data);
                                data.element = $option[0];

                                Utils.StoreData($option[0], 'data', data);

                                return data;
                            };

                            SelectAdapter.prototype._normalizeItem = function (item) {
                                if (item !== Object(item)) {
                                    item = {
                                        id: item,
                                        text: item
                                    };
                                }

                                item = $.extend({}, {
                                    text: ''
                                }, item);

                                var defaults = {
                                    selected: false,
                                    disabled: false
                                };

                                if (item.id != null) {
                                    item.id = item.id.toString();
                                }

                                if (item.text != null) {
                                    item.text = item.text.toString();
                                }

                                if (item._resultId == null && item.id && this.container != null) {
                                    item._resultId = this.generateResultId(this.container, item);
                                }

                                return $.extend({}, defaults, item);
                            };

                            SelectAdapter.prototype.matches = function (params, data) {
                                var matcher = this.options.get('matcher');

                                return matcher(params, data);
                            };

                            return SelectAdapter;
                        });

                        S2.define('select2/data/array',[
                            './select',
                            '../utils',
                            'jquery'
                        ], function (SelectAdapter, Utils, $) {
                            function ArrayAdapter ($element, options) {
                                this._dataToConvert = options.get('data') || [];

                                ArrayAdapter.__super__.constructor.call(this, $element, options);
                            }

                            Utils.Extend(ArrayAdapter, SelectAdapter);

                            ArrayAdapter.prototype.bind = function (container, $container) {
                                ArrayAdapter.__super__.bind.call(this, container, $container);

                                this.addOptions(this.convertToOptions(this._dataToConvert));
                            };

                            ArrayAdapter.prototype.select = function (data) {
                                var $option = this.$element.find('option').filter(function (i, elm) {
                                    return elm.value == data.id.toString();
                                });

                                if ($option.length === 0) {
                                    $option = this.option(data);

                                    this.addOptions($option);
                                }

                                ArrayAdapter.__super__.select.call(this, data);
                            };

                            ArrayAdapter.prototype.convertToOptions = function (data) {
                                var self = this;

                                var $existing = this.$element.find('option');
                                var existingIds = $existing.map(function () {
                                    return self.item($(this)).id;
                                }).get();

                                var $options = [];

                                // Filter out all items except for the one passed in the argument
                                function onlyItem (item) {
                                    return function () {
                                        return $(this).val() == item.id;
                                    };
                                }

                                for (var d = 0; d < data.length; d++) {
                                    var item = this._normalizeItem(data[d]);

                                    // Skip items which were pre-loaded, only merge the data
                                    if ($.inArray(item.id, existingIds) >= 0) {
                                        var $existingOption = $existing.filter(onlyItem(item));

                                        var existingData = this.item($existingOption);
                                        var newData = $.extend(true, {}, item, existingData);

                                        var $newOption = this.option(newData);

                                        $existingOption.replaceWith($newOption);

                                        continue;
                                    }

                                    var $option = this.option(item);

                                    if (item.children) {
                                        var $children = this.convertToOptions(item.children);

                                        Utils.appendMany($option, $children);
                                    }

                                    $options.push($option);
                                }

                                return $options;
                            };

                            return ArrayAdapter;
                        });

                        S2.define('select2/data/ajax',[
                            './array',
                            '../utils',
                            'jquery'
                        ], function (ArrayAdapter, Utils, $) {
                            function AjaxAdapter ($element, options) {
                                this.ajaxOptions = this._applyDefaults(options.get('ajax'));

                                if (this.ajaxOptions.processResults != null) {
                                    this.processResults = this.ajaxOptions.processResults;
                                }

                                AjaxAdapter.__super__.constructor.call(this, $element, options);
                            }

                            Utils.Extend(AjaxAdapter, ArrayAdapter);

                            AjaxAdapter.prototype._applyDefaults = function (options) {
                                var defaults = {
                                    data: function (params) {
                                        return $.extend({}, params, {
                                            q: params.term
                                        });
                                    },
                                    transport: function (params, success, failure) {
                                        var $request = $.ajax(params);

                                        $request.then(success);
                                        $request.fail(failure);

                                        return $request;
                                    }
                                };

                                return $.extend({}, defaults, options, true);
                            };

                            AjaxAdapter.prototype.processResults = function (results) {
                                return results;
                            };

                            AjaxAdapter.prototype.query = function (params, callback) {
                                var matches = [];
                                var self = this;

                                if (this._request != null) {
                                    // JSONP requests cannot always be aborted
                                    if ($.isFunction(this._request.abort)) {
                                        this._request.abort();
                                    }

                                    this._request = null;
                                }

                                var options = $.extend({
                                    type: 'GET'
                                }, this.ajaxOptions);

                                if (typeof options.url === 'function') {
                                    options.url = options.url.call(this.$element, params);
                                }

                                if (typeof options.data === 'function') {
                                    options.data = options.data.call(this.$element, params);
                                }

                                function request () {
                                    var $request = options.transport(options, function (data) {
                                        var results = self.processResults(data, params);

                                        if (self.options.get('debug') && window.console && console.error) {
                                            // Check to make sure that the response included a `results` key.
                                            if (!results || !results.results || !$.isArray(results.results)) {
                                                console.error(
                                                    'Select2: The AJAX results did not return an array in the ' +
                                                    '`results` key of the response.'
                                                );
                                            }
                                        }

                                        callback(results);
                                    }, function () {
                                        // Attempt to detect if a request was aborted
                                        // Only works if the transport exposes a status property
                                        if ('status' in $request &&
                                            ($request.status === 0 || $request.status === '0')) {
                                            return;
                                        }

                                        self.trigger('results:message', {
                                            message: 'errorLoading'
                                        });
                                    });

                                    self._request = $request;
                                }

                                if (this.ajaxOptions.delay && params.term != null) {
                                    if (this._queryTimeout) {
                                        window.clearTimeout(this._queryTimeout);
                                    }

                                    this._queryTimeout = window.setTimeout(request, this.ajaxOptions.delay);
                                } else {
                                    request();
                                }
                            };

                            return AjaxAdapter;
                        });

                        S2.define('select2/data/tags',[
                            'jquery'
                        ], function ($) {
                            function Tags (decorated, $element, options) {
                                var tags = options.get('tags');

                                var createTag = options.get('createTag');

                                if (createTag !== undefined) {
                                    this.createTag = createTag;
                                }

                                var insertTag = options.get('insertTag');

                                if (insertTag !== undefined) {
                                    this.insertTag = insertTag;
                                }

                                decorated.call(this, $element, options);

                                if ($.isArray(tags)) {
                                    for (var t = 0; t < tags.length; t++) {
                                        var tag = tags[t];
                                        var item = this._normalizeItem(tag);

                                        var $option = this.option(item);

                                        this.$element.append($option);
                                    }
                                }
                            }

                            Tags.prototype.query = function (decorated, params, callback) {
                                var self = this;

                                this._removeOldTags();

                                if (params.term == null || params.page != null) {
                                    decorated.call(this, params, callback);
                                    return;
                                }

                                function wrapper (obj, child) {
                                    var data = obj.results;

                                    for (var i = 0; i < data.length; i++) {
                                        var option = data[i];

                                        var checkChildren = (
                                            option.children != null &&
                                            !wrapper({
                                                results: option.children
                                            }, true)
                                        );

                                        var optionText = (option.text || '').toUpperCase();
                                        var paramsTerm = (params.term || '').toUpperCase();

                                        var checkText = optionText === paramsTerm;

                                        if (checkText || checkChildren) {
                                            if (child) {
                                                return false;
                                            }

                                            obj.data = data;
                                            callback(obj);

                                            return;
                                        }
                                    }

                                    if (child) {
                                        return true;
                                    }

                                    var tag = self.createTag(params);

                                    if (tag != null) {
                                        var $option = self.option(tag);
                                        $option.attr('data-select2-tag', true);

                                        self.addOptions([$option]);

                                        self.insertTag(data, tag);
                                    }

                                    obj.results = data;

                                    callback(obj);
                                }

                                decorated.call(this, params, wrapper);
                            };

                            Tags.prototype.createTag = function (decorated, params) {
                                var term = $.trim(params.term);

                                if (term === '') {
                                    return null;
                                }

                                return {
                                    id: term,
                                    text: term
                                };
                            };

                            Tags.prototype.insertTag = function (_, data, tag) {
                                data.unshift(tag);
                            };

                            Tags.prototype._removeOldTags = function (_) {
                                var $options = this.$element.find('option[data-select2-tag]');

                                $options.each(function () {
                                    if (this.selected) {
                                        return;
                                    }

                                    $(this).remove();
                                });
                            };

                            return Tags;
                        });

                        S2.define('select2/data/tokenizer',[
                            'jquery'
                        ], function ($) {
                            function Tokenizer (decorated, $element, options) {
                                var tokenizer = options.get('tokenizer');

                                if (tokenizer !== undefined) {
                                    this.tokenizer = tokenizer;
                                }

                                decorated.call(this, $element, options);
                            }

                            Tokenizer.prototype.bind = function (decorated, container, $container) {
                                decorated.call(this, container, $container);

                                this.$search =  container.dropdown.$search || container.selection.$search ||
                                    $container.find('.select2-search__field');
                            };

                            Tokenizer.prototype.query = function (decorated, params, callback) {
                                var self = this;

                                function createAndSelect (data) {
                                    // Normalize the data object so we can use it for checks
                                    var item = self._normalizeItem(data);

                                    // Check if the data object already exists as a tag
                                    // Select it if it doesn't
                                    var $existingOptions = self.$element.find('option').filter(function () {
                                        return $(this).val() === item.id;
                                    });

                                    // If an existing option wasn't found for it, create the option
                                    if (!$existingOptions.length) {
                                        var $option = self.option(item);
                                        $option.attr('data-select2-tag', true);

                                        self._removeOldTags();
                                        self.addOptions([$option]);
                                    }

                                    // Select the item, now that we know there is an option for it
                                    select(item);
                                }

                                function select (data) {
                                    self.trigger('select', {
                                        data: data
                                    });
                                }

                                params.term = params.term || '';

                                var tokenData = this.tokenizer(params, this.options, createAndSelect);

                                if (tokenData.term !== params.term) {
                                    // Replace the search term if we have the search box
                                    if (this.$search.length) {
                                        this.$search.val(tokenData.term);
                                        this.$search.trigger('focus');
                                    }

                                    params.term = tokenData.term;
                                }

                                decorated.call(this, params, callback);
                            };

                            Tokenizer.prototype.tokenizer = function (_, params, options, callback) {
                                var separators = options.get('tokenSeparators') || [];
                                var term = params.term;
                                var i = 0;

                                var createTag = this.createTag || function (params) {
                                    return {
                                        id: params.term,
                                        text: params.term
                                    };
                                };

                                while (i < term.length) {
                                    var termChar = term[i];

                                    if ($.inArray(termChar, separators) === -1) {
                                        i++;

                                        continue;
                                    }

                                    var part = term.substr(0, i);
                                    var partParams = $.extend({}, params, {
                                        term: part
                                    });

                                    var data = createTag(partParams);

                                    if (data == null) {
                                        i++;
                                        continue;
                                    }

                                    callback(data);

                                    // Reset the term to not include the tokenized portion
                                    term = term.substr(i + 1) || '';
                                    i = 0;
                                }

                                return {
                                    term: term
                                };
                            };

                            return Tokenizer;
                        });

                        S2.define('select2/data/minimumInputLength',[

                        ], function () {
                            function MinimumInputLength (decorated, $e, options) {
                                this.minimumInputLength = options.get('minimumInputLength');

                                decorated.call(this, $e, options);
                            }

                            MinimumInputLength.prototype.query = function (decorated, params, callback) {
                                params.term = params.term || '';

                                if (params.term.length < this.minimumInputLength) {
                                    this.trigger('results:message', {
                                        message: 'inputTooShort',
                                        args: {
                                            minimum: this.minimumInputLength,
                                            input: params.term,
                                            params: params
                                        }
                                    });

                                    return;
                                }

                                decorated.call(this, params, callback);
                            };

                            return MinimumInputLength;
                        });

                        S2.define('select2/data/maximumInputLength',[

                        ], function () {
                            function MaximumInputLength (decorated, $e, options) {
                                this.maximumInputLength = options.get('maximumInputLength');

                                decorated.call(this, $e, options);
                            }

                            MaximumInputLength.prototype.query = function (decorated, params, callback) {
                                params.term = params.term || '';

                                if (this.maximumInputLength > 0 &&
                                    params.term.length > this.maximumInputLength) {
                                    this.trigger('results:message', {
                                        message: 'inputTooLong',
                                        args: {
                                            maximum: this.maximumInputLength,
                                            input: params.term,
                                            params: params
                                        }
                                    });

                                    return;
                                }

                                decorated.call(this, params, callback);
                            };

                            return MaximumInputLength;
                        });

                        S2.define('select2/data/maximumSelectionLength',[

                        ], function (){
                            function MaximumSelectionLength (decorated, $e, options) {
                                this.maximumSelectionLength = options.get('maximumSelectionLength');

                                decorated.call(this, $e, options);
                            }

                            MaximumSelectionLength.prototype.bind =
                                function (decorated, container, $container) {
                                    var self = this;

                                    decorated.call(this, container, $container);

                                    container.on('select', function () {
                                        self._checkIfMaximumSelected();
                                    });
                                };

                            MaximumSelectionLength.prototype.query =
                                function (decorated, params, callback) {
                                    var self = this;

                                    this._checkIfMaximumSelected(function () {
                                        decorated.call(self, params, callback);
                                    });
                                };

                            MaximumSelectionLength.prototype._checkIfMaximumSelected =
                                function (_, successCallback) {
                                    var self = this;

                                    this.current(function (currentData) {
                                        var count = currentData != null ? currentData.length : 0;
                                        if (self.maximumSelectionLength > 0 &&
                                            count >= self.maximumSelectionLength) {
                                            self.trigger('results:message', {
                                                message: 'maximumSelected',
                                                args: {
                                                    maximum: self.maximumSelectionLength
                                                }
                                            });
                                            return;
                                        }

                                        if (successCallback) {
                                            successCallback();
                                        }
                                    });
                                };

                            return MaximumSelectionLength;
                        });

                        S2.define('select2/dropdown',[
                            'jquery',
                            './utils'
                        ], function ($, Utils) {
                            function Dropdown ($element, options) {
                                this.$element = $element;
                                this.options = options;

                                Dropdown.__super__.constructor.call(this);
                            }

                            Utils.Extend(Dropdown, Utils.Observable);

                            Dropdown.prototype.render = function () {
                                var $dropdown = $(
                                    '<span class="select2-dropdown">' +
                                    '<span class="select2-results"></span>' +
                                    '</span>'
                                );

                                $dropdown.attr('dir', this.options.get('dir'));

                                this.$dropdown = $dropdown;

                                return $dropdown;
                            };

                            Dropdown.prototype.bind = function () {
                                // Should be implemented in subclasses
                            };

                            Dropdown.prototype.position = function ($dropdown, $container) {
                                // Should be implemented in subclasses
                            };

                            Dropdown.prototype.destroy = function () {
                                // Remove the dropdown from the DOM
                                this.$dropdown.remove();
                            };

                            return Dropdown;
                        });

                        S2.define('select2/dropdown/search',[
                            'jquery',
                            '../utils'
                        ], function ($, Utils) {
                            function Search () { }

                            Search.prototype.render = function (decorated) {
                                var $rendered = decorated.call(this);

                                var $search = $(
                                    '<span class="select2-search select2-search--dropdown">' +
                                    '<input class="select2-search__field" type="search" tabindex="-1"' +
                                    ' autocomplete="off" autocorrect="off" autocapitalize="none"' +
                                    ' spellcheck="false" role="searchbox" aria-autocomplete="list" />' +
                                    '</span>'
                                );

                                this.$searchContainer = $search;
                                this.$search = $search.find('input');

                                $rendered.prepend($search);

                                return $rendered;
                            };

                            Search.prototype.bind = function (decorated, container, $container) {
                                var self = this;

                                var resultsId = container.id + '-results';

                                decorated.call(this, container, $container);

                                this.$search.on('keydown', function (evt) {
                                    self.trigger('keypress', evt);

                                    self._keyUpPrevented = evt.isDefaultPrevented();
                                });

                                // Workaround for browsers which do not support the `input` event
                                // This will prevent double-triggering of events for browsers which support
                                // both the `keyup` and `input` events.
                                this.$search.on('input', function (evt) {
                                    // Unbind the duplicated `keyup` event
                                    $(this).off('keyup');
                                });

                                this.$search.on('keyup input', function (evt) {
                                    self.handleSearch(evt);
                                });

                                container.on('open', function () {
                                    self.$search.attr('tabindex', 0);
                                    self.$search.attr('aria-controls', resultsId);

                                    self.$search.trigger('focus');

                                    window.setTimeout(function () {
                                        self.$search.trigger('focus');
                                    }, 0);
                                });

                                container.on('close', function () {
                                    self.$search.attr('tabindex', -1);
                                    self.$search.removeAttr('aria-controls');
                                    self.$search.removeAttr('aria-activedescendant');

                                    self.$search.val('');
                                    self.$search.trigger('blur');
                                });

                                container.on('focus', function () {
                                    if (!container.isOpen()) {
                                        self.$search.trigger('focus');
                                    }
                                });

                                container.on('results:all', function (params) {
                                    if (params.query.term == null || params.query.term === '') {
                                        var showSearch = self.showSearch(params);

                                        if (showSearch) {
                                            self.$searchContainer.removeClass('select2-search--hide');
                                        } else {
                                            self.$searchContainer.addClass('select2-search--hide');
                                        }
                                    }
                                });

                                container.on('results:focus', function (params) {
                                    if (params.data._resultId) {
                                        self.$search.attr('aria-activedescendant', params.data._resultId);
                                    } else {
                                        self.$search.removeAttr('aria-activedescendant');
                                    }
                                });
                            };

                            Search.prototype.handleSearch = function (evt) {
                                if (!this._keyUpPrevented) {
                                    var input = this.$search.val();

                                    this.trigger('query', {
                                        term: input
                                    });
                                }

                                this._keyUpPrevented = false;
                            };

                            Search.prototype.showSearch = function (_, params) {
                                return true;
                            };

                            return Search;
                        });

                        S2.define('select2/dropdown/hidePlaceholder',[

                        ], function () {
                            function HidePlaceholder (decorated, $element, options, dataAdapter) {
                                this.placeholder = this.normalizePlaceholder(options.get('placeholder'));

                                decorated.call(this, $element, options, dataAdapter);
                            }

                            HidePlaceholder.prototype.append = function (decorated, data) {
                                data.results = this.removePlaceholder(data.results);

                                decorated.call(this, data);
                            };

                            HidePlaceholder.prototype.normalizePlaceholder = function (_, placeholder) {
                                if (typeof placeholder === 'string') {
                                    placeholder = {
                                        id: '',
                                        text: placeholder
                                    };
                                }

                                return placeholder;
                            };

                            HidePlaceholder.prototype.removePlaceholder = function (_, data) {
                                var modifiedData = data.slice(0);

                                for (var d = data.length - 1; d >= 0; d--) {
                                    var item = data[d];

                                    if (this.placeholder.id === item.id) {
                                        modifiedData.splice(d, 1);
                                    }
                                }

                                return modifiedData;
                            };

                            return HidePlaceholder;
                        });

                        S2.define('select2/dropdown/infiniteScroll',[
                            'jquery'
                        ], function ($) {
                            function InfiniteScroll (decorated, $element, options, dataAdapter) {
                                this.lastParams = {};

                                decorated.call(this, $element, options, dataAdapter);

                                this.$loadingMore = this.createLoadingMore();
                                this.loading = false;
                            }

                            InfiniteScroll.prototype.append = function (decorated, data) {
                                this.$loadingMore.remove();
                                this.loading = false;

                                decorated.call(this, data);

                                if (this.showLoadingMore(data)) {
                                    this.$results.append(this.$loadingMore);
                                    this.loadMoreIfNeeded();
                                }
                            };

                            InfiniteScroll.prototype.bind = function (decorated, container, $container) {
                                var self = this;

                                decorated.call(this, container, $container);

                                container.on('query', function (params) {
                                    self.lastParams = params;
                                    self.loading = true;
                                });

                                container.on('query:append', function (params) {
                                    self.lastParams = params;
                                    self.loading = true;
                                });

                                this.$results.on('scroll', this.loadMoreIfNeeded.bind(this));
                            };

                            InfiniteScroll.prototype.loadMoreIfNeeded = function () {
                                var isLoadMoreVisible = $.contains(
                                    document.documentElement,
                                    this.$loadingMore[0]
                                );

                                if (this.loading || !isLoadMoreVisible) {
                                    return;
                                }

                                var currentOffset = this.$results.offset().top +
                                    this.$results.outerHeight(false);
                                var loadingMoreOffset = this.$loadingMore.offset().top +
                                    this.$loadingMore.outerHeight(false);

                                if (currentOffset + 50 >= loadingMoreOffset) {
                                    this.loadMore();
                                }
                            };

                            InfiniteScroll.prototype.loadMore = function () {
                                this.loading = true;

                                var params = $.extend({}, {page: 1}, this.lastParams);

                                params.page++;

                                this.trigger('query:append', params);
                            };

                            InfiniteScroll.prototype.showLoadingMore = function (_, data) {
                                return data.pagination && data.pagination.more;
                            };

                            InfiniteScroll.prototype.createLoadingMore = function () {
                                var $option = $(
                                    '<li ' +
                                    'class="select2-results__option select2-results__option--load-more"' +
                                    'role="option" aria-disabled="true"></li>'
                                );

                                var message = this.options.get('translations').get('loadingMore');

                                $option.html(message(this.lastParams));

                                return $option;
                            };

                            return InfiniteScroll;
                        });

                        S2.define('select2/dropdown/attachBody',[
                            'jquery',
                            '../utils'
                        ], function ($, Utils) {
                            function AttachBody (decorated, $element, options) {
                                this.$dropdownParent = $(options.get('dropdownParent') || document.body);

                                decorated.call(this, $element, options);
                            }

                            AttachBody.prototype.bind = function (decorated, container, $container) {
                                var self = this;

                                decorated.call(this, container, $container);

                                container.on('open', function () {
                                    self._showDropdown();
                                    self._attachPositioningHandler(container);

                                    // Must bind after the results handlers to ensure correct sizing
                                    self._bindContainerResultHandlers(container);
                                });

                                container.on('close', function () {
                                    self._hideDropdown();
                                    self._detachPositioningHandler(container);
                                });

                                this.$dropdownContainer.on('mousedown', function (evt) {
                                    evt.stopPropagation();
                                });
                            };

                            AttachBody.prototype.destroy = function (decorated) {
                                decorated.call(this);

                                this.$dropdownContainer.remove();
                            };

                            AttachBody.prototype.position = function (decorated, $dropdown, $container) {
                                // Clone all of the container classes
                                $dropdown.attr('class', $container.attr('class'));

                                $dropdown.removeClass('select2');
                                $dropdown.addClass('select2-container--open');

                                $dropdown.css({
                                    position: 'absolute',
                                    top: -999999
                                });

                                this.$container = $container;
                            };

                            AttachBody.prototype.render = function (decorated) {
                                var $container = $('<span></span>');

                                var $dropdown = decorated.call(this);
                                $container.append($dropdown);

                                this.$dropdownContainer = $container;

                                return $container;
                            };

                            AttachBody.prototype._hideDropdown = function (decorated) {
                                this.$dropdownContainer.detach();
                            };

                            AttachBody.prototype._bindContainerResultHandlers =
                                function (decorated, container) {

                                    // These should only be bound once
                                    if (this._containerResultsHandlersBound) {
                                        return;
                                    }

                                    var self = this;

                                    container.on('results:all', function () {
                                        self._positionDropdown();
                                        self._resizeDropdown();
                                    });

                                    container.on('results:append', function () {
                                        self._positionDropdown();
                                        self._resizeDropdown();
                                    });

                                    container.on('results:message', function () {
                                        self._positionDropdown();
                                        self._resizeDropdown();
                                    });

                                    container.on('select', function () {
                                        self._positionDropdown();
                                        self._resizeDropdown();
                                    });

                                    container.on('unselect', function () {
                                        self._positionDropdown();
                                        self._resizeDropdown();
                                    });

                                    this._containerResultsHandlersBound = true;
                                };

                            AttachBody.prototype._attachPositioningHandler =
                                function (decorated, container) {
                                    var self = this;

                                    var scrollEvent = 'scroll.select2.' + container.id;
                                    var resizeEvent = 'resize.select2.' + container.id;
                                    var orientationEvent = 'orientationchange.select2.' + container.id;

                                    var $watchers = this.$container.parents().filter(Utils.hasScroll);
                                    $watchers.each(function () {
                                        Utils.StoreData(this, 'select2-scroll-position', {
                                            x: $(this).scrollLeft(),
                                            y: $(this).scrollTop()
                                        });
                                    });

                                    $watchers.on(scrollEvent, function (ev) {
                                        var position = Utils.GetData(this, 'select2-scroll-position');
                                        $(this).scrollTop(position.y);
                                    });

                                    $(window).on(scrollEvent + ' ' + resizeEvent + ' ' + orientationEvent,
                                        function (e) {
                                            self._positionDropdown();
                                            self._resizeDropdown();
                                        });
                                };

                            AttachBody.prototype._detachPositioningHandler =
                                function (decorated, container) {
                                    var scrollEvent = 'scroll.select2.' + container.id;
                                    var resizeEvent = 'resize.select2.' + container.id;
                                    var orientationEvent = 'orientationchange.select2.' + container.id;

                                    var $watchers = this.$container.parents().filter(Utils.hasScroll);
                                    $watchers.off(scrollEvent);

                                    $(window).off(scrollEvent + ' ' + resizeEvent + ' ' + orientationEvent);
                                };

                            AttachBody.prototype._positionDropdown = function () {
                                var $window = $(window);

                                var isCurrentlyAbove = this.$dropdown.hasClass('select2-dropdown--above');
                                var isCurrentlyBelow = this.$dropdown.hasClass('select2-dropdown--below');

                                var newDirection = null;

                                var offset = this.$container.offset();

                                offset.bottom = offset.top + this.$container.outerHeight(false);

                                var container = {
                                    height: this.$container.outerHeight(false)
                                };

                                container.top = offset.top;
                                container.bottom = offset.top + container.height;

                                var dropdown = {
                                    height: this.$dropdown.outerHeight(false)
                                };

                                var viewport = {
                                    top: $window.scrollTop(),
                                    bottom: $window.scrollTop() + $window.height()
                                };

                                var enoughRoomAbove = viewport.top < (offset.top - dropdown.height);
                                var enoughRoomBelow = viewport.bottom > (offset.bottom + dropdown.height);

                                var css = {
                                    left: offset.left,
                                    top: container.bottom
                                };

                                // Determine what the parent element is to use for calculating the offset
                                var $offsetParent = this.$dropdownParent;

                                // For statically positioned elements, we need to get the element
                                // that is determining the offset
                                if ($offsetParent.css('position') === 'static') {
                                    $offsetParent = $offsetParent.offsetParent();
                                }

                                var parentOffset = {
                                    top: 0,
                                    left: 0
                                };

                                if (
                                    $.contains(document.body, $offsetParent[0]) ||
                                    $offsetParent[0].isConnected
                                ) {
                                    parentOffset = $offsetParent.offset();
                                }

                                css.top -= parentOffset.top;
                                css.left -= parentOffset.left;

                                if (!isCurrentlyAbove && !isCurrentlyBelow) {
                                    newDirection = 'below';
                                }

                                if (!enoughRoomBelow && enoughRoomAbove && !isCurrentlyAbove) {
                                    newDirection = 'above';
                                } else if (!enoughRoomAbove && enoughRoomBelow && isCurrentlyAbove) {
                                    newDirection = 'below';
                                }

                                if (newDirection == 'above' ||
                                    (isCurrentlyAbove && newDirection !== 'below')) {
                                    css.top = container.top - parentOffset.top - dropdown.height;
                                }

                                if (newDirection != null) {
                                    this.$dropdown
                                        .removeClass('select2-dropdown--below select2-dropdown--above')
                                        .addClass('select2-dropdown--' + newDirection);
                                    this.$container
                                        .removeClass('select2-container--below select2-container--above')
                                        .addClass('select2-container--' + newDirection);
                                }

                                this.$dropdownContainer.css(css);
                            };

                            AttachBody.prototype._resizeDropdown = function () {
                                var css = {
                                    width: this.$container.outerWidth(false) + 'px'
                                };

                                if (this.options.get('dropdownAutoWidth')) {
                                    css.minWidth = css.width;
                                    css.position = 'relative';
                                    css.width = 'auto';
                                }

                                this.$dropdown.css(css);
                            };

                            AttachBody.prototype._showDropdown = function (decorated) {
                                this.$dropdownContainer.appendTo(this.$dropdownParent);

                                this._positionDropdown();
                                this._resizeDropdown();
                            };

                            return AttachBody;
                        });

                        S2.define('select2/dropdown/minimumResultsForSearch',[

                        ], function () {
                            function countResults (data) {
                                var count = 0;

                                for (var d = 0; d < data.length; d++) {
                                    var item = data[d];

                                    if (item.children) {
                                        count += countResults(item.children);
                                    } else {
                                        count++;
                                    }
                                }

                                return count;
                            }

                            function MinimumResultsForSearch (decorated, $element, options, dataAdapter) {
                                this.minimumResultsForSearch = options.get('minimumResultsForSearch');

                                if (this.minimumResultsForSearch < 0) {
                                    this.minimumResultsForSearch = Infinity;
                                }

                                decorated.call(this, $element, options, dataAdapter);
                            }

                            MinimumResultsForSearch.prototype.showSearch = function (decorated, params) {
                                if (countResults(params.data.results) < this.minimumResultsForSearch) {
                                    return false;
                                }

                                return decorated.call(this, params);
                            };

                            return MinimumResultsForSearch;
                        });

                        S2.define('select2/dropdown/selectOnClose',[
                            '../utils'
                        ], function (Utils) {
                            function SelectOnClose () { }

                            SelectOnClose.prototype.bind = function (decorated, container, $container) {
                                var self = this;

                                decorated.call(this, container, $container);

                                container.on('close', function (params) {
                                    self._handleSelectOnClose(params);
                                });
                            };

                            SelectOnClose.prototype._handleSelectOnClose = function (_, params) {
                                if (params && params.originalSelect2Event != null) {
                                    var event = params.originalSelect2Event;

                                    // Don't select an item if the close event was triggered from a select or
                                    // unselect event
                                    if (event._type === 'select' || event._type === 'unselect') {
                                        return;
                                    }
                                }

                                var $highlightedResults = this.getHighlightedResults();

                                // Only select highlighted results
                                if ($highlightedResults.length < 1) {
                                    return;
                                }

                                var data = Utils.GetData($highlightedResults[0], 'data');

                                // Don't re-select already selected resulte
                                if (
                                    (data.element != null && data.element.selected) ||
                                    (data.element == null && data.selected)
                                ) {
                                    return;
                                }

                                this.trigger('select', {
                                    data: data
                                });
                            };

                            return SelectOnClose;
                        });

                        S2.define('select2/dropdown/closeOnSelect',[

                        ], function () {
                            function CloseOnSelect () { }

                            CloseOnSelect.prototype.bind = function (decorated, container, $container) {
                                var self = this;

                                decorated.call(this, container, $container);

                                container.on('select', function (evt) {
                                    self._selectTriggered(evt);
                                });

                                container.on('unselect', function (evt) {
                                    self._selectTriggered(evt);
                                });
                            };

                            CloseOnSelect.prototype._selectTriggered = function (_, evt) {
                                var originalEvent = evt.originalEvent;

                                // Don't close if the control key is being held
                                if (originalEvent && (originalEvent.ctrlKey || originalEvent.metaKey)) {
                                    return;
                                }

                                this.trigger('close', {
                                    originalEvent: originalEvent,
                                    originalSelect2Event: evt
                                });
                            };

                            return CloseOnSelect;
                        });

                        S2.define('select2/i18n/en',[],function () {
                            // English
                            return {
                                errorLoading: function () {
                                    return 'The results could not be loaded.';
                                },
                                inputTooLong: function (args) {
                                    var overChars = args.input.length - args.maximum;

                                    var message = 'Please delete ' + overChars + ' character';

                                    if (overChars != 1) {
                                        message += 's';
                                    }

                                    return message;
                                },
                                inputTooShort: function (args) {
                                    var remainingChars = args.minimum - args.input.length;

                                    var message = 'Please enter ' + remainingChars + ' or more characters';

                                    return message;
                                },
                                loadingMore: function () {
                                    return 'Loading more results…';
                                },
                                maximumSelected: function (args) {
                                    var message = 'You can only select ' + args.maximum + ' item';

                                    if (args.maximum != 1) {
                                        message += 's';
                                    }

                                    return message;
                                },
                                noResults: function () {
                                    return 'No results found';
                                },
                                searching: function () {
                                    return 'Searching…';
                                },
                                removeAllItems: function () {
                                    return 'Remove all items';
                                }
                            };
                        });

                        S2.define('select2/defaults',[
                            'jquery',
                            'require',

                            './results',

                            './selection/single',
                            './selection/multiple',
                            './selection/placeholder',
                            './selection/allowClear',
                            './selection/search',
                            './selection/eventRelay',

                            './utils',
                            './translation',
                            './diacritics',

                            './data/select',
                            './data/array',
                            './data/ajax',
                            './data/tags',
                            './data/tokenizer',
                            './data/minimumInputLength',
                            './data/maximumInputLength',
                            './data/maximumSelectionLength',

                            './dropdown',
                            './dropdown/search',
                            './dropdown/hidePlaceholder',
                            './dropdown/infiniteScroll',
                            './dropdown/attachBody',
                            './dropdown/minimumResultsForSearch',
                            './dropdown/selectOnClose',
                            './dropdown/closeOnSelect',

                            './i18n/en'
                        ], function ($, require,

                                     ResultsList,

                                     SingleSelection, MultipleSelection, Placeholder, AllowClear,
                                     SelectionSearch, EventRelay,

                                     Utils, Translation, DIACRITICS,

                                     SelectData, ArrayData, AjaxData, Tags, Tokenizer,
                                     MinimumInputLength, MaximumInputLength, MaximumSelectionLength,

                                     Dropdown, DropdownSearch, HidePlaceholder, InfiniteScroll,
                                     AttachBody, MinimumResultsForSearch, SelectOnClose, CloseOnSelect,

                                     EnglishTranslation) {
                            function Defaults () {
                                this.reset();
                            }

                            Defaults.prototype.apply = function (options) {
                                options = $.extend(true, {}, this.defaults, options);

                                if (options.dataAdapter == null) {
                                    if (options.ajax != null) {
                                        options.dataAdapter = AjaxData;
                                    } else if (options.data != null) {
                                        options.dataAdapter = ArrayData;
                                    } else {
                                        options.dataAdapter = SelectData;
                                    }

                                    if (options.minimumInputLength > 0) {
                                        options.dataAdapter = Utils.Decorate(
                                            options.dataAdapter,
                                            MinimumInputLength
                                        );
                                    }

                                    if (options.maximumInputLength > 0) {
                                        options.dataAdapter = Utils.Decorate(
                                            options.dataAdapter,
                                            MaximumInputLength
                                        );
                                    }

                                    if (options.maximumSelectionLength > 0) {
                                        options.dataAdapter = Utils.Decorate(
                                            options.dataAdapter,
                                            MaximumSelectionLength
                                        );
                                    }

                                    if (options.tags) {
                                        options.dataAdapter = Utils.Decorate(options.dataAdapter, Tags);
                                    }

                                    if (options.tokenSeparators != null || options.tokenizer != null) {
                                        options.dataAdapter = Utils.Decorate(
                                            options.dataAdapter,
                                            Tokenizer
                                        );
                                    }

                                    if (options.query != null) {
                                        var Query = require(options.amdBase + 'compat/query');

                                        options.dataAdapter = Utils.Decorate(
                                            options.dataAdapter,
                                            Query
                                        );
                                    }

                                    if (options.initSelection != null) {
                                        var InitSelection = require(options.amdBase + 'compat/initSelection');

                                        options.dataAdapter = Utils.Decorate(
                                            options.dataAdapter,
                                            InitSelection
                                        );
                                    }
                                }

                                if (options.resultsAdapter == null) {
                                    options.resultsAdapter = ResultsList;

                                    if (options.ajax != null) {
                                        options.resultsAdapter = Utils.Decorate(
                                            options.resultsAdapter,
                                            InfiniteScroll
                                        );
                                    }

                                    if (options.placeholder != null) {
                                        options.resultsAdapter = Utils.Decorate(
                                            options.resultsAdapter,
                                            HidePlaceholder
                                        );
                                    }

                                    if (options.selectOnClose) {
                                        options.resultsAdapter = Utils.Decorate(
                                            options.resultsAdapter,
                                            SelectOnClose
                                        );
                                    }
                                }

                                if (options.dropdownAdapter == null) {
                                    if (options.multiple) {
                                        options.dropdownAdapter = Dropdown;
                                    } else {
                                        var SearchableDropdown = Utils.Decorate(Dropdown, DropdownSearch);

                                        options.dropdownAdapter = SearchableDropdown;
                                    }

                                    if (options.minimumResultsForSearch !== 0) {
                                        options.dropdownAdapter = Utils.Decorate(
                                            options.dropdownAdapter,
                                            MinimumResultsForSearch
                                        );
                                    }

                                    if (options.closeOnSelect) {
                                        options.dropdownAdapter = Utils.Decorate(
                                            options.dropdownAdapter,
                                            CloseOnSelect
                                        );
                                    }

                                    if (
                                        options.dropdownCssClass != null ||
                                        options.dropdownCss != null ||
                                        options.adaptDropdownCssClass != null
                                    ) {
                                        var DropdownCSS = require(options.amdBase + 'compat/dropdownCss');

                                        options.dropdownAdapter = Utils.Decorate(
                                            options.dropdownAdapter,
                                            DropdownCSS
                                        );
                                    }

                                    options.dropdownAdapter = Utils.Decorate(
                                        options.dropdownAdapter,
                                        AttachBody
                                    );
                                }

                                if (options.selectionAdapter == null) {
                                    if (options.multiple) {
                                        options.selectionAdapter = MultipleSelection;
                                    } else {
                                        options.selectionAdapter = SingleSelection;
                                    }

                                    // Add the placeholder mixin if a placeholder was specified
                                    if (options.placeholder != null) {
                                        options.selectionAdapter = Utils.Decorate(
                                            options.selectionAdapter,
                                            Placeholder
                                        );
                                    }

                                    if (options.allowClear) {
                                        options.selectionAdapter = Utils.Decorate(
                                            options.selectionAdapter,
                                            AllowClear
                                        );
                                    }

                                    if (options.multiple) {
                                        options.selectionAdapter = Utils.Decorate(
                                            options.selectionAdapter,
                                            SelectionSearch
                                        );
                                    }

                                    if (
                                        options.containerCssClass != null ||
                                        options.containerCss != null ||
                                        options.adaptContainerCssClass != null
                                    ) {
                                        var ContainerCSS = require(options.amdBase + 'compat/containerCss');

                                        options.selectionAdapter = Utils.Decorate(
                                            options.selectionAdapter,
                                            ContainerCSS
                                        );
                                    }

                                    options.selectionAdapter = Utils.Decorate(
                                        options.selectionAdapter,
                                        EventRelay
                                    );
                                }

                                // If the defaults were not previously applied from an element, it is
                                // possible for the language option to have not been resolved
                                options.language = this._resolveLanguage(options.language);

                                // Always fall back to English since it will always be complete
                                options.language.push('en');

                                var uniqueLanguages = [];

                                for (var l = 0; l < options.language.length; l++) {
                                    var language = options.language[l];

                                    if (uniqueLanguages.indexOf(language) === -1) {
                                        uniqueLanguages.push(language);
                                    }
                                }

                                options.language = uniqueLanguages;

                                options.translations = this._processTranslations(
                                    options.language,
                                    options.debug
                                );

                                return options;
                            };

                            Defaults.prototype.reset = function () {
                                function stripDiacritics (text) {
                                    // Used 'uni range + named function' from http://jsperf.com/diacritics/18
                                    function match(a) {
                                        return DIACRITICS[a] || a;
                                    }

                                    return text.replace(/[^\u0000-\u007E]/g, match);
                                }

                                function matcher (params, data) {
                                    // Always return the object if there is nothing to compare
                                    if ($.trim(params.term) === '') {
                                        return data;
                                    }

                                    // Do a recursive check for options with children
                                    if (data.children && data.children.length > 0) {
                                        // Clone the data object if there are children
                                        // This is required as we modify the object to remove any non-matches
                                        var match = $.extend(true, {}, data);

                                        // Check each child of the option
                                        for (var c = data.children.length - 1; c >= 0; c--) {
                                            var child = data.children[c];

                                            var matches = matcher(params, child);

                                            // If there wasn't a match, remove the object in the array
                                            if (matches == null) {
                                                match.children.splice(c, 1);
                                            }
                                        }

                                        // If any children matched, return the new object
                                        if (match.children.length > 0) {
                                            return match;
                                        }

                                        // If there were no matching children, check just the plain object
                                        return matcher(params, match);
                                    }

                                    var original = stripDiacritics(data.text).toUpperCase();
                                    var term = stripDiacritics(params.term).toUpperCase();

                                    // Check if the text contains the term
                                    if (original.indexOf(term) > -1) {
                                        return data;
                                    }

                                    // If it doesn't contain the term, don't return anything
                                    return null;
                                }

                                this.defaults = {
                                    amdBase: './',
                                    amdLanguageBase: './i18n/',
                                    closeOnSelect: true,
                                    debug: false,
                                    dropdownAutoWidth: false,
                                    escapeMarkup: Utils.escapeMarkup,
                                    language: {},
                                    matcher: matcher,
                                    minimumInputLength: 0,
                                    maximumInputLength: 0,
                                    maximumSelectionLength: 0,
                                    minimumResultsForSearch: 0,
                                    selectOnClose: false,
                                    scrollAfterSelect: false,
                                    sorter: function (data) {
                                        return data;
                                    },
                                    templateResult: function (result) {
                                        return result.text;
                                    },
                                    templateSelection: function (selection) {
                                        return selection.text;
                                    },
                                    theme: 'default',
                                    width: 'resolve'
                                };
                            };

                            Defaults.prototype.applyFromElement = function (options, $element) {
                                var optionLanguage = options.language;
                                var defaultLanguage = this.defaults.language;
                                var elementLanguage = $element.prop('lang');
                                var parentLanguage = $element.closest('[lang]').prop('lang');

                                var languages = Array.prototype.concat.call(
                                    this._resolveLanguage(elementLanguage),
                                    this._resolveLanguage(optionLanguage),
                                    this._resolveLanguage(defaultLanguage),
                                    this._resolveLanguage(parentLanguage)
                                );

                                options.language = languages;

                                return options;
                            };

                            Defaults.prototype._resolveLanguage = function (language) {
                                if (!language) {
                                    return [];
                                }

                                if ($.isEmptyObject(language)) {
                                    return [];
                                }

                                if ($.isPlainObject(language)) {
                                    return [language];
                                }

                                var languages;

                                if (!$.isArray(language)) {
                                    languages = [language];
                                } else {
                                    languages = language;
                                }

                                var resolvedLanguages = [];

                                for (var l = 0; l < languages.length; l++) {
                                    resolvedLanguages.push(languages[l]);

                                    if (typeof languages[l] === 'string' && languages[l].indexOf('-') > 0) {
                                        // Extract the region information if it is included
                                        var languageParts = languages[l].split('-');
                                        var baseLanguage = languageParts[0];

                                        resolvedLanguages.push(baseLanguage);
                                    }
                                }

                                return resolvedLanguages;
                            };

                            Defaults.prototype._processTranslations = function (languages, debug) {
                                var translations = new Translation();

                                for (var l = 0; l < languages.length; l++) {
                                    var languageData = new Translation();

                                    var language = languages[l];

                                    if (typeof language === 'string') {
                                        try {
                                            // Try to load it with the original name
                                            languageData = Translation.loadPath(language);
                                        } catch (e) {
                                            try {
                                                // If we couldn't load it, check if it wasn't the full path
                                                language = this.defaults.amdLanguageBase + language;
                                                languageData = Translation.loadPath(language);
                                            } catch (ex) {
                                                // The translation could not be loaded at all. Sometimes this is
                                                // because of a configuration problem, other times this can be
                                                // because of how Select2 helps load all possible translation files
                                                if (debug && window.console && console.warn) {
                                                    console.warn(
                                                        'Select2: The language file for "' + language + '" could ' +
                                                        'not be automatically loaded. A fallback will be used instead.'
                                                    );
                                                }
                                            }
                                        }
                                    } else if ($.isPlainObject(language)) {
                                        languageData = new Translation(language);
                                    } else {
                                        languageData = language;
                                    }

                                    translations.extend(languageData);
                                }

                                return translations;
                            };

                            Defaults.prototype.set = function (key, value) {
                                var camelKey = $.camelCase(key);

                                var data = {};
                                data[camelKey] = value;

                                var convertedData = Utils._convertData(data);

                                $.extend(true, this.defaults, convertedData);
                            };

                            var defaults = new Defaults();

                            return defaults;
                        });

                        S2.define('select2/options',[
                            'require',
                            'jquery',
                            './defaults',
                            './utils'
                        ], function (require, $, Defaults, Utils) {
                            function Options (options, $element) {
                                this.options = options;

                                if ($element != null) {
                                    this.fromElement($element);
                                }

                                if ($element != null) {
                                    this.options = Defaults.applyFromElement(this.options, $element);
                                }

                                this.options = Defaults.apply(this.options);

                                if ($element && $element.is('input')) {
                                    var InputCompat = require(this.get('amdBase') + 'compat/inputData');

                                    this.options.dataAdapter = Utils.Decorate(
                                        this.options.dataAdapter,
                                        InputCompat
                                    );
                                }
                            }

                            Options.prototype.fromElement = function ($e) {
                                var excludedData = ['select2'];

                                if (this.options.multiple == null) {
                                    this.options.multiple = $e.prop('multiple');
                                }

                                if (this.options.disabled == null) {
                                    this.options.disabled = $e.prop('disabled');
                                }

                                if (this.options.dir == null) {
                                    if ($e.prop('dir')) {
                                        this.options.dir = $e.prop('dir');
                                    } else if ($e.closest('[dir]').prop('dir')) {
                                        this.options.dir = $e.closest('[dir]').prop('dir');
                                    } else {
                                        this.options.dir = 'ltr';
                                    }
                                }

                                $e.prop('disabled', this.options.disabled);
                                $e.prop('multiple', this.options.multiple);

                                if (Utils.GetData($e[0], 'select2Tags')) {
                                    if (this.options.debug && window.console && console.warn) {
                                        console.warn(
                                            'Select2: The `data-select2-tags` attribute has been changed to ' +
                                            'use the `data-data` and `data-tags="true"` attributes and will be ' +
                                            'removed in future versions of Select2.'
                                        );
                                    }

                                    Utils.StoreData($e[0], 'data', Utils.GetData($e[0], 'select2Tags'));
                                    Utils.StoreData($e[0], 'tags', true);
                                }

                                if (Utils.GetData($e[0], 'ajaxUrl')) {
                                    if (this.options.debug && window.console && console.warn) {
                                        console.warn(
                                            'Select2: The `data-ajax-url` attribute has been changed to ' +
                                            '`data-ajax--url` and support for the old attribute will be removed' +
                                            ' in future versions of Select2.'
                                        );
                                    }

                                    $e.attr('ajax--url', Utils.GetData($e[0], 'ajaxUrl'));
                                    Utils.StoreData($e[0], 'ajax-Url', Utils.GetData($e[0], 'ajaxUrl'));
                                }

                                var dataset = {};

                                function upperCaseLetter(_, letter) {
                                    return letter.toUpperCase();
                                }

                                // Pre-load all of the attributes which are prefixed with `data-`
                                for (var attr = 0; attr < $e[0].attributes.length; attr++) {
                                    var attributeName = $e[0].attributes[attr].name;
                                    var prefix = 'data-';

                                    if (attributeName.substr(0, prefix.length) == prefix) {
                                        // Get the contents of the attribute after `data-`
                                        var dataName = attributeName.substring(prefix.length);

                                        // Get the data contents from the consistent source
                                        // This is more than likely the jQuery data helper
                                        var dataValue = Utils.GetData($e[0], dataName);

                                        // camelCase the attribute name to match the spec
                                        var camelDataName = dataName.replace(/-([a-z])/g, upperCaseLetter);

                                        // Store the data attribute contents into the dataset since
                                        dataset[camelDataName] = dataValue;
                                    }
                                }

                                // Prefer the element's `dataset` attribute if it exists
                                // jQuery 1.x does not correctly handle data attributes with multiple dashes
                                if ($.fn.jquery && $.fn.jquery.substr(0, 2) == '1.' && $e[0].dataset) {
                                    dataset = $.extend(true, {}, $e[0].dataset, dataset);
                                }

                                // Prefer our internal data cache if it exists
                                var data = $.extend(true, {}, Utils.GetData($e[0]), dataset);

                                data = Utils._convertData(data);

                                for (var key in data) {
                                    if ($.inArray(key, excludedData) > -1) {
                                        continue;
                                    }

                                    if ($.isPlainObject(this.options[key])) {
                                        $.extend(this.options[key], data[key]);
                                    } else {
                                        this.options[key] = data[key];
                                    }
                                }

                                return this;
                            };

                            Options.prototype.get = function (key) {
                                return this.options[key];
                            };

                            Options.prototype.set = function (key, val) {
                                this.options[key] = val;
                            };

                            return Options;
                        });

                        S2.define('select2/core',[
                            'jquery',
                            './options',
                            './utils',
                            './keys'
                        ], function ($, Options, Utils, KEYS) {
                            var Select2 = function ($element, options) {
                                if (Utils.GetData($element[0], 'select2') != null) {
                                    Utils.GetData($element[0], 'select2').destroy();
                                }

                                this.$element = $element;

                                this.id = this._generateId($element);

                                options = options || {};

                                this.options = new Options(options, $element);

                                Select2.__super__.constructor.call(this);

                                // Set up the tabindex

                                var tabindex = $element.attr('tabindex') || 0;
                                Utils.StoreData($element[0], 'old-tabindex', tabindex);
                                $element.attr('tabindex', '-1');

                                // Set up containers and adapters

                                var DataAdapter = this.options.get('dataAdapter');
                                this.dataAdapter = new DataAdapter($element, this.options);

                                var $container = this.render();

                                this._placeContainer($container);

                                var SelectionAdapter = this.options.get('selectionAdapter');
                                this.selection = new SelectionAdapter($element, this.options);
                                this.$selection = this.selection.render();

                                this.selection.position(this.$selection, $container);

                                var DropdownAdapter = this.options.get('dropdownAdapter');
                                this.dropdown = new DropdownAdapter($element, this.options);
                                this.$dropdown = this.dropdown.render();

                                this.dropdown.position(this.$dropdown, $container);

                                var ResultsAdapter = this.options.get('resultsAdapter');
                                this.results = new ResultsAdapter($element, this.options, this.dataAdapter);
                                this.$results = this.results.render();

                                this.results.position(this.$results, this.$dropdown);

                                // Bind events

                                var self = this;

                                // Bind the container to all of the adapters
                                this._bindAdapters();

                                // Register any DOM event handlers
                                this._registerDomEvents();

                                // Register any internal event handlers
                                this._registerDataEvents();
                                this._registerSelectionEvents();
                                this._registerDropdownEvents();
                                this._registerResultsEvents();
                                this._registerEvents();

                                // Set the initial state
                                this.dataAdapter.current(function (initialData) {
                                    self.trigger('selection:update', {
                                        data: initialData
                                    });
                                });

                                // Hide the original select
                                $element.addClass('select2-hidden-accessible');
                                $element.attr('aria-hidden', 'true');

                                // Synchronize any monitored attributes
                                this._syncAttributes();

                                Utils.StoreData($element[0], 'select2', this);

                                // Ensure backwards compatibility with $element.data('select2').
                                $element.data('select2', this);
                            };

                            Utils.Extend(Select2, Utils.Observable);

                            Select2.prototype._generateId = function ($element) {
                                var id = '';

                                if ($element.attr('id') != null) {
                                    id = $element.attr('id');
                                } else if ($element.attr('name') != null) {
                                    id = $element.attr('name') + '-' + Utils.generateChars(2);
                                } else {
                                    id = Utils.generateChars(4);
                                }

                                id = id.replace(/(:|\.|\[|\]|,)/g, '');
                                id = 'select2-' + id;

                                return id;
                            };

                            Select2.prototype._placeContainer = function ($container) {
                                $container.insertAfter(this.$element);

                                var width = this._resolveWidth(this.$element, this.options.get('width'));

                                if (width != null) {
                                    $container.css('width', width);
                                }
                            };

                            Select2.prototype._resolveWidth = function ($element, method) {
                                var WIDTH = /^width:(([-+]?([0-9]*\.)?[0-9]+)(px|em|ex|%|in|cm|mm|pt|pc))/i;

                                if (method == 'resolve') {
                                    var styleWidth = this._resolveWidth($element, 'style');

                                    if (styleWidth != null) {
                                        return styleWidth;
                                    }

                                    return this._resolveWidth($element, 'element');
                                }

                                if (method == 'element') {
                                    var elementWidth = $element.outerWidth(false);

                                    if (elementWidth <= 0) {
                                        return 'auto';
                                    }

                                    return elementWidth + 'px';
                                }

                                if (method == 'style') {
                                    var style = $element.attr('style');

                                    if (typeof(style) !== 'string') {
                                        return null;
                                    }

                                    var attrs = style.split(';');

                                    for (var i = 0, l = attrs.length; i < l; i = i + 1) {
                                        var attr = attrs[i].replace(/\s/g, '');
                                        var matches = attr.match(WIDTH);

                                        if (matches !== null && matches.length >= 1) {
                                            return matches[1];
                                        }
                                    }

                                    return null;
                                }

                                if (method == 'computedstyle') {
                                    var computedStyle = window.getComputedStyle($element[0]);

                                    return computedStyle.width;
                                }

                                return method;
                            };

                            Select2.prototype._bindAdapters = function () {
                                this.dataAdapter.bind(this, this.$container);
                                this.selection.bind(this, this.$container);

                                this.dropdown.bind(this, this.$container);
                                this.results.bind(this, this.$container);
                            };

                            Select2.prototype._registerDomEvents = function () {
                                var self = this;

                                this.$element.on('change.select2', function () {
                                    self.dataAdapter.current(function (data) {
                                        self.trigger('selection:update', {
                                            data: data
                                        });
                                    });
                                });

                                this.$element.on('focus.select2', function (evt) {
                                    self.trigger('focus', evt);
                                });

                                this._syncA = Utils.bind(this._syncAttributes, this);
                                this._syncS = Utils.bind(this._syncSubtree, this);

                                if (this.$element[0].attachEvent) {
                                    this.$element[0].attachEvent('onpropertychange', this._syncA);
                                }

                                var observer = window.MutationObserver ||
                                    window.WebKitMutationObserver ||
                                    window.MozMutationObserver
                                ;

                                if (observer != null) {
                                    this._observer = new observer(function (mutations) {
                                        self._syncA();
                                        self._syncS(null, mutations);
                                    });
                                    this._observer.observe(this.$element[0], {
                                        attributes: true,
                                        childList: true,
                                        subtree: false
                                    });
                                } else if (this.$element[0].addEventListener) {
                                    this.$element[0].addEventListener(
                                        'DOMAttrModified',
                                        self._syncA,
                                        false
                                    );
                                    this.$element[0].addEventListener(
                                        'DOMNodeInserted',
                                        self._syncS,
                                        false
                                    );
                                    this.$element[0].addEventListener(
                                        'DOMNodeRemoved',
                                        self._syncS,
                                        false
                                    );
                                }
                            };

                            Select2.prototype._registerDataEvents = function () {
                                var self = this;

                                this.dataAdapter.on('*', function (name, params) {
                                    self.trigger(name, params);
                                });
                            };

                            Select2.prototype._registerSelectionEvents = function () {
                                var self = this;
                                var nonRelayEvents = ['toggle', 'focus'];

                                this.selection.on('toggle', function () {
                                    self.toggleDropdown();
                                });

                                this.selection.on('focus', function (params) {
                                    self.focus(params);
                                });

                                this.selection.on('*', function (name, params) {
                                    if ($.inArray(name, nonRelayEvents) !== -1) {
                                        return;
                                    }

                                    self.trigger(name, params);
                                });
                            };

                            Select2.prototype._registerDropdownEvents = function () {
                                var self = this;

                                this.dropdown.on('*', function (name, params) {
                                    self.trigger(name, params);
                                });
                            };

                            Select2.prototype._registerResultsEvents = function () {
                                var self = this;

                                this.results.on('*', function (name, params) {
                                    self.trigger(name, params);
                                });
                            };

                            Select2.prototype._registerEvents = function () {
                                var self = this;

                                this.on('open', function () {
                                    self.$container.addClass('select2-container--open');
                                });

                                this.on('close', function () {
                                    self.$container.removeClass('select2-container--open');
                                });

                                this.on('enable', function () {
                                    self.$container.removeClass('select2-container--disabled');
                                });

                                this.on('disable', function () {
                                    self.$container.addClass('select2-container--disabled');
                                });

                                this.on('blur', function () {
                                    self.$container.removeClass('select2-container--focus');
                                });

                                this.on('query', function (params) {
                                    if (!self.isOpen()) {
                                        self.trigger('open', {});
                                    }

                                    this.dataAdapter.query(params, function (data) {
                                        self.trigger('results:all', {
                                            data: data,
                                            query: params
                                        });
                                    });
                                });

                                this.on('query:append', function (params) {
                                    this.dataAdapter.query(params, function (data) {
                                        self.trigger('results:append', {
                                            data: data,
                                            query: params
                                        });
                                    });
                                });

                                this.on('keypress', function (evt) {
                                    var key = evt.which;

                                    if (self.isOpen()) {
                                        if (key === KEYS.ESC || key === KEYS.TAB ||
                                            (key === KEYS.UP && evt.altKey)) {
                                            self.close(evt);

                                            evt.preventDefault();
                                        } else if (key === KEYS.ENTER) {
                                            self.trigger('results:select', {});

                                            evt.preventDefault();
                                        } else if ((key === KEYS.SPACE && evt.ctrlKey)) {
                                            self.trigger('results:toggle', {});

                                            evt.preventDefault();
                                        } else if (key === KEYS.UP) {
                                            self.trigger('results:previous', {});

                                            evt.preventDefault();
                                        } else if (key === KEYS.DOWN) {
                                            self.trigger('results:next', {});

                                            evt.preventDefault();
                                        }
                                    } else {
                                        if (key === KEYS.ENTER || key === KEYS.SPACE ||
                                            (key === KEYS.DOWN && evt.altKey)) {
                                            self.open();

                                            evt.preventDefault();
                                        }
                                    }
                                });
                            };

                            Select2.prototype._syncAttributes = function () {
                                this.options.set('disabled', this.$element.prop('disabled'));

                                if (this.isDisabled()) {
                                    if (this.isOpen()) {
                                        this.close();
                                    }

                                    this.trigger('disable', {});
                                } else {
                                    this.trigger('enable', {});
                                }
                            };

                            Select2.prototype._isChangeMutation = function (evt, mutations) {
                                var changed = false;
                                var self = this;

                                // Ignore any mutation events raised for elements that aren't options or
                                // optgroups. This handles the case when the select element is destroyed
                                if (
                                    evt && evt.target && (
                                        evt.target.nodeName !== 'OPTION' && evt.target.nodeName !== 'OPTGROUP'
                                    )
                                ) {
                                    return;
                                }

                                if (!mutations) {
                                    // If mutation events aren't supported, then we can only assume that the
                                    // change affected the selections
                                    changed = true;
                                } else if (mutations.addedNodes && mutations.addedNodes.length > 0) {
                                    for (var n = 0; n < mutations.addedNodes.length; n++) {
                                        var node = mutations.addedNodes[n];

                                        if (node.selected) {
                                            changed = true;
                                        }
                                    }
                                } else if (mutations.removedNodes && mutations.removedNodes.length > 0) {
                                    changed = true;
                                } else if ($.isArray(mutations)) {
                                    $.each(mutations, function(evt, mutation) {
                                        if (self._isChangeMutation(evt, mutation)) {
                                            // We've found a change mutation.
                                            // Let's escape from the loop and continue
                                            changed = true;
                                            return false;
                                        }
                                    });
                                }
                                return changed;
                            };

                            Select2.prototype._syncSubtree = function (evt, mutations) {
                                var changed = this._isChangeMutation(evt, mutations);
                                var self = this;

                                // Only re-pull the data if we think there is a change
                                if (changed) {
                                    this.dataAdapter.current(function (currentData) {
                                        self.trigger('selection:update', {
                                            data: currentData
                                        });
                                    });
                                }
                            };

                            /**
                             * Override the trigger method to automatically trigger pre-events when
                             * there are events that can be prevented.
                             */
                            Select2.prototype.trigger = function (name, args) {
                                var actualTrigger = Select2.__super__.trigger;
                                var preTriggerMap = {
                                    'open': 'opening',
                                    'close': 'closing',
                                    'select': 'selecting',
                                    'unselect': 'unselecting',
                                    'clear': 'clearing'
                                };

                                if (args === undefined) {
                                    args = {};
                                }

                                if (name in preTriggerMap) {
                                    var preTriggerName = preTriggerMap[name];
                                    var preTriggerArgs = {
                                        prevented: false,
                                        name: name,
                                        args: args
                                    };

                                    actualTrigger.call(this, preTriggerName, preTriggerArgs);

                                    if (preTriggerArgs.prevented) {
                                        args.prevented = true;

                                        return;
                                    }
                                }

                                actualTrigger.call(this, name, args);
                            };

                            Select2.prototype.toggleDropdown = function () {
                                if (this.isDisabled()) {
                                    return;
                                }

                                if (this.isOpen()) {
                                    this.close();
                                } else {
                                    this.open();
                                }
                            };

                            Select2.prototype.open = function () {
                                if (this.isOpen()) {
                                    return;
                                }

                                if (this.isDisabled()) {
                                    return;
                                }

                                this.trigger('query', {});
                            };

                            Select2.prototype.close = function (evt) {
                                if (!this.isOpen()) {
                                    return;
                                }

                                this.trigger('close', { originalEvent : evt });
                            };

                            /**
                             * Helper method to abstract the "enabled" (not "disabled") state of this
                             * object.
                             *
                             * @return {true} if the instance is not disabled.
                             * @return {false} if the instance is disabled.
                             */
                            Select2.prototype.isEnabled = function () {
                                return !this.isDisabled();
                            };

                            /**
                             * Helper method to abstract the "disabled" state of this object.
                             *
                             * @return {true} if the disabled option is true.
                             * @return {false} if the disabled option is false.
                             */
                            Select2.prototype.isDisabled = function () {
                                return this.options.get('disabled');
                            };

                            Select2.prototype.isOpen = function () {
                                return this.$container.hasClass('select2-container--open');
                            };

                            Select2.prototype.hasFocus = function () {
                                return this.$container.hasClass('select2-container--focus');
                            };

                            Select2.prototype.focus = function (data) {
                                // No need to re-trigger focus events if we are already focused
                                if (this.hasFocus()) {
                                    return;
                                }

                                this.$container.addClass('select2-container--focus');
                                this.trigger('focus', {});
                            };

                            Select2.prototype.enable = function (args) {
                                if (this.options.get('debug') && window.console && console.warn) {
                                    console.warn(
                                        'Select2: The `select2("enable")` method has been deprecated and will' +
                                        ' be removed in later Select2 versions. Use $element.prop("disabled")' +
                                        ' instead.'
                                    );
                                }

                                if (args == null || args.length === 0) {
                                    args = [true];
                                }

                                var disabled = !args[0];

                                this.$element.prop('disabled', disabled);
                            };

                            Select2.prototype.data = function () {
                                if (this.options.get('debug') &&
                                    arguments.length > 0 && window.console && console.warn) {
                                    console.warn(
                                        'Select2: Data can no longer be set using `select2("data")`. You ' +
                                        'should consider setting the value instead using `$element.val()`.'
                                    );
                                }

                                var data = [];

                                this.dataAdapter.current(function (currentData) {
                                    data = currentData;
                                });

                                return data;
                            };

                            Select2.prototype.val = function (args) {
                                if (this.options.get('debug') && window.console && console.warn) {
                                    console.warn(
                                        'Select2: The `select2("val")` method has been deprecated and will be' +
                                        ' removed in later Select2 versions. Use $element.val() instead.'
                                    );
                                }

                                if (args == null || args.length === 0) {
                                    return this.$element.val();
                                }

                                var newVal = args[0];

                                if ($.isArray(newVal)) {
                                    newVal = $.map(newVal, function (obj) {
                                        return obj.toString();
                                    });
                                }

                                this.$element.val(newVal).trigger('input').trigger('change');
                            };

                            Select2.prototype.destroy = function () {
                                this.$container.remove();

                                if (this.$element[0].detachEvent) {
                                    this.$element[0].detachEvent('onpropertychange', this._syncA);
                                }

                                if (this._observer != null) {
                                    this._observer.disconnect();
                                    this._observer = null;
                                } else if (this.$element[0].removeEventListener) {
                                    this.$element[0]
                                        .removeEventListener('DOMAttrModified', this._syncA, false);
                                    this.$element[0]
                                        .removeEventListener('DOMNodeInserted', this._syncS, false);
                                    this.$element[0]
                                        .removeEventListener('DOMNodeRemoved', this._syncS, false);
                                }

                                this._syncA = null;
                                this._syncS = null;

                                this.$element.off('.select2');
                                this.$element.attr('tabindex',
                                    Utils.GetData(this.$element[0], 'old-tabindex'));

                                this.$element.removeClass('select2-hidden-accessible');
                                this.$element.attr('aria-hidden', 'false');
                                Utils.RemoveData(this.$element[0]);
                                this.$element.removeData('select2');

                                this.dataAdapter.destroy();
                                this.selection.destroy();
                                this.dropdown.destroy();
                                this.results.destroy();

                                this.dataAdapter = null;
                                this.selection = null;
                                this.dropdown = null;
                                this.results = null;
                            };

                            Select2.prototype.render = function () {
                                var $container = $(
                                    '<span class="select2 select2-container">' +
                                    '<span class="selection"></span>' +
                                    '<span class="dropdown-wrapper" aria-hidden="true"></span>' +
                                    '</span>'
                                );

                                $container.attr('dir', this.options.get('dir'));

                                this.$container = $container;

                                this.$container.addClass('select2-container--' + this.options.get('theme'));

                                Utils.StoreData($container[0], 'element', this.$element);

                                return $container;
                            };

                            return Select2;
                        });

                        S2.define('jquery-mousewheel',[
                            'jquery'
                        ], function ($) {
                            // Used to shim jQuery.mousewheel for non-full builds.
                            return $;
                        });

                        S2.define('jquery.select2',[
                            'jquery',
                            'jquery-mousewheel',

                            './select2/core',
                            './select2/defaults',
                            './select2/utils'
                        ], function ($, _, Select2, Defaults, Utils) {
                            if ($.fn.select2 == null) {
                                // All methods that should return the element
                                var thisMethods = ['open', 'close', 'destroy'];

                                $.fn.select2 = function (options) {
                                    options = options || {};

                                    if (typeof options === 'object') {
                                        this.each(function () {
                                            var instanceOptions = $.extend(true, {}, options);

                                            var instance = new Select2($(this), instanceOptions);
                                        });

                                        return this;
                                    } else if (typeof options === 'string') {
                                        var ret;
                                        var args = Array.prototype.slice.call(arguments, 1);

                                        this.each(function () {
                                            var instance = Utils.GetData(this, 'select2');

                                            if (instance == null && window.console && console.error) {
                                                console.error(
                                                    'The select2(\'' + options + '\') method was called on an ' +
                                                    'element that is not using Select2.'
                                                );
                                            }

                                            ret = instance[options].apply(instance, args);
                                        });

                                        // Check if we should be returning `this`
                                        if ($.inArray(options, thisMethods) > -1) {
                                            return this;
                                        }

                                        return ret;
                                    } else {
                                        throw new Error('Invalid arguments for Select2: ' + options);
                                    }
                                };
                            }

                            if ($.fn.select2.defaults == null) {
                                $.fn.select2.defaults = Defaults;
                            }

                            return Select2;
                        });

                        // Return the AMD loader configuration so it can be used outside of this file
                        return {
                            define: S2.define,
                            require: S2.require
                        };
                    }());

                    // Autoload the jQuery bindings
                    // We know that all of the modules exist above this, so we're safe
                    var select2 = S2.require('jquery.select2');

                    // Hold the AMD module references on the jQuery function that was just loaded
                    // This allows Select2 to use the internal loader outside of this file, such
                    // as in the language files.
                    jQuery.fn.select2.amd = S2;

                    // Return the Select2 instance for anyone who is importing it.
                    return select2;
                }));

                /* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

            /***/ }),

        /***/ "./node_modules/slick-carousel/slick/slick.js":
        /*!****************************************************!*\
  !*** ./node_modules/slick-carousel/slick/slick.js ***!
  \****************************************************/
        /*! no static exports found */
        /***/ (function(module, exports, __webpack_require__) {

            var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
     _ _      _       _
 ___| (_) ___| | __  (_)___
/ __| | |/ __| |/ /  | / __|
\__ \ | | (__|   < _ | \__ \
|___/_|_|\___|_|\_(_)/ |___/
                   |__/

 Version: 1.8.1
  Author: Ken Wheeler
 Website: http://kenwheeler.github.io
    Docs: http://kenwheeler.github.io/slick
    Repo: http://github.com/kenwheeler/slick
  Issues: http://github.com/kenwheeler/slick/issues

 */
            /* global window, document, define, jQuery, setInterval, clearInterval */
            ;(function(factory) {
                'use strict';
                if (true) {
                    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                        __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                            (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                } else {}

            }(function($) {
                'use strict';
                var Slick = window.Slick || {};

                Slick = (function() {

                    var instanceUid = 0;

                    function Slick(element, settings) {

                        var _ = this, dataSettings;

                        _.defaults = {
                            accessibility: true,
                            adaptiveHeight: false,
                            appendArrows: $(element),
                            appendDots: $(element),
                            arrows: true,
                            asNavFor: null,
                            prevArrow: '<button class="slick-prev" aria-label="Previous" type="button">Previous</button>',
                            nextArrow: '<button class="slick-next" aria-label="Next" type="button">Next</button>',
                            autoplay: false,
                            autoplaySpeed: 3000,
                            centerMode: false,
                            centerPadding: '50px',
                            cssEase: 'ease',
                            customPaging: function(slider, i) {
                                return $('<button type="button" />').text(i + 1);
                            },
                            dots: false,
                            dotsClass: 'slick-dots',
                            draggable: true,
                            easing: 'linear',
                            edgeFriction: 0.35,
                            fade: false,
                            focusOnSelect: false,
                            focusOnChange: false,
                            infinite: true,
                            initialSlide: 0,
                            lazyLoad: 'ondemand',
                            mobileFirst: false,
                            pauseOnHover: true,
                            pauseOnFocus: true,
                            pauseOnDotsHover: false,
                            respondTo: 'window',
                            responsive: null,
                            rows: 1,
                            rtl: false,
                            slide: '',
                            slidesPerRow: 1,
                            slidesToShow: 1,
                            slidesToScroll: 1,
                            speed: 500,
                            swipe: true,
                            swipeToSlide: false,
                            touchMove: true,
                            touchThreshold: 5,
                            useCSS: true,
                            useTransform: true,
                            variableWidth: false,
                            vertical: false,
                            verticalSwiping: false,
                            waitForAnimate: true,
                            zIndex: 1000
                        };

                        _.initials = {
                            animating: false,
                            dragging: false,
                            autoPlayTimer: null,
                            currentDirection: 0,
                            currentLeft: null,
                            currentSlide: 0,
                            direction: 1,
                            $dots: null,
                            listWidth: null,
                            listHeight: null,
                            loadIndex: 0,
                            $nextArrow: null,
                            $prevArrow: null,
                            scrolling: false,
                            slideCount: null,
                            slideWidth: null,
                            $slideTrack: null,
                            $slides: null,
                            sliding: false,
                            slideOffset: 0,
                            swipeLeft: null,
                            swiping: false,
                            $list: null,
                            touchObject: {},
                            transformsEnabled: false,
                            unslicked: false
                        };

                        $.extend(_, _.initials);

                        _.activeBreakpoint = null;
                        _.animType = null;
                        _.animProp = null;
                        _.breakpoints = [];
                        _.breakpointSettings = [];
                        _.cssTransitions = false;
                        _.focussed = false;
                        _.interrupted = false;
                        _.hidden = 'hidden';
                        _.paused = true;
                        _.positionProp = null;
                        _.respondTo = null;
                        _.rowCount = 1;
                        _.shouldClick = true;
                        _.$slider = $(element);
                        _.$slidesCache = null;
                        _.transformType = null;
                        _.transitionType = null;
                        _.visibilityChange = 'visibilitychange';
                        _.windowWidth = 0;
                        _.windowTimer = null;

                        dataSettings = $(element).data('slick') || {};

                        _.options = $.extend({}, _.defaults, settings, dataSettings);

                        _.currentSlide = _.options.initialSlide;

                        _.originalSettings = _.options;

                        if (typeof document.mozHidden !== 'undefined') {
                            _.hidden = 'mozHidden';
                            _.visibilityChange = 'mozvisibilitychange';
                        } else if (typeof document.webkitHidden !== 'undefined') {
                            _.hidden = 'webkitHidden';
                            _.visibilityChange = 'webkitvisibilitychange';
                        }

                        _.autoPlay = $.proxy(_.autoPlay, _);
                        _.autoPlayClear = $.proxy(_.autoPlayClear, _);
                        _.autoPlayIterator = $.proxy(_.autoPlayIterator, _);
                        _.changeSlide = $.proxy(_.changeSlide, _);
                        _.clickHandler = $.proxy(_.clickHandler, _);
                        _.selectHandler = $.proxy(_.selectHandler, _);
                        _.setPosition = $.proxy(_.setPosition, _);
                        _.swipeHandler = $.proxy(_.swipeHandler, _);
                        _.dragHandler = $.proxy(_.dragHandler, _);
                        _.keyHandler = $.proxy(_.keyHandler, _);

                        _.instanceUid = instanceUid++;

                        // A simple way to check for HTML strings
                        // Strict HTML recognition (must start with <)
                        // Extracted from jQuery v1.11 source
                        _.htmlExpr = /^(?:\s*(<[\w\W]+>)[^>]*)$/;


                        _.registerBreakpoints();
                        _.init(true);

                    }

                    return Slick;

                }());

                Slick.prototype.activateADA = function() {
                    var _ = this;

                    _.$slideTrack.find('.slick-active').attr({
                        'aria-hidden': 'false'
                    }).find('a, input, button, select').attr({
                        'tabindex': '0'
                    });

                };

                Slick.prototype.addSlide = Slick.prototype.slickAdd = function(markup, index, addBefore) {

                    var _ = this;

                    if (typeof(index) === 'boolean') {
                        addBefore = index;
                        index = null;
                    } else if (index < 0 || (index >= _.slideCount)) {
                        return false;
                    }

                    _.unload();

                    if (typeof(index) === 'number') {
                        if (index === 0 && _.$slides.length === 0) {
                            $(markup).appendTo(_.$slideTrack);
                        } else if (addBefore) {
                            $(markup).insertBefore(_.$slides.eq(index));
                        } else {
                            $(markup).insertAfter(_.$slides.eq(index));
                        }
                    } else {
                        if (addBefore === true) {
                            $(markup).prependTo(_.$slideTrack);
                        } else {
                            $(markup).appendTo(_.$slideTrack);
                        }
                    }

                    _.$slides = _.$slideTrack.children(this.options.slide);

                    _.$slideTrack.children(this.options.slide).detach();

                    _.$slideTrack.append(_.$slides);

                    _.$slides.each(function(index, element) {
                        $(element).attr('data-slick-index', index);
                    });

                    _.$slidesCache = _.$slides;

                    _.reinit();

                };

                Slick.prototype.animateHeight = function() {
                    var _ = this;
                    if (_.options.slidesToShow === 1 && _.options.adaptiveHeight === true && _.options.vertical === false) {
                        var targetHeight = _.$slides.eq(_.currentSlide).outerHeight(true);
                        _.$list.animate({
                            height: targetHeight
                        }, _.options.speed);
                    }
                };

                Slick.prototype.animateSlide = function(targetLeft, callback) {

                    var animProps = {},
                        _ = this;

                    _.animateHeight();

                    if (_.options.rtl === true && _.options.vertical === false) {
                        targetLeft = -targetLeft;
                    }
                    if (_.transformsEnabled === false) {
                        if (_.options.vertical === false) {
                            _.$slideTrack.animate({
                                left: targetLeft
                            }, _.options.speed, _.options.easing, callback);
                        } else {
                            _.$slideTrack.animate({
                                top: targetLeft
                            }, _.options.speed, _.options.easing, callback);
                        }

                    } else {

                        if (_.cssTransitions === false) {
                            if (_.options.rtl === true) {
                                _.currentLeft = -(_.currentLeft);
                            }
                            $({
                                animStart: _.currentLeft
                            }).animate({
                                animStart: targetLeft
                            }, {
                                duration: _.options.speed,
                                easing: _.options.easing,
                                step: function(now) {
                                    now = Math.ceil(now);
                                    if (_.options.vertical === false) {
                                        animProps[_.animType] = 'translate(' +
                                            now + 'px, 0px)';
                                        _.$slideTrack.css(animProps);
                                    } else {
                                        animProps[_.animType] = 'translate(0px,' +
                                            now + 'px)';
                                        _.$slideTrack.css(animProps);
                                    }
                                },
                                complete: function() {
                                    if (callback) {
                                        callback.call();
                                    }
                                }
                            });

                        } else {

                            _.applyTransition();
                            targetLeft = Math.ceil(targetLeft);

                            if (_.options.vertical === false) {
                                animProps[_.animType] = 'translate3d(' + targetLeft + 'px, 0px, 0px)';
                            } else {
                                animProps[_.animType] = 'translate3d(0px,' + targetLeft + 'px, 0px)';
                            }
                            _.$slideTrack.css(animProps);

                            if (callback) {
                                setTimeout(function() {

                                    _.disableTransition();

                                    callback.call();
                                }, _.options.speed);
                            }

                        }

                    }

                };

                Slick.prototype.getNavTarget = function() {

                    var _ = this,
                        asNavFor = _.options.asNavFor;

                    if ( asNavFor && asNavFor !== null ) {
                        asNavFor = $(asNavFor).not(_.$slider);
                    }

                    return asNavFor;

                };

                Slick.prototype.asNavFor = function(index) {

                    var _ = this,
                        asNavFor = _.getNavTarget();

                    if ( asNavFor !== null && typeof asNavFor === 'object' ) {
                        asNavFor.each(function() {
                            var target = $(this).slick('getSlick');
                            if(!target.unslicked) {
                                target.slideHandler(index, true);
                            }
                        });
                    }

                };

                Slick.prototype.applyTransition = function(slide) {

                    var _ = this,
                        transition = {};

                    if (_.options.fade === false) {
                        transition[_.transitionType] = _.transformType + ' ' + _.options.speed + 'ms ' + _.options.cssEase;
                    } else {
                        transition[_.transitionType] = 'opacity ' + _.options.speed + 'ms ' + _.options.cssEase;
                    }

                    if (_.options.fade === false) {
                        _.$slideTrack.css(transition);
                    } else {
                        _.$slides.eq(slide).css(transition);
                    }

                };

                Slick.prototype.autoPlay = function() {

                    var _ = this;

                    _.autoPlayClear();

                    if ( _.slideCount > _.options.slidesToShow ) {
                        _.autoPlayTimer = setInterval( _.autoPlayIterator, _.options.autoplaySpeed );
                    }

                };

                Slick.prototype.autoPlayClear = function() {

                    var _ = this;

                    if (_.autoPlayTimer) {
                        clearInterval(_.autoPlayTimer);
                    }

                };

                Slick.prototype.autoPlayIterator = function() {

                    var _ = this,
                        slideTo = _.currentSlide + _.options.slidesToScroll;

                    if ( !_.paused && !_.interrupted && !_.focussed ) {

                        if ( _.options.infinite === false ) {

                            if ( _.direction === 1 && ( _.currentSlide + 1 ) === ( _.slideCount - 1 )) {
                                _.direction = 0;
                            }

                            else if ( _.direction === 0 ) {

                                slideTo = _.currentSlide - _.options.slidesToScroll;

                                if ( _.currentSlide - 1 === 0 ) {
                                    _.direction = 1;
                                }

                            }

                        }

                        _.slideHandler( slideTo );

                    }

                };

                Slick.prototype.buildArrows = function() {

                    var _ = this;

                    if (_.options.arrows === true ) {

                        _.$prevArrow = $(_.options.prevArrow).addClass('slick-arrow');
                        _.$nextArrow = $(_.options.nextArrow).addClass('slick-arrow');

                        if( _.slideCount > _.options.slidesToShow ) {

                            _.$prevArrow.removeClass('slick-hidden').removeAttr('aria-hidden tabindex');
                            _.$nextArrow.removeClass('slick-hidden').removeAttr('aria-hidden tabindex');

                            if (_.htmlExpr.test(_.options.prevArrow)) {
                                _.$prevArrow.prependTo(_.options.appendArrows);
                            }

                            if (_.htmlExpr.test(_.options.nextArrow)) {
                                _.$nextArrow.appendTo(_.options.appendArrows);
                            }

                            if (_.options.infinite !== true) {
                                _.$prevArrow
                                    .addClass('slick-disabled')
                                    .attr('aria-disabled', 'true');
                            }

                        } else {

                            _.$prevArrow.add( _.$nextArrow )

                                .addClass('slick-hidden')
                                .attr({
                                    'aria-disabled': 'true',
                                    'tabindex': '-1'
                                });

                        }

                    }

                };

                Slick.prototype.buildDots = function() {

                    var _ = this,
                        i, dot;

                    if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {

                        _.$slider.addClass('slick-dotted');

                        dot = $('<ul />').addClass(_.options.dotsClass);

                        for (i = 0; i <= _.getDotCount(); i += 1) {
                            dot.append($('<li />').append(_.options.customPaging.call(this, _, i)));
                        }

                        _.$dots = dot.appendTo(_.options.appendDots);

                        _.$dots.find('li').first().addClass('slick-active');

                    }

                };

                Slick.prototype.buildOut = function() {

                    var _ = this;

                    _.$slides =
                        _.$slider
                            .children( _.options.slide + ':not(.slick-cloned)')
                            .addClass('slick-slide');

                    _.slideCount = _.$slides.length;

                    _.$slides.each(function(index, element) {
                        $(element)
                            .attr('data-slick-index', index)
                            .data('originalStyling', $(element).attr('style') || '');
                    });

                    _.$slider.addClass('slick-slider');

                    _.$slideTrack = (_.slideCount === 0) ?
                        $('<div class="slick-track"/>').appendTo(_.$slider) :
                        _.$slides.wrapAll('<div class="slick-track"/>').parent();

                    _.$list = _.$slideTrack.wrap(
                        '<div class="slick-list"/>').parent();
                    _.$slideTrack.css('opacity', 0);

                    if (_.options.centerMode === true || _.options.swipeToSlide === true) {
                        _.options.slidesToScroll = 1;
                    }

                    $('img[data-lazy]', _.$slider).not('[src]').addClass('slick-loading');

                    _.setupInfinite();

                    _.buildArrows();

                    _.buildDots();

                    _.updateDots();


                    _.setSlideClasses(typeof _.currentSlide === 'number' ? _.currentSlide : 0);

                    if (_.options.draggable === true) {
                        _.$list.addClass('draggable');
                    }

                };

                Slick.prototype.buildRows = function() {

                    var _ = this, a, b, c, newSlides, numOfSlides, originalSlides,slidesPerSection;

                    newSlides = document.createDocumentFragment();
                    originalSlides = _.$slider.children();

                    if(_.options.rows > 0) {

                        slidesPerSection = _.options.slidesPerRow * _.options.rows;
                        numOfSlides = Math.ceil(
                            originalSlides.length / slidesPerSection
                        );

                        for(a = 0; a < numOfSlides; a++){
                            var slide = document.createElement('div');
                            for(b = 0; b < _.options.rows; b++) {
                                var row = document.createElement('div');
                                for(c = 0; c < _.options.slidesPerRow; c++) {
                                    var target = (a * slidesPerSection + ((b * _.options.slidesPerRow) + c));
                                    if (originalSlides.get(target)) {
                                        row.appendChild(originalSlides.get(target));
                                    }
                                }
                                slide.appendChild(row);
                            }
                            newSlides.appendChild(slide);
                        }

                        _.$slider.empty().append(newSlides);
                        _.$slider.children().children().children()
                            .css({
                                'width':(100 / _.options.slidesPerRow) + '%',
                                'display': 'inline-block'
                            });

                    }

                };

                Slick.prototype.checkResponsive = function(initial, forceUpdate) {

                    var _ = this,
                        breakpoint, targetBreakpoint, respondToWidth, triggerBreakpoint = false;
                    var sliderWidth = _.$slider.width();
                    var windowWidth = window.innerWidth || $(window).width();

                    if (_.respondTo === 'window') {
                        respondToWidth = windowWidth;
                    } else if (_.respondTo === 'slider') {
                        respondToWidth = sliderWidth;
                    } else if (_.respondTo === 'min') {
                        respondToWidth = Math.min(windowWidth, sliderWidth);
                    }

                    if ( _.options.responsive &&
                        _.options.responsive.length &&
                        _.options.responsive !== null) {

                        targetBreakpoint = null;

                        for (breakpoint in _.breakpoints) {
                            if (_.breakpoints.hasOwnProperty(breakpoint)) {
                                if (_.originalSettings.mobileFirst === false) {
                                    if (respondToWidth < _.breakpoints[breakpoint]) {
                                        targetBreakpoint = _.breakpoints[breakpoint];
                                    }
                                } else {
                                    if (respondToWidth > _.breakpoints[breakpoint]) {
                                        targetBreakpoint = _.breakpoints[breakpoint];
                                    }
                                }
                            }
                        }

                        if (targetBreakpoint !== null) {
                            if (_.activeBreakpoint !== null) {
                                if (targetBreakpoint !== _.activeBreakpoint || forceUpdate) {
                                    _.activeBreakpoint =
                                        targetBreakpoint;
                                    if (_.breakpointSettings[targetBreakpoint] === 'unslick') {
                                        _.unslick(targetBreakpoint);
                                    } else {
                                        _.options = $.extend({}, _.originalSettings,
                                            _.breakpointSettings[
                                                targetBreakpoint]);
                                        if (initial === true) {
                                            _.currentSlide = _.options.initialSlide;
                                        }
                                        _.refresh(initial);
                                    }
                                    triggerBreakpoint = targetBreakpoint;
                                }
                            } else {
                                _.activeBreakpoint = targetBreakpoint;
                                if (_.breakpointSettings[targetBreakpoint] === 'unslick') {
                                    _.unslick(targetBreakpoint);
                                } else {
                                    _.options = $.extend({}, _.originalSettings,
                                        _.breakpointSettings[
                                            targetBreakpoint]);
                                    if (initial === true) {
                                        _.currentSlide = _.options.initialSlide;
                                    }
                                    _.refresh(initial);
                                }
                                triggerBreakpoint = targetBreakpoint;
                            }
                        } else {
                            if (_.activeBreakpoint !== null) {
                                _.activeBreakpoint = null;
                                _.options = _.originalSettings;
                                if (initial === true) {
                                    _.currentSlide = _.options.initialSlide;
                                }
                                _.refresh(initial);
                                triggerBreakpoint = targetBreakpoint;
                            }
                        }

                        // only trigger breakpoints during an actual break. not on initialize.
                        if( !initial && triggerBreakpoint !== false ) {
                            _.$slider.trigger('breakpoint', [_, triggerBreakpoint]);
                        }
                    }

                };

                Slick.prototype.changeSlide = function(event, dontAnimate) {

                    var _ = this,
                        $target = $(event.currentTarget),
                        indexOffset, slideOffset, unevenOffset;

                    // If target is a link, prevent default action.
                    if($target.is('a')) {
                        event.preventDefault();
                    }

                    // If target is not the <li> element (ie: a child), find the <li>.
                    if(!$target.is('li')) {
                        $target = $target.closest('li');
                    }

                    unevenOffset = (_.slideCount % _.options.slidesToScroll !== 0);
                    indexOffset = unevenOffset ? 0 : (_.slideCount - _.currentSlide) % _.options.slidesToScroll;

                    switch (event.data.message) {

                        case 'previous':
                            slideOffset = indexOffset === 0 ? _.options.slidesToScroll : _.options.slidesToShow - indexOffset;
                            if (_.slideCount > _.options.slidesToShow) {
                                _.slideHandler(_.currentSlide - slideOffset, false, dontAnimate);
                            }
                            break;

                        case 'next':
                            slideOffset = indexOffset === 0 ? _.options.slidesToScroll : indexOffset;
                            if (_.slideCount > _.options.slidesToShow) {
                                _.slideHandler(_.currentSlide + slideOffset, false, dontAnimate);
                            }
                            break;

                        case 'index':
                            var index = event.data.index === 0 ? 0 :
                                event.data.index || $target.index() * _.options.slidesToScroll;

                            _.slideHandler(_.checkNavigable(index), false, dontAnimate);
                            $target.children().trigger('focus');
                            break;

                        default:
                            return;
                    }

                };

                Slick.prototype.checkNavigable = function(index) {

                    var _ = this,
                        navigables, prevNavigable;

                    navigables = _.getNavigableIndexes();
                    prevNavigable = 0;
                    if (index > navigables[navigables.length - 1]) {
                        index = navigables[navigables.length - 1];
                    } else {
                        for (var n in navigables) {
                            if (index < navigables[n]) {
                                index = prevNavigable;
                                break;
                            }
                            prevNavigable = navigables[n];
                        }
                    }

                    return index;
                };

                Slick.prototype.cleanUpEvents = function() {

                    var _ = this;

                    if (_.options.dots && _.$dots !== null) {

                        $('li', _.$dots)
                            .off('click.slick', _.changeSlide)
                            .off('mouseenter.slick', $.proxy(_.interrupt, _, true))
                            .off('mouseleave.slick', $.proxy(_.interrupt, _, false));

                        if (_.options.accessibility === true) {
                            _.$dots.off('keydown.slick', _.keyHandler);
                        }
                    }

                    _.$slider.off('focus.slick blur.slick');

                    if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {
                        _.$prevArrow && _.$prevArrow.off('click.slick', _.changeSlide);
                        _.$nextArrow && _.$nextArrow.off('click.slick', _.changeSlide);

                        if (_.options.accessibility === true) {
                            _.$prevArrow && _.$prevArrow.off('keydown.slick', _.keyHandler);
                            _.$nextArrow && _.$nextArrow.off('keydown.slick', _.keyHandler);
                        }
                    }

                    _.$list.off('touchstart.slick mousedown.slick', _.swipeHandler);
                    _.$list.off('touchmove.slick mousemove.slick', _.swipeHandler);
                    _.$list.off('touchend.slick mouseup.slick', _.swipeHandler);
                    _.$list.off('touchcancel.slick mouseleave.slick', _.swipeHandler);

                    _.$list.off('click.slick', _.clickHandler);

                    $(document).off(_.visibilityChange, _.visibility);

                    _.cleanUpSlideEvents();

                    if (_.options.accessibility === true) {
                        _.$list.off('keydown.slick', _.keyHandler);
                    }

                    if (_.options.focusOnSelect === true) {
                        $(_.$slideTrack).children().off('click.slick', _.selectHandler);
                    }

                    $(window).off('orientationchange.slick.slick-' + _.instanceUid, _.orientationChange);

                    $(window).off('resize.slick.slick-' + _.instanceUid, _.resize);

                    $('[draggable!=true]', _.$slideTrack).off('dragstart', _.preventDefault);

                    $(window).off('load.slick.slick-' + _.instanceUid, _.setPosition);

                };

                Slick.prototype.cleanUpSlideEvents = function() {

                    var _ = this;

                    _.$list.off('mouseenter.slick', $.proxy(_.interrupt, _, true));
                    _.$list.off('mouseleave.slick', $.proxy(_.interrupt, _, false));

                };

                Slick.prototype.cleanUpRows = function() {

                    var _ = this, originalSlides;

                    if(_.options.rows > 0) {
                        originalSlides = _.$slides.children().children();
                        originalSlides.removeAttr('style');
                        _.$slider.empty().append(originalSlides);
                    }

                };

                Slick.prototype.clickHandler = function(event) {

                    var _ = this;

                    if (_.shouldClick === false) {
                        event.stopImmediatePropagation();
                        event.stopPropagation();
                        event.preventDefault();
                    }

                };

                Slick.prototype.destroy = function(refresh) {

                    var _ = this;

                    _.autoPlayClear();

                    _.touchObject = {};

                    _.cleanUpEvents();

                    $('.slick-cloned', _.$slider).detach();

                    if (_.$dots) {
                        _.$dots.remove();
                    }

                    if ( _.$prevArrow && _.$prevArrow.length ) {

                        _.$prevArrow
                            .removeClass('slick-disabled slick-arrow slick-hidden')
                            .removeAttr('aria-hidden aria-disabled tabindex')
                            .css('display','');

                        if ( _.htmlExpr.test( _.options.prevArrow )) {
                            _.$prevArrow.remove();
                        }
                    }

                    if ( _.$nextArrow && _.$nextArrow.length ) {

                        _.$nextArrow
                            .removeClass('slick-disabled slick-arrow slick-hidden')
                            .removeAttr('aria-hidden aria-disabled tabindex')
                            .css('display','');

                        if ( _.htmlExpr.test( _.options.nextArrow )) {
                            _.$nextArrow.remove();
                        }
                    }


                    if (_.$slides) {

                        _.$slides
                            .removeClass('slick-slide slick-active slick-center slick-visible slick-current')
                            .removeAttr('aria-hidden')
                            .removeAttr('data-slick-index')
                            .each(function(){
                                $(this).attr('style', $(this).data('originalStyling'));
                            });

                        _.$slideTrack.children(this.options.slide).detach();

                        _.$slideTrack.detach();

                        _.$list.detach();

                        _.$slider.append(_.$slides);
                    }

                    _.cleanUpRows();

                    _.$slider.removeClass('slick-slider');
                    _.$slider.removeClass('slick-initialized');
                    _.$slider.removeClass('slick-dotted');

                    _.unslicked = true;

                    if(!refresh) {
                        _.$slider.trigger('destroy', [_]);
                    }

                };

                Slick.prototype.disableTransition = function(slide) {

                    var _ = this,
                        transition = {};

                    transition[_.transitionType] = '';

                    if (_.options.fade === false) {
                        _.$slideTrack.css(transition);
                    } else {
                        _.$slides.eq(slide).css(transition);
                    }

                };

                Slick.prototype.fadeSlide = function(slideIndex, callback) {

                    var _ = this;

                    if (_.cssTransitions === false) {

                        _.$slides.eq(slideIndex).css({
                            zIndex: _.options.zIndex
                        });

                        _.$slides.eq(slideIndex).animate({
                            opacity: 1
                        }, _.options.speed, _.options.easing, callback);

                    } else {

                        _.applyTransition(slideIndex);

                        _.$slides.eq(slideIndex).css({
                            opacity: 1,
                            zIndex: _.options.zIndex
                        });

                        if (callback) {
                            setTimeout(function() {

                                _.disableTransition(slideIndex);

                                callback.call();
                            }, _.options.speed);
                        }

                    }

                };

                Slick.prototype.fadeSlideOut = function(slideIndex) {

                    var _ = this;

                    if (_.cssTransitions === false) {

                        _.$slides.eq(slideIndex).animate({
                            opacity: 0,
                            zIndex: _.options.zIndex - 2
                        }, _.options.speed, _.options.easing);

                    } else {

                        _.applyTransition(slideIndex);

                        _.$slides.eq(slideIndex).css({
                            opacity: 0,
                            zIndex: _.options.zIndex - 2
                        });

                    }

                };

                Slick.prototype.filterSlides = Slick.prototype.slickFilter = function(filter) {

                    var _ = this;

                    if (filter !== null) {

                        _.$slidesCache = _.$slides;

                        _.unload();

                        _.$slideTrack.children(this.options.slide).detach();

                        _.$slidesCache.filter(filter).appendTo(_.$slideTrack);

                        _.reinit();

                    }

                };

                Slick.prototype.focusHandler = function() {

                    var _ = this;

                    _.$slider
                        .off('focus.slick blur.slick')
                        .on('focus.slick blur.slick', '*', function(event) {

                            event.stopImmediatePropagation();
                            var $sf = $(this);

                            setTimeout(function() {

                                if( _.options.pauseOnFocus ) {
                                    _.focussed = $sf.is(':focus');
                                    _.autoPlay();
                                }

                            }, 0);

                        });
                };

                Slick.prototype.getCurrent = Slick.prototype.slickCurrentSlide = function() {

                    var _ = this;
                    return _.currentSlide;

                };

                Slick.prototype.getDotCount = function() {

                    var _ = this;

                    var breakPoint = 0;
                    var counter = 0;
                    var pagerQty = 0;

                    if (_.options.infinite === true) {
                        if (_.slideCount <= _.options.slidesToShow) {
                            ++pagerQty;
                        } else {
                            while (breakPoint < _.slideCount) {
                                ++pagerQty;
                                breakPoint = counter + _.options.slidesToScroll;
                                counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
                            }
                        }
                    } else if (_.options.centerMode === true) {
                        pagerQty = _.slideCount;
                    } else if(!_.options.asNavFor) {
                        pagerQty = 1 + Math.ceil((_.slideCount - _.options.slidesToShow) / _.options.slidesToScroll);
                    }else {
                        while (breakPoint < _.slideCount) {
                            ++pagerQty;
                            breakPoint = counter + _.options.slidesToScroll;
                            counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
                        }
                    }

                    return pagerQty - 1;

                };

                Slick.prototype.getLeft = function(slideIndex) {

                    var _ = this,
                        targetLeft,
                        verticalHeight,
                        verticalOffset = 0,
                        targetSlide,
                        coef;

                    _.slideOffset = 0;
                    verticalHeight = _.$slides.first().outerHeight(true);

                    if (_.options.infinite === true) {
                        if (_.slideCount > _.options.slidesToShow) {
                            _.slideOffset = (_.slideWidth * _.options.slidesToShow) * -1;
                            coef = -1

                            if (_.options.vertical === true && _.options.centerMode === true) {
                                if (_.options.slidesToShow === 2) {
                                    coef = -1.5;
                                } else if (_.options.slidesToShow === 1) {
                                    coef = -2
                                }
                            }
                            verticalOffset = (verticalHeight * _.options.slidesToShow) * coef;
                        }
                        if (_.slideCount % _.options.slidesToScroll !== 0) {
                            if (slideIndex + _.options.slidesToScroll > _.slideCount && _.slideCount > _.options.slidesToShow) {
                                if (slideIndex > _.slideCount) {
                                    _.slideOffset = ((_.options.slidesToShow - (slideIndex - _.slideCount)) * _.slideWidth) * -1;
                                    verticalOffset = ((_.options.slidesToShow - (slideIndex - _.slideCount)) * verticalHeight) * -1;
                                } else {
                                    _.slideOffset = ((_.slideCount % _.options.slidesToScroll) * _.slideWidth) * -1;
                                    verticalOffset = ((_.slideCount % _.options.slidesToScroll) * verticalHeight) * -1;
                                }
                            }
                        }
                    } else {
                        if (slideIndex + _.options.slidesToShow > _.slideCount) {
                            _.slideOffset = ((slideIndex + _.options.slidesToShow) - _.slideCount) * _.slideWidth;
                            verticalOffset = ((slideIndex + _.options.slidesToShow) - _.slideCount) * verticalHeight;
                        }
                    }

                    if (_.slideCount <= _.options.slidesToShow) {
                        _.slideOffset = 0;
                        verticalOffset = 0;
                    }

                    if (_.options.centerMode === true && _.slideCount <= _.options.slidesToShow) {
                        _.slideOffset = ((_.slideWidth * Math.floor(_.options.slidesToShow)) / 2) - ((_.slideWidth * _.slideCount) / 2);
                    } else if (_.options.centerMode === true && _.options.infinite === true) {
                        _.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2) - _.slideWidth;
                    } else if (_.options.centerMode === true) {
                        _.slideOffset = 0;
                        _.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2);
                    }

                    if (_.options.vertical === false) {
                        targetLeft = ((slideIndex * _.slideWidth) * -1) + _.slideOffset;
                    } else {
                        targetLeft = ((slideIndex * verticalHeight) * -1) + verticalOffset;
                    }

                    if (_.options.variableWidth === true) {

                        if (_.slideCount <= _.options.slidesToShow || _.options.infinite === false) {
                            targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex);
                        } else {
                            targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex + _.options.slidesToShow);
                        }

                        if (_.options.rtl === true) {
                            if (targetSlide[0]) {
                                targetLeft = (_.$slideTrack.width() - targetSlide[0].offsetLeft - targetSlide.width()) * -1;
                            } else {
                                targetLeft =  0;
                            }
                        } else {
                            targetLeft = targetSlide[0] ? targetSlide[0].offsetLeft * -1 : 0;
                        }

                        if (_.options.centerMode === true) {
                            if (_.slideCount <= _.options.slidesToShow || _.options.infinite === false) {
                                targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex);
                            } else {
                                targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex + _.options.slidesToShow + 1);
                            }

                            if (_.options.rtl === true) {
                                if (targetSlide[0]) {
                                    targetLeft = (_.$slideTrack.width() - targetSlide[0].offsetLeft - targetSlide.width()) * -1;
                                } else {
                                    targetLeft =  0;
                                }
                            } else {
                                targetLeft = targetSlide[0] ? targetSlide[0].offsetLeft * -1 : 0;
                            }

                            targetLeft += (_.$list.width() - targetSlide.outerWidth()) / 2;
                        }
                    }

                    return targetLeft;

                };

                Slick.prototype.getOption = Slick.prototype.slickGetOption = function(option) {

                    var _ = this;

                    return _.options[option];

                };

                Slick.prototype.getNavigableIndexes = function() {

                    var _ = this,
                        breakPoint = 0,
                        counter = 0,
                        indexes = [],
                        max;

                    if (_.options.infinite === false) {
                        max = _.slideCount;
                    } else {
                        breakPoint = _.options.slidesToScroll * -1;
                        counter = _.options.slidesToScroll * -1;
                        max = _.slideCount * 2;
                    }

                    while (breakPoint < max) {
                        indexes.push(breakPoint);
                        breakPoint = counter + _.options.slidesToScroll;
                        counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
                    }

                    return indexes;

                };

                Slick.prototype.getSlick = function() {

                    return this;

                };

                Slick.prototype.getSlideCount = function() {

                    var _ = this,
                        slidesTraversed, swipedSlide, centerOffset;

                    centerOffset = _.options.centerMode === true ? _.slideWidth * Math.floor(_.options.slidesToShow / 2) : 0;

                    if (_.options.swipeToSlide === true) {
                        _.$slideTrack.find('.slick-slide').each(function(index, slide) {
                            if (slide.offsetLeft - centerOffset + ($(slide).outerWidth() / 2) > (_.swipeLeft * -1)) {
                                swipedSlide = slide;
                                return false;
                            }
                        });

                        slidesTraversed = Math.abs($(swipedSlide).attr('data-slick-index') - _.currentSlide) || 1;

                        return slidesTraversed;

                    } else {
                        return _.options.slidesToScroll;
                    }

                };

                Slick.prototype.goTo = Slick.prototype.slickGoTo = function(slide, dontAnimate) {

                    var _ = this;

                    _.changeSlide({
                        data: {
                            message: 'index',
                            index: parseInt(slide)
                        }
                    }, dontAnimate);

                };

                Slick.prototype.init = function(creation) {

                    var _ = this;

                    if (!$(_.$slider).hasClass('slick-initialized')) {

                        $(_.$slider).addClass('slick-initialized');

                        _.buildRows();
                        _.buildOut();
                        _.setProps();
                        _.startLoad();
                        _.loadSlider();
                        _.initializeEvents();
                        _.updateArrows();
                        _.updateDots();
                        _.checkResponsive(true);
                        _.focusHandler();

                    }

                    if (creation) {
                        _.$slider.trigger('init', [_]);
                    }

                    if (_.options.accessibility === true) {
                        _.initADA();
                    }

                    if ( _.options.autoplay ) {

                        _.paused = false;
                        _.autoPlay();

                    }

                };

                Slick.prototype.initADA = function() {
                    var _ = this,
                        numDotGroups = Math.ceil(_.slideCount / _.options.slidesToShow),
                        tabControlIndexes = _.getNavigableIndexes().filter(function(val) {
                            return (val >= 0) && (val < _.slideCount);
                        });

                    _.$slides.add(_.$slideTrack.find('.slick-cloned')).attr({
                        'aria-hidden': 'true',
                        'tabindex': '-1'
                    }).find('a, input, button, select').attr({
                        'tabindex': '-1'
                    });

                    if (_.$dots !== null) {
                        _.$slides.not(_.$slideTrack.find('.slick-cloned')).each(function(i) {
                            var slideControlIndex = tabControlIndexes.indexOf(i);

                            $(this).attr({
                                'role': 'tabpanel',
                                'id': 'slick-slide' + _.instanceUid + i,
                                'tabindex': -1
                            });

                            if (slideControlIndex !== -1) {
                                var ariaButtonControl = 'slick-slide-control' + _.instanceUid + slideControlIndex
                                if ($('#' + ariaButtonControl).length) {
                                    $(this).attr({
                                        'aria-describedby': ariaButtonControl
                                    });
                                }
                            }
                        });

                        _.$dots.attr('role', 'tablist').find('li').each(function(i) {
                            var mappedSlideIndex = tabControlIndexes[i];

                            $(this).attr({
                                'role': 'presentation'
                            });

                            $(this).find('button').first().attr({
                                'role': 'tab',
                                'id': 'slick-slide-control' + _.instanceUid + i,
                                'aria-controls': 'slick-slide' + _.instanceUid + mappedSlideIndex,
                                'aria-label': (i + 1) + ' of ' + numDotGroups,
                                'aria-selected': null,
                                'tabindex': '-1'
                            });

                        }).eq(_.currentSlide).find('button').attr({
                            'aria-selected': 'true',
                            'tabindex': '0'
                        }).end();
                    }

                    for (var i=_.currentSlide, max=i+_.options.slidesToShow; i < max; i++) {
                        if (_.options.focusOnChange) {
                            _.$slides.eq(i).attr({'tabindex': '0'});
                        } else {
                            _.$slides.eq(i).removeAttr('tabindex');
                        }
                    }

                    _.activateADA();

                };

                Slick.prototype.initArrowEvents = function() {

                    var _ = this;

                    if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {
                        _.$prevArrow
                            .off('click.slick')
                            .on('click.slick', {
                                message: 'previous'
                            }, _.changeSlide);
                        _.$nextArrow
                            .off('click.slick')
                            .on('click.slick', {
                                message: 'next'
                            }, _.changeSlide);

                        if (_.options.accessibility === true) {
                            _.$prevArrow.on('keydown.slick', _.keyHandler);
                            _.$nextArrow.on('keydown.slick', _.keyHandler);
                        }
                    }

                };

                Slick.prototype.initDotEvents = function() {

                    var _ = this;

                    if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {
                        $('li', _.$dots).on('click.slick', {
                            message: 'index'
                        }, _.changeSlide);

                        if (_.options.accessibility === true) {
                            _.$dots.on('keydown.slick', _.keyHandler);
                        }
                    }

                    if (_.options.dots === true && _.options.pauseOnDotsHover === true && _.slideCount > _.options.slidesToShow) {

                        $('li', _.$dots)
                            .on('mouseenter.slick', $.proxy(_.interrupt, _, true))
                            .on('mouseleave.slick', $.proxy(_.interrupt, _, false));

                    }

                };

                Slick.prototype.initSlideEvents = function() {

                    var _ = this;

                    if ( _.options.pauseOnHover ) {

                        _.$list.on('mouseenter.slick', $.proxy(_.interrupt, _, true));
                        _.$list.on('mouseleave.slick', $.proxy(_.interrupt, _, false));

                    }

                };

                Slick.prototype.initializeEvents = function() {

                    var _ = this;

                    _.initArrowEvents();

                    _.initDotEvents();
                    _.initSlideEvents();

                    _.$list.on('touchstart.slick mousedown.slick', {
                        action: 'start'
                    }, _.swipeHandler);
                    _.$list.on('touchmove.slick mousemove.slick', {
                        action: 'move'
                    }, _.swipeHandler);
                    _.$list.on('touchend.slick mouseup.slick', {
                        action: 'end'
                    }, _.swipeHandler);
                    _.$list.on('touchcancel.slick mouseleave.slick', {
                        action: 'end'
                    }, _.swipeHandler);

                    _.$list.on('click.slick', _.clickHandler);

                    $(document).on(_.visibilityChange, $.proxy(_.visibility, _));

                    if (_.options.accessibility === true) {
                        _.$list.on('keydown.slick', _.keyHandler);
                    }

                    if (_.options.focusOnSelect === true) {
                        $(_.$slideTrack).children().on('click.slick', _.selectHandler);
                    }

                    $(window).on('orientationchange.slick.slick-' + _.instanceUid, $.proxy(_.orientationChange, _));

                    $(window).on('resize.slick.slick-' + _.instanceUid, $.proxy(_.resize, _));

                    $('[draggable!=true]', _.$slideTrack).on('dragstart', _.preventDefault);

                    $(window).on('load.slick.slick-' + _.instanceUid, _.setPosition);
                    $(_.setPosition);

                };

                Slick.prototype.initUI = function() {

                    var _ = this;

                    if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {

                        _.$prevArrow.show();
                        _.$nextArrow.show();

                    }

                    if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {

                        _.$dots.show();

                    }

                };

                Slick.prototype.keyHandler = function(event) {

                    var _ = this;
                    //Dont slide if the cursor is inside the form fields and arrow keys are pressed
                    if(!event.target.tagName.match('TEXTAREA|INPUT|SELECT')) {
                        if (event.keyCode === 37 && _.options.accessibility === true) {
                            _.changeSlide({
                                data: {
                                    message: _.options.rtl === true ? 'next' :  'previous'
                                }
                            });
                        } else if (event.keyCode === 39 && _.options.accessibility === true) {
                            _.changeSlide({
                                data: {
                                    message: _.options.rtl === true ? 'previous' : 'next'
                                }
                            });
                        }
                    }

                };

                Slick.prototype.lazyLoad = function() {

                    var _ = this,
                        loadRange, cloneRange, rangeStart, rangeEnd;

                    function loadImages(imagesScope) {

                        $('img[data-lazy]', imagesScope).each(function() {

                            var image = $(this),
                                imageSource = $(this).attr('data-lazy'),
                                imageSrcSet = $(this).attr('data-srcset'),
                                imageSizes  = $(this).attr('data-sizes') || _.$slider.attr('data-sizes'),
                                imageToLoad = document.createElement('img');

                            imageToLoad.onload = function() {

                                image
                                    .animate({ opacity: 0 }, 100, function() {

                                        if (imageSrcSet) {
                                            image
                                                .attr('srcset', imageSrcSet );

                                            if (imageSizes) {
                                                image
                                                    .attr('sizes', imageSizes );
                                            }
                                        }

                                        image
                                            .attr('src', imageSource)
                                            .animate({ opacity: 1 }, 200, function() {
                                                image
                                                    .removeAttr('data-lazy data-srcset data-sizes')
                                                    .removeClass('slick-loading');
                                            });
                                        _.$slider.trigger('lazyLoaded', [_, image, imageSource]);
                                    });

                            };

                            imageToLoad.onerror = function() {

                                image
                                    .removeAttr( 'data-lazy' )
                                    .removeClass( 'slick-loading' )
                                    .addClass( 'slick-lazyload-error' );

                                _.$slider.trigger('lazyLoadError', [ _, image, imageSource ]);

                            };

                            imageToLoad.src = imageSource;

                        });

                    }

                    if (_.options.centerMode === true) {
                        if (_.options.infinite === true) {
                            rangeStart = _.currentSlide + (_.options.slidesToShow / 2 + 1);
                            rangeEnd = rangeStart + _.options.slidesToShow + 2;
                        } else {
                            rangeStart = Math.max(0, _.currentSlide - (_.options.slidesToShow / 2 + 1));
                            rangeEnd = 2 + (_.options.slidesToShow / 2 + 1) + _.currentSlide;
                        }
                    } else {
                        rangeStart = _.options.infinite ? _.options.slidesToShow + _.currentSlide : _.currentSlide;
                        rangeEnd = Math.ceil(rangeStart + _.options.slidesToShow);
                        if (_.options.fade === true) {
                            if (rangeStart > 0) rangeStart--;
                            if (rangeEnd <= _.slideCount) rangeEnd++;
                        }
                    }

                    loadRange = _.$slider.find('.slick-slide').slice(rangeStart, rangeEnd);

                    if (_.options.lazyLoad === 'anticipated') {
                        var prevSlide = rangeStart - 1,
                            nextSlide = rangeEnd,
                            $slides = _.$slider.find('.slick-slide');

                        for (var i = 0; i < _.options.slidesToScroll; i++) {
                            if (prevSlide < 0) prevSlide = _.slideCount - 1;
                            loadRange = loadRange.add($slides.eq(prevSlide));
                            loadRange = loadRange.add($slides.eq(nextSlide));
                            prevSlide--;
                            nextSlide++;
                        }
                    }

                    loadImages(loadRange);

                    if (_.slideCount <= _.options.slidesToShow) {
                        cloneRange = _.$slider.find('.slick-slide');
                        loadImages(cloneRange);
                    } else
                    if (_.currentSlide >= _.slideCount - _.options.slidesToShow) {
                        cloneRange = _.$slider.find('.slick-cloned').slice(0, _.options.slidesToShow);
                        loadImages(cloneRange);
                    } else if (_.currentSlide === 0) {
                        cloneRange = _.$slider.find('.slick-cloned').slice(_.options.slidesToShow * -1);
                        loadImages(cloneRange);
                    }

                };

                Slick.prototype.loadSlider = function() {

                    var _ = this;

                    _.setPosition();

                    _.$slideTrack.css({
                        opacity: 1
                    });

                    _.$slider.removeClass('slick-loading');

                    _.initUI();

                    if (_.options.lazyLoad === 'progressive') {
                        _.progressiveLazyLoad();
                    }

                };

                Slick.prototype.next = Slick.prototype.slickNext = function() {

                    var _ = this;

                    _.changeSlide({
                        data: {
                            message: 'next'
                        }
                    });

                };

                Slick.prototype.orientationChange = function() {

                    var _ = this;

                    _.checkResponsive();
                    _.setPosition();

                };

                Slick.prototype.pause = Slick.prototype.slickPause = function() {

                    var _ = this;

                    _.autoPlayClear();
                    _.paused = true;

                };

                Slick.prototype.play = Slick.prototype.slickPlay = function() {

                    var _ = this;

                    _.autoPlay();
                    _.options.autoplay = true;
                    _.paused = false;
                    _.focussed = false;
                    _.interrupted = false;

                };

                Slick.prototype.postSlide = function(index) {

                    var _ = this;

                    if( !_.unslicked ) {

                        _.$slider.trigger('afterChange', [_, index]);

                        _.animating = false;

                        if (_.slideCount > _.options.slidesToShow) {
                            _.setPosition();
                        }

                        _.swipeLeft = null;

                        if ( _.options.autoplay ) {
                            _.autoPlay();
                        }

                        if (_.options.accessibility === true) {
                            _.initADA();

                            if (_.options.focusOnChange) {
                                var $currentSlide = $(_.$slides.get(_.currentSlide));
                                $currentSlide.attr('tabindex', 0).focus();
                            }
                        }

                    }

                };

                Slick.prototype.prev = Slick.prototype.slickPrev = function() {

                    var _ = this;

                    _.changeSlide({
                        data: {
                            message: 'previous'
                        }
                    });

                };

                Slick.prototype.preventDefault = function(event) {

                    event.preventDefault();

                };

                Slick.prototype.progressiveLazyLoad = function( tryCount ) {

                    tryCount = tryCount || 1;

                    var _ = this,
                        $imgsToLoad = $( 'img[data-lazy]', _.$slider ),
                        image,
                        imageSource,
                        imageSrcSet,
                        imageSizes,
                        imageToLoad;

                    if ( $imgsToLoad.length ) {

                        image = $imgsToLoad.first();
                        imageSource = image.attr('data-lazy');
                        imageSrcSet = image.attr('data-srcset');
                        imageSizes  = image.attr('data-sizes') || _.$slider.attr('data-sizes');
                        imageToLoad = document.createElement('img');

                        imageToLoad.onload = function() {

                            if (imageSrcSet) {
                                image
                                    .attr('srcset', imageSrcSet );

                                if (imageSizes) {
                                    image
                                        .attr('sizes', imageSizes );
                                }
                            }

                            image
                                .attr( 'src', imageSource )
                                .removeAttr('data-lazy data-srcset data-sizes')
                                .removeClass('slick-loading');

                            if ( _.options.adaptiveHeight === true ) {
                                _.setPosition();
                            }

                            _.$slider.trigger('lazyLoaded', [ _, image, imageSource ]);
                            _.progressiveLazyLoad();

                        };

                        imageToLoad.onerror = function() {

                            if ( tryCount < 3 ) {

                                /**
                                 * try to load the image 3 times,
                                 * leave a slight delay so we don't get
                                 * servers blocking the request.
                                 */
                                setTimeout( function() {
                                    _.progressiveLazyLoad( tryCount + 1 );
                                }, 500 );

                            } else {

                                image
                                    .removeAttr( 'data-lazy' )
                                    .removeClass( 'slick-loading' )
                                    .addClass( 'slick-lazyload-error' );

                                _.$slider.trigger('lazyLoadError', [ _, image, imageSource ]);

                                _.progressiveLazyLoad();

                            }

                        };

                        imageToLoad.src = imageSource;

                    } else {

                        _.$slider.trigger('allImagesLoaded', [ _ ]);

                    }

                };

                Slick.prototype.refresh = function( initializing ) {

                    var _ = this, currentSlide, lastVisibleIndex;

                    lastVisibleIndex = _.slideCount - _.options.slidesToShow;

                    // in non-infinite sliders, we don't want to go past the
                    // last visible index.
                    if( !_.options.infinite && ( _.currentSlide > lastVisibleIndex )) {
                        _.currentSlide = lastVisibleIndex;
                    }

                    // if less slides than to show, go to start.
                    if ( _.slideCount <= _.options.slidesToShow ) {
                        _.currentSlide = 0;

                    }

                    currentSlide = _.currentSlide;

                    _.destroy(true);

                    $.extend(_, _.initials, { currentSlide: currentSlide });

                    _.init();

                    if( !initializing ) {

                        _.changeSlide({
                            data: {
                                message: 'index',
                                index: currentSlide
                            }
                        }, false);

                    }

                };

                Slick.prototype.registerBreakpoints = function() {

                    var _ = this, breakpoint, currentBreakpoint, l,
                        responsiveSettings = _.options.responsive || null;

                    if ( $.type(responsiveSettings) === 'array' && responsiveSettings.length ) {

                        _.respondTo = _.options.respondTo || 'window';

                        for ( breakpoint in responsiveSettings ) {

                            l = _.breakpoints.length-1;

                            if (responsiveSettings.hasOwnProperty(breakpoint)) {
                                currentBreakpoint = responsiveSettings[breakpoint].breakpoint;

                                // loop through the breakpoints and cut out any existing
                                // ones with the same breakpoint number, we don't want dupes.
                                while( l >= 0 ) {
                                    if( _.breakpoints[l] && _.breakpoints[l] === currentBreakpoint ) {
                                        _.breakpoints.splice(l,1);
                                    }
                                    l--;
                                }

                                _.breakpoints.push(currentBreakpoint);
                                _.breakpointSettings[currentBreakpoint] = responsiveSettings[breakpoint].settings;

                            }

                        }

                        _.breakpoints.sort(function(a, b) {
                            return ( _.options.mobileFirst ) ? a-b : b-a;
                        });

                    }

                };

                Slick.prototype.reinit = function() {

                    var _ = this;

                    _.$slides =
                        _.$slideTrack
                            .children(_.options.slide)
                            .addClass('slick-slide');

                    _.slideCount = _.$slides.length;

                    if (_.currentSlide >= _.slideCount && _.currentSlide !== 0) {
                        _.currentSlide = _.currentSlide - _.options.slidesToScroll;
                    }

                    if (_.slideCount <= _.options.slidesToShow) {
                        _.currentSlide = 0;
                    }

                    _.registerBreakpoints();

                    _.setProps();
                    _.setupInfinite();
                    _.buildArrows();
                    _.updateArrows();
                    _.initArrowEvents();
                    _.buildDots();
                    _.updateDots();
                    _.initDotEvents();
                    _.cleanUpSlideEvents();
                    _.initSlideEvents();

                    _.checkResponsive(false, true);

                    if (_.options.focusOnSelect === true) {
                        $(_.$slideTrack).children().on('click.slick', _.selectHandler);
                    }

                    _.setSlideClasses(typeof _.currentSlide === 'number' ? _.currentSlide : 0);

                    _.setPosition();
                    _.focusHandler();

                    _.paused = !_.options.autoplay;
                    _.autoPlay();

                    _.$slider.trigger('reInit', [_]);

                };

                Slick.prototype.resize = function() {

                    var _ = this;

                    if ($(window).width() !== _.windowWidth) {
                        clearTimeout(_.windowDelay);
                        _.windowDelay = window.setTimeout(function() {
                            _.windowWidth = $(window).width();
                            _.checkResponsive();
                            if( !_.unslicked ) { _.setPosition(); }
                        }, 50);
                    }
                };

                Slick.prototype.removeSlide = Slick.prototype.slickRemove = function(index, removeBefore, removeAll) {

                    var _ = this;

                    if (typeof(index) === 'boolean') {
                        removeBefore = index;
                        index = removeBefore === true ? 0 : _.slideCount - 1;
                    } else {
                        index = removeBefore === true ? --index : index;
                    }

                    if (_.slideCount < 1 || index < 0 || index > _.slideCount - 1) {
                        return false;
                    }

                    _.unload();

                    if (removeAll === true) {
                        _.$slideTrack.children().remove();
                    } else {
                        _.$slideTrack.children(this.options.slide).eq(index).remove();
                    }

                    _.$slides = _.$slideTrack.children(this.options.slide);

                    _.$slideTrack.children(this.options.slide).detach();

                    _.$slideTrack.append(_.$slides);

                    _.$slidesCache = _.$slides;

                    _.reinit();

                };

                Slick.prototype.setCSS = function(position) {

                    var _ = this,
                        positionProps = {},
                        x, y;

                    if (_.options.rtl === true) {
                        position = -position;
                    }
                    x = _.positionProp == 'left' ? Math.ceil(position) + 'px' : '0px';
                    y = _.positionProp == 'top' ? Math.ceil(position) + 'px' : '0px';

                    positionProps[_.positionProp] = position;

                    if (_.transformsEnabled === false) {
                        _.$slideTrack.css(positionProps);
                    } else {
                        positionProps = {};
                        if (_.cssTransitions === false) {
                            positionProps[_.animType] = 'translate(' + x + ', ' + y + ')';
                            _.$slideTrack.css(positionProps);
                        } else {
                            positionProps[_.animType] = 'translate3d(' + x + ', ' + y + ', 0px)';
                            _.$slideTrack.css(positionProps);
                        }
                    }

                };

                Slick.prototype.setDimensions = function() {

                    var _ = this;

                    if (_.options.vertical === false) {
                        if (_.options.centerMode === true) {
                            _.$list.css({
                                padding: ('0px ' + _.options.centerPadding)
                            });
                        }
                    } else {
                        _.$list.height(_.$slides.first().outerHeight(true) * _.options.slidesToShow);
                        if (_.options.centerMode === true) {
                            _.$list.css({
                                padding: (_.options.centerPadding + ' 0px')
                            });
                        }
                    }

                    _.listWidth = _.$list.width();
                    _.listHeight = _.$list.height();


                    if (_.options.vertical === false && _.options.variableWidth === false) {
                        _.slideWidth = Math.ceil(_.listWidth / _.options.slidesToShow);
                        _.$slideTrack.width(Math.ceil((_.slideWidth * _.$slideTrack.children('.slick-slide').length)));

                    } else if (_.options.variableWidth === true) {
                        _.$slideTrack.width(5000 * _.slideCount);
                    } else {
                        _.slideWidth = Math.ceil(_.listWidth);
                        _.$slideTrack.height(Math.ceil((_.$slides.first().outerHeight(true) * _.$slideTrack.children('.slick-slide').length)));
                    }

                    var offset = _.$slides.first().outerWidth(true) - _.$slides.first().width();
                    if (_.options.variableWidth === false) _.$slideTrack.children('.slick-slide').width(_.slideWidth - offset);

                };

                Slick.prototype.setFade = function() {

                    var _ = this,
                        targetLeft;

                    _.$slides.each(function(index, element) {
                        targetLeft = (_.slideWidth * index) * -1;
                        if (_.options.rtl === true) {
                            $(element).css({
                                position: 'relative',
                                right: targetLeft,
                                top: 0,
                                zIndex: _.options.zIndex - 2,
                                opacity: 0
                            });
                        } else {
                            $(element).css({
                                position: 'relative',
                                left: targetLeft,
                                top: 0,
                                zIndex: _.options.zIndex - 2,
                                opacity: 0
                            });
                        }
                    });

                    _.$slides.eq(_.currentSlide).css({
                        zIndex: _.options.zIndex - 1,
                        opacity: 1
                    });

                };

                Slick.prototype.setHeight = function() {

                    var _ = this;

                    if (_.options.slidesToShow === 1 && _.options.adaptiveHeight === true && _.options.vertical === false) {
                        var targetHeight = _.$slides.eq(_.currentSlide).outerHeight(true);
                        _.$list.css('height', targetHeight);
                    }

                };

                Slick.prototype.setOption =
                    Slick.prototype.slickSetOption = function() {

                        /**
                         * accepts arguments in format of:
                         *
                         *  - for changing a single option's value:
                         *     .slick("setOption", option, value, refresh )
                         *
                         *  - for changing a set of responsive options:
                         *     .slick("setOption", 'responsive', [{}, ...], refresh )
                         *
                         *  - for updating multiple values at once (not responsive)
                         *     .slick("setOption", { 'option': value, ... }, refresh )
                         */

                        var _ = this, l, item, option, value, refresh = false, type;

                        if( $.type( arguments[0] ) === 'object' ) {

                            option =  arguments[0];
                            refresh = arguments[1];
                            type = 'multiple';

                        } else if ( $.type( arguments[0] ) === 'string' ) {

                            option =  arguments[0];
                            value = arguments[1];
                            refresh = arguments[2];

                            if ( arguments[0] === 'responsive' && $.type( arguments[1] ) === 'array' ) {

                                type = 'responsive';

                            } else if ( typeof arguments[1] !== 'undefined' ) {

                                type = 'single';

                            }

                        }

                        if ( type === 'single' ) {

                            _.options[option] = value;


                        } else if ( type === 'multiple' ) {

                            $.each( option , function( opt, val ) {

                                _.options[opt] = val;

                            });


                        } else if ( type === 'responsive' ) {

                            for ( item in value ) {

                                if( $.type( _.options.responsive ) !== 'array' ) {

                                    _.options.responsive = [ value[item] ];

                                } else {

                                    l = _.options.responsive.length-1;

                                    // loop through the responsive object and splice out duplicates.
                                    while( l >= 0 ) {

                                        if( _.options.responsive[l].breakpoint === value[item].breakpoint ) {

                                            _.options.responsive.splice(l,1);

                                        }

                                        l--;

                                    }

                                    _.options.responsive.push( value[item] );

                                }

                            }

                        }

                        if ( refresh ) {

                            _.unload();
                            _.reinit();

                        }

                    };

                Slick.prototype.setPosition = function() {

                    var _ = this;

                    _.setDimensions();

                    _.setHeight();

                    if (_.options.fade === false) {
                        _.setCSS(_.getLeft(_.currentSlide));
                    } else {
                        _.setFade();
                    }

                    _.$slider.trigger('setPosition', [_]);

                };

                Slick.prototype.setProps = function() {

                    var _ = this,
                        bodyStyle = document.body.style;

                    _.positionProp = _.options.vertical === true ? 'top' : 'left';

                    if (_.positionProp === 'top') {
                        _.$slider.addClass('slick-vertical');
                    } else {
                        _.$slider.removeClass('slick-vertical');
                    }

                    if (bodyStyle.WebkitTransition !== undefined ||
                        bodyStyle.MozTransition !== undefined ||
                        bodyStyle.msTransition !== undefined) {
                        if (_.options.useCSS === true) {
                            _.cssTransitions = true;
                        }
                    }

                    if ( _.options.fade ) {
                        if ( typeof _.options.zIndex === 'number' ) {
                            if( _.options.zIndex < 3 ) {
                                _.options.zIndex = 3;
                            }
                        } else {
                            _.options.zIndex = _.defaults.zIndex;
                        }
                    }

                    if (bodyStyle.OTransform !== undefined) {
                        _.animType = 'OTransform';
                        _.transformType = '-o-transform';
                        _.transitionType = 'OTransition';
                        if (bodyStyle.perspectiveProperty === undefined && bodyStyle.webkitPerspective === undefined) _.animType = false;
                    }
                    if (bodyStyle.MozTransform !== undefined) {
                        _.animType = 'MozTransform';
                        _.transformType = '-moz-transform';
                        _.transitionType = 'MozTransition';
                        if (bodyStyle.perspectiveProperty === undefined && bodyStyle.MozPerspective === undefined) _.animType = false;
                    }
                    if (bodyStyle.webkitTransform !== undefined) {
                        _.animType = 'webkitTransform';
                        _.transformType = '-webkit-transform';
                        _.transitionType = 'webkitTransition';
                        if (bodyStyle.perspectiveProperty === undefined && bodyStyle.webkitPerspective === undefined) _.animType = false;
                    }
                    if (bodyStyle.msTransform !== undefined) {
                        _.animType = 'msTransform';
                        _.transformType = '-ms-transform';
                        _.transitionType = 'msTransition';
                        if (bodyStyle.msTransform === undefined) _.animType = false;
                    }
                    if (bodyStyle.transform !== undefined && _.animType !== false) {
                        _.animType = 'transform';
                        _.transformType = 'transform';
                        _.transitionType = 'transition';
                    }
                    _.transformsEnabled = _.options.useTransform && (_.animType !== null && _.animType !== false);
                };


                Slick.prototype.setSlideClasses = function(index) {

                    var _ = this,
                        centerOffset, allSlides, indexOffset, remainder;

                    allSlides = _.$slider
                        .find('.slick-slide')
                        .removeClass('slick-active slick-center slick-current')
                        .attr('aria-hidden', 'true');

                    _.$slides
                        .eq(index)
                        .addClass('slick-current');

                    if (_.options.centerMode === true) {

                        var evenCoef = _.options.slidesToShow % 2 === 0 ? 1 : 0;

                        centerOffset = Math.floor(_.options.slidesToShow / 2);

                        if (_.options.infinite === true) {

                            if (index >= centerOffset && index <= (_.slideCount - 1) - centerOffset) {
                                _.$slides
                                    .slice(index - centerOffset + evenCoef, index + centerOffset + 1)
                                    .addClass('slick-active')
                                    .attr('aria-hidden', 'false');

                            } else {

                                indexOffset = _.options.slidesToShow + index;
                                allSlides
                                    .slice(indexOffset - centerOffset + 1 + evenCoef, indexOffset + centerOffset + 2)
                                    .addClass('slick-active')
                                    .attr('aria-hidden', 'false');

                            }

                            if (index === 0) {

                                allSlides
                                    .eq(allSlides.length - 1 - _.options.slidesToShow)
                                    .addClass('slick-center');

                            } else if (index === _.slideCount - 1) {

                                allSlides
                                    .eq(_.options.slidesToShow)
                                    .addClass('slick-center');

                            }

                        }

                        _.$slides
                            .eq(index)
                            .addClass('slick-center');

                    } else {

                        if (index >= 0 && index <= (_.slideCount - _.options.slidesToShow)) {

                            _.$slides
                                .slice(index, index + _.options.slidesToShow)
                                .addClass('slick-active')
                                .attr('aria-hidden', 'false');

                        } else if (allSlides.length <= _.options.slidesToShow) {

                            allSlides
                                .addClass('slick-active')
                                .attr('aria-hidden', 'false');

                        } else {

                            remainder = _.slideCount % _.options.slidesToShow;
                            indexOffset = _.options.infinite === true ? _.options.slidesToShow + index : index;

                            if (_.options.slidesToShow == _.options.slidesToScroll && (_.slideCount - index) < _.options.slidesToShow) {

                                allSlides
                                    .slice(indexOffset - (_.options.slidesToShow - remainder), indexOffset + remainder)
                                    .addClass('slick-active')
                                    .attr('aria-hidden', 'false');

                            } else {

                                allSlides
                                    .slice(indexOffset, indexOffset + _.options.slidesToShow)
                                    .addClass('slick-active')
                                    .attr('aria-hidden', 'false');

                            }

                        }

                    }

                    if (_.options.lazyLoad === 'ondemand' || _.options.lazyLoad === 'anticipated') {
                        _.lazyLoad();
                    }
                };

                Slick.prototype.setupInfinite = function() {

                    var _ = this,
                        i, slideIndex, infiniteCount;

                    if (_.options.fade === true) {
                        _.options.centerMode = false;
                    }

                    if (_.options.infinite === true && _.options.fade === false) {

                        slideIndex = null;

                        if (_.slideCount > _.options.slidesToShow) {

                            if (_.options.centerMode === true) {
                                infiniteCount = _.options.slidesToShow + 1;
                            } else {
                                infiniteCount = _.options.slidesToShow;
                            }

                            for (i = _.slideCount; i > (_.slideCount -
                                infiniteCount); i -= 1) {
                                slideIndex = i - 1;
                                $(_.$slides[slideIndex]).clone(true).attr('id', '')
                                    .attr('data-slick-index', slideIndex - _.slideCount)
                                    .prependTo(_.$slideTrack).addClass('slick-cloned');
                            }
                            for (i = 0; i < infiniteCount  + _.slideCount; i += 1) {
                                slideIndex = i;
                                $(_.$slides[slideIndex]).clone(true).attr('id', '')
                                    .attr('data-slick-index', slideIndex + _.slideCount)
                                    .appendTo(_.$slideTrack).addClass('slick-cloned');
                            }
                            _.$slideTrack.find('.slick-cloned').find('[id]').each(function() {
                                $(this).attr('id', '');
                            });

                        }

                    }

                };

                Slick.prototype.interrupt = function( toggle ) {

                    var _ = this;

                    if( !toggle ) {
                        _.autoPlay();
                    }
                    _.interrupted = toggle;

                };

                Slick.prototype.selectHandler = function(event) {

                    var _ = this;

                    var targetElement =
                        $(event.target).is('.slick-slide') ?
                            $(event.target) :
                            $(event.target).parents('.slick-slide');

                    var index = parseInt(targetElement.attr('data-slick-index'));

                    if (!index) index = 0;

                    if (_.slideCount <= _.options.slidesToShow) {

                        _.slideHandler(index, false, true);
                        return;

                    }

                    _.slideHandler(index);

                };

                Slick.prototype.slideHandler = function(index, sync, dontAnimate) {

                    var targetSlide, animSlide, oldSlide, slideLeft, targetLeft = null,
                        _ = this, navTarget;

                    sync = sync || false;

                    if (_.animating === true && _.options.waitForAnimate === true) {
                        return;
                    }

                    if (_.options.fade === true && _.currentSlide === index) {
                        return;
                    }

                    if (sync === false) {
                        _.asNavFor(index);
                    }

                    targetSlide = index;
                    targetLeft = _.getLeft(targetSlide);
                    slideLeft = _.getLeft(_.currentSlide);

                    _.currentLeft = _.swipeLeft === null ? slideLeft : _.swipeLeft;

                    if (_.options.infinite === false && _.options.centerMode === false && (index < 0 || index > _.getDotCount() * _.options.slidesToScroll)) {
                        if (_.options.fade === false) {
                            targetSlide = _.currentSlide;
                            if (dontAnimate !== true && _.slideCount > _.options.slidesToShow) {
                                _.animateSlide(slideLeft, function() {
                                    _.postSlide(targetSlide);
                                });
                            } else {
                                _.postSlide(targetSlide);
                            }
                        }
                        return;
                    } else if (_.options.infinite === false && _.options.centerMode === true && (index < 0 || index > (_.slideCount - _.options.slidesToScroll))) {
                        if (_.options.fade === false) {
                            targetSlide = _.currentSlide;
                            if (dontAnimate !== true && _.slideCount > _.options.slidesToShow) {
                                _.animateSlide(slideLeft, function() {
                                    _.postSlide(targetSlide);
                                });
                            } else {
                                _.postSlide(targetSlide);
                            }
                        }
                        return;
                    }

                    if ( _.options.autoplay ) {
                        clearInterval(_.autoPlayTimer);
                    }

                    if (targetSlide < 0) {
                        if (_.slideCount % _.options.slidesToScroll !== 0) {
                            animSlide = _.slideCount - (_.slideCount % _.options.slidesToScroll);
                        } else {
                            animSlide = _.slideCount + targetSlide;
                        }
                    } else if (targetSlide >= _.slideCount) {
                        if (_.slideCount % _.options.slidesToScroll !== 0) {
                            animSlide = 0;
                        } else {
                            animSlide = targetSlide - _.slideCount;
                        }
                    } else {
                        animSlide = targetSlide;
                    }

                    _.animating = true;

                    _.$slider.trigger('beforeChange', [_, _.currentSlide, animSlide]);

                    oldSlide = _.currentSlide;
                    _.currentSlide = animSlide;

                    _.setSlideClasses(_.currentSlide);

                    if ( _.options.asNavFor ) {

                        navTarget = _.getNavTarget();
                        navTarget = navTarget.slick('getSlick');

                        if ( navTarget.slideCount <= navTarget.options.slidesToShow ) {
                            navTarget.setSlideClasses(_.currentSlide);
                        }

                    }

                    _.updateDots();
                    _.updateArrows();

                    if (_.options.fade === true) {
                        if (dontAnimate !== true) {

                            _.fadeSlideOut(oldSlide);

                            _.fadeSlide(animSlide, function() {
                                _.postSlide(animSlide);
                            });

                        } else {
                            _.postSlide(animSlide);
                        }
                        _.animateHeight();
                        return;
                    }

                    if (dontAnimate !== true && _.slideCount > _.options.slidesToShow) {
                        _.animateSlide(targetLeft, function() {
                            _.postSlide(animSlide);
                        });
                    } else {
                        _.postSlide(animSlide);
                    }

                };

                Slick.prototype.startLoad = function() {

                    var _ = this;

                    if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {

                        _.$prevArrow.hide();
                        _.$nextArrow.hide();

                    }

                    if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {

                        _.$dots.hide();

                    }

                    _.$slider.addClass('slick-loading');

                };

                Slick.prototype.swipeDirection = function() {

                    var xDist, yDist, r, swipeAngle, _ = this;

                    xDist = _.touchObject.startX - _.touchObject.curX;
                    yDist = _.touchObject.startY - _.touchObject.curY;
                    r = Math.atan2(yDist, xDist);

                    swipeAngle = Math.round(r * 180 / Math.PI);
                    if (swipeAngle < 0) {
                        swipeAngle = 360 - Math.abs(swipeAngle);
                    }

                    if ((swipeAngle <= 45) && (swipeAngle >= 0)) {
                        return (_.options.rtl === false ? 'left' : 'right');
                    }
                    if ((swipeAngle <= 360) && (swipeAngle >= 315)) {
                        return (_.options.rtl === false ? 'left' : 'right');
                    }
                    if ((swipeAngle >= 135) && (swipeAngle <= 225)) {
                        return (_.options.rtl === false ? 'right' : 'left');
                    }
                    if (_.options.verticalSwiping === true) {
                        if ((swipeAngle >= 35) && (swipeAngle <= 135)) {
                            return 'down';
                        } else {
                            return 'up';
                        }
                    }

                    return 'vertical';

                };

                Slick.prototype.swipeEnd = function(event) {

                    var _ = this,
                        slideCount,
                        direction;

                    _.dragging = false;
                    _.swiping = false;

                    if (_.scrolling) {
                        _.scrolling = false;
                        return false;
                    }

                    _.interrupted = false;
                    _.shouldClick = ( _.touchObject.swipeLength > 10 ) ? false : true;

                    if ( _.touchObject.curX === undefined ) {
                        return false;
                    }

                    if ( _.touchObject.edgeHit === true ) {
                        _.$slider.trigger('edge', [_, _.swipeDirection() ]);
                    }

                    if ( _.touchObject.swipeLength >= _.touchObject.minSwipe ) {

                        direction = _.swipeDirection();

                        switch ( direction ) {

                            case 'left':
                            case 'down':

                                slideCount =
                                    _.options.swipeToSlide ?
                                        _.checkNavigable( _.currentSlide + _.getSlideCount() ) :
                                        _.currentSlide + _.getSlideCount();

                                _.currentDirection = 0;

                                break;

                            case 'right':
                            case 'up':

                                slideCount =
                                    _.options.swipeToSlide ?
                                        _.checkNavigable( _.currentSlide - _.getSlideCount() ) :
                                        _.currentSlide - _.getSlideCount();

                                _.currentDirection = 1;

                                break;

                            default:


                        }

                        if( direction != 'vertical' ) {

                            _.slideHandler( slideCount );
                            _.touchObject = {};
                            _.$slider.trigger('swipe', [_, direction ]);

                        }

                    } else {

                        if ( _.touchObject.startX !== _.touchObject.curX ) {

                            _.slideHandler( _.currentSlide );
                            _.touchObject = {};

                        }

                    }

                };

                Slick.prototype.swipeHandler = function(event) {

                    var _ = this;

                    if ((_.options.swipe === false) || ('ontouchend' in document && _.options.swipe === false)) {
                        return;
                    } else if (_.options.draggable === false && event.type.indexOf('mouse') !== -1) {
                        return;
                    }

                    _.touchObject.fingerCount = event.originalEvent && event.originalEvent.touches !== undefined ?
                        event.originalEvent.touches.length : 1;

                    _.touchObject.minSwipe = _.listWidth / _.options
                        .touchThreshold;

                    if (_.options.verticalSwiping === true) {
                        _.touchObject.minSwipe = _.listHeight / _.options
                            .touchThreshold;
                    }

                    switch (event.data.action) {

                        case 'start':
                            _.swipeStart(event);
                            break;

                        case 'move':
                            _.swipeMove(event);
                            break;

                        case 'end':
                            _.swipeEnd(event);
                            break;

                    }

                };

                Slick.prototype.swipeMove = function(event) {

                    var _ = this,
                        edgeWasHit = false,
                        curLeft, swipeDirection, swipeLength, positionOffset, touches, verticalSwipeLength;

                    touches = event.originalEvent !== undefined ? event.originalEvent.touches : null;

                    if (!_.dragging || _.scrolling || touches && touches.length !== 1) {
                        return false;
                    }

                    curLeft = _.getLeft(_.currentSlide);

                    _.touchObject.curX = touches !== undefined ? touches[0].pageX : event.clientX;
                    _.touchObject.curY = touches !== undefined ? touches[0].pageY : event.clientY;

                    _.touchObject.swipeLength = Math.round(Math.sqrt(
                        Math.pow(_.touchObject.curX - _.touchObject.startX, 2)));

                    verticalSwipeLength = Math.round(Math.sqrt(
                        Math.pow(_.touchObject.curY - _.touchObject.startY, 2)));

                    if (!_.options.verticalSwiping && !_.swiping && verticalSwipeLength > 4) {
                        _.scrolling = true;
                        return false;
                    }

                    if (_.options.verticalSwiping === true) {
                        _.touchObject.swipeLength = verticalSwipeLength;
                    }

                    swipeDirection = _.swipeDirection();

                    if (event.originalEvent !== undefined && _.touchObject.swipeLength > 4) {
                        _.swiping = true;
                        event.preventDefault();
                    }

                    positionOffset = (_.options.rtl === false ? 1 : -1) * (_.touchObject.curX > _.touchObject.startX ? 1 : -1);
                    if (_.options.verticalSwiping === true) {
                        positionOffset = _.touchObject.curY > _.touchObject.startY ? 1 : -1;
                    }


                    swipeLength = _.touchObject.swipeLength;

                    _.touchObject.edgeHit = false;

                    if (_.options.infinite === false) {
                        if ((_.currentSlide === 0 && swipeDirection === 'right') || (_.currentSlide >= _.getDotCount() && swipeDirection === 'left')) {
                            swipeLength = _.touchObject.swipeLength * _.options.edgeFriction;
                            _.touchObject.edgeHit = true;
                        }
                    }

                    if (_.options.vertical === false) {
                        _.swipeLeft = curLeft + swipeLength * positionOffset;
                    } else {
                        _.swipeLeft = curLeft + (swipeLength * (_.$list.height() / _.listWidth)) * positionOffset;
                    }
                    if (_.options.verticalSwiping === true) {
                        _.swipeLeft = curLeft + swipeLength * positionOffset;
                    }

                    if (_.options.fade === true || _.options.touchMove === false) {
                        return false;
                    }

                    if (_.animating === true) {
                        _.swipeLeft = null;
                        return false;
                    }

                    _.setCSS(_.swipeLeft);

                };

                Slick.prototype.swipeStart = function(event) {

                    var _ = this,
                        touches;

                    _.interrupted = true;

                    if (_.touchObject.fingerCount !== 1 || _.slideCount <= _.options.slidesToShow) {
                        _.touchObject = {};
                        return false;
                    }

                    if (event.originalEvent !== undefined && event.originalEvent.touches !== undefined) {
                        touches = event.originalEvent.touches[0];
                    }

                    _.touchObject.startX = _.touchObject.curX = touches !== undefined ? touches.pageX : event.clientX;
                    _.touchObject.startY = _.touchObject.curY = touches !== undefined ? touches.pageY : event.clientY;

                    _.dragging = true;

                };

                Slick.prototype.unfilterSlides = Slick.prototype.slickUnfilter = function() {

                    var _ = this;

                    if (_.$slidesCache !== null) {

                        _.unload();

                        _.$slideTrack.children(this.options.slide).detach();

                        _.$slidesCache.appendTo(_.$slideTrack);

                        _.reinit();

                    }

                };

                Slick.prototype.unload = function() {

                    var _ = this;

                    $('.slick-cloned', _.$slider).remove();

                    if (_.$dots) {
                        _.$dots.remove();
                    }

                    if (_.$prevArrow && _.htmlExpr.test(_.options.prevArrow)) {
                        _.$prevArrow.remove();
                    }

                    if (_.$nextArrow && _.htmlExpr.test(_.options.nextArrow)) {
                        _.$nextArrow.remove();
                    }

                    _.$slides
                        .removeClass('slick-slide slick-active slick-visible slick-current')
                        .attr('aria-hidden', 'true')
                        .css('width', '');

                };

                Slick.prototype.unslick = function(fromBreakpoint) {

                    var _ = this;
                    _.$slider.trigger('unslick', [_, fromBreakpoint]);
                    _.destroy();

                };

                Slick.prototype.updateArrows = function() {

                    var _ = this,
                        centerOffset;

                    centerOffset = Math.floor(_.options.slidesToShow / 2);

                    if ( _.options.arrows === true &&
                        _.slideCount > _.options.slidesToShow &&
                        !_.options.infinite ) {

                        _.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');
                        _.$nextArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');

                        if (_.currentSlide === 0) {

                            _.$prevArrow.addClass('slick-disabled').attr('aria-disabled', 'true');
                            _.$nextArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');

                        } else if (_.currentSlide >= _.slideCount - _.options.slidesToShow && _.options.centerMode === false) {

                            _.$nextArrow.addClass('slick-disabled').attr('aria-disabled', 'true');
                            _.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');

                        } else if (_.currentSlide >= _.slideCount - 1 && _.options.centerMode === true) {

                            _.$nextArrow.addClass('slick-disabled').attr('aria-disabled', 'true');
                            _.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');

                        }

                    }

                };

                Slick.prototype.updateDots = function() {

                    var _ = this;

                    if (_.$dots !== null) {

                        _.$dots
                            .find('li')
                            .removeClass('slick-active')
                            .end();

                        _.$dots
                            .find('li')
                            .eq(Math.floor(_.currentSlide / _.options.slidesToScroll))
                            .addClass('slick-active');

                    }

                };

                Slick.prototype.visibility = function() {

                    var _ = this;

                    if ( _.options.autoplay ) {

                        if ( document[_.hidden] ) {

                            _.interrupted = true;

                        } else {

                            _.interrupted = false;

                        }

                    }

                };

                $.fn.slick = function() {
                    var _ = this,
                        opt = arguments[0],
                        args = Array.prototype.slice.call(arguments, 1),
                        l = _.length,
                        i,
                        ret;
                    for (i = 0; i < l; i++) {
                        if (typeof opt == 'object' || typeof opt == 'undefined')
                            _[i].slick = new Slick(_[i], opt);
                        else
                            ret = _[i].slick[opt].apply(_[i].slick, args);
                        if (typeof ret != 'undefined') return ret;
                    }
                    return _;
                };

            }));


            /***/ }),

        /***/ "./node_modules/webpack/buildin/amd-options.js":
        /*!****************************************!*\
  !*** (webpack)/buildin/amd-options.js ***!
  \****************************************/
        /*! no static exports found */
        /***/ (function(module, exports) {

            /* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */
                module.exports = __webpack_amd_options__;

                /* WEBPACK VAR INJECTION */}.call(this, {}))

            /***/ }),

        /***/ "./src/js/index.js":
        /*!*************************!*\
  !*** ./src/js/index.js ***!
  \*************************/
        /*! no exports provided */
        /***/ (function(module, __webpack_exports__, __webpack_require__) {

            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
            /* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
            /* harmony import */ var owl_carousel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! owl.carousel */ "./node_modules/owl.carousel/dist/owl.carousel.js");
            /* harmony import */ var owl_carousel__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(owl_carousel__WEBPACK_IMPORTED_MODULE_1__);
            /* harmony import */ var inputmask__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! inputmask */ "./node_modules/inputmask/dist/inputmask.js");
            /* harmony import */ var inputmask__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(inputmask__WEBPACK_IMPORTED_MODULE_2__);
            /* harmony import */ var magnific_popup__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! magnific-popup */ "./node_modules/magnific-popup/dist/jquery.magnific-popup.js");
            /* harmony import */ var magnific_popup__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(magnific_popup__WEBPACK_IMPORTED_MODULE_3__);
            /* harmony import */ var slick_carousel__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! slick-carousel */ "./node_modules/slick-carousel/slick/slick.js");
            /* harmony import */ var slick_carousel__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(slick_carousel__WEBPACK_IMPORTED_MODULE_4__);
            /* harmony import */ var jquery_lazy__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! jquery-lazy */ "./node_modules/jquery-lazy/jquery.lazy.js");
            /* harmony import */ var jquery_lazy__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(jquery_lazy__WEBPACK_IMPORTED_MODULE_5__);
            /* harmony import */ var ion_rangeslider__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ion-rangeslider */ "./node_modules/ion-rangeslider/js/ion.rangeSlider.js");
            /* harmony import */ var ion_rangeslider__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(ion_rangeslider__WEBPACK_IMPORTED_MODULE_6__);
            /* harmony import */ var select2__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! select2 */ "./node_modules/select2/dist/js/select2.js");
            /* harmony import */ var select2__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(select2__WEBPACK_IMPORTED_MODULE_7__);
            /* harmony import */ var jquery_inview__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! jquery-inview */ "./node_modules/jquery-inview/jquery.inview.js");
            /* harmony import */ var jquery_inview__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(jquery_inview__WEBPACK_IMPORTED_MODULE_8__);
            /* harmony import */ var js_cookie__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! js-cookie */ "./node_modules/js-cookie/dist/js.cookie.js");
            /* harmony import */ var js_cookie__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(js_cookie__WEBPACK_IMPORTED_MODULE_9__);











            jquery__WEBPACK_IMPORTED_MODULE_0___default()(document).ready(function () {
                let selector = document.querySelectorAll(".js-input-mask");
                let im = new inputmask__WEBPACK_IMPORTED_MODULE_2___default.a("+7(999)999-99-99",{ clearMaskOnLostFocus: false });
                selector.forEach((el) => {
                    im.mask(el);
                })

                if(document.getElementById('videomain') !== null) {
                    document.getElementById('videomain').play();
                }


                jquery__WEBPACK_IMPORTED_MODULE_0___default()("img.lazyload").on('inview', function(event, isInView) {
                    if (isInView) {
                        jquery__WEBPACK_IMPORTED_MODULE_0___default()("img.lazyload").Lazy({
                            afterLoad: function(element) {
                                element.addClass('load')
                            },
                            threshold: 50
                        });
                    } else {
                        jquery__WEBPACK_IMPORTED_MODULE_0___default()("img.lazyload").off('inview');
                    }
                });

                setTimeout(() => {
                    jquery__WEBPACK_IMPORTED_MODULE_0___default()('.build-route').addClass('show')
                }, 5000)

                setTimeout(() => {
                    jquery__WEBPACK_IMPORTED_MODULE_0___default()('.yandex-maps').addClass('show')
                }, 7000)

                setTimeout(() => {
                    jquery__WEBPACK_IMPORTED_MODULE_0___default()('.head-popup').css('display', 'flex');

                    setTimeout(() => {
                        jquery__WEBPACK_IMPORTED_MODULE_0___default()('.head-popup').addClass('show')
                        jquery__WEBPACK_IMPORTED_MODULE_0___default()('.wrapper').addClass('pop')
                    }, 1000)
                }, 1000)

                // if(Cookies.get('sales') === undefined) {
                // 	setTimeout(() => {
                // 		$.magnificPopup.open({
                // 			mainClass: 'mfp-with-zoom',
                // 			items: {
                // 				src: '#popup-sales', // can be a HTML string, jQuery object, or CSS selector
                // 				type: 'inline'
                // 			}
                // 		});
                // 		Cookies.set('sales', '1',  { expires: 7, path: '' })
                // 	}, 18500)
                // }

                setTimeout(() => {
                    if(js_cookie__WEBPACK_IMPORTED_MODULE_9___default.a.get('cookie') === undefined) {
                        jquery__WEBPACK_IMPORTED_MODULE_0___default()('.cookie').addClass('show');
                        js_cookie__WEBPACK_IMPORTED_MODULE_9___default.a.set('cookie', '1',  { expires: 7, path: '' })
                    }
                }, 1500)

                jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-close-open').on('click', function () {
                    jquery__WEBPACK_IMPORTED_MODULE_0___default.a.magnificPopup.close()

                    setTimeout(() => {
                        jquery__WEBPACK_IMPORTED_MODULE_0___default.a.magnificPopup.open({
                            mainClass: 'mfp-with-zoom',
                            items: {
                                src: '#popup-form', // can be a HTML string, jQuery object, or CSS selector
                                type: 'inline'
                            }
                        });
                    }, 100)
                })

                setTimeout(() => {
                    jquery__WEBPACK_IMPORTED_MODULE_0___default()('.whatsap').addClass('show');
                }, 30000)

                jquery__WEBPACK_IMPORTED_MODULE_0___default()('.whatsap__close').on('click', () => {
                    jquery__WEBPACK_IMPORTED_MODULE_0___default()('.whatsap').removeClass('show');jquery__WEBPACK_IMPORTED_MODULE_0___default.a
                })

                jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-close-cookie').on('click', () => {
                    jquery__WEBPACK_IMPORTED_MODULE_0___default()('.cookie').removeClass('show')
                })

                jquery__WEBPACK_IMPORTED_MODULE_0___default()('.drop-wrap').on('mouseover', (ev) => {
                    jquery__WEBPACK_IMPORTED_MODULE_0___default()(ev.currentTarget).find('.drop-menu').addClass('open')
                })

                jquery__WEBPACK_IMPORTED_MODULE_0___default()('.drop-wrap').on('mouseleave', (ev) => {
                    jquery__WEBPACK_IMPORTED_MODULE_0___default()(ev.currentTarget).find('.drop-menu').removeClass('open')
                })

                jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-send-form').each(function () {
                    jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).submit(function(e) {
                        e.preventDefault();
                        let form = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).serialize();
                        let phone = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).find('.js-input-mask')
                        let name = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).find('input[name="name"]')

                        if(phone.val().length < 16 || name.val().length < 3) {
                            if(phone.val().length < 16) {
                                phone.addClass('error')
                            } else{
                                phone.removeClass('error')
                            }

                            if(name.val().length < 3) {
                                name.addClass('error')
                            } else{
                                name.removeClass('error')
                            }

                        } else {
                            jquery__WEBPACK_IMPORTED_MODULE_0___default.a.ajax({
                                method: 'post',
                                url: '../uploads/senda.php',
                                data: form,
                                success: function(response) {
                                    // $(e.currentTarget).addClass('thank')
                                    name.removeClass('error')
                                    phone.removeClass('error')

                                    setTimeout(() => {
                                        window.location.href = '/thank.html'
                                    }, 500)
                                }
                            });
                        }
                    });
                })

                if(jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-select').length) {
                    jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-select').each((i, el) => {
                        jquery__WEBPACK_IMPORTED_MODULE_0___default()(el).select2()
                    })
                }


                if(jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-multi-label').length) {
                    jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-multi-label').each((i, el) => {
                        jquery__WEBPACK_IMPORTED_MODULE_0___default()(el).on('click', () => {
                            jquery__WEBPACK_IMPORTED_MODULE_0___default()(el).closest('.form__input').find('.js-select').select2('open')
                        })
                    })
                }


                jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-sale-item').each((i, el) => {
                    const $this = jquery__WEBPACK_IMPORTED_MODULE_0___default()(el);
                    const $popup = $this.find('.sale-popup')
                    const $popupCopy = $popup.clone();

                    $this.on('click', () => {
                        jquery__WEBPACK_IMPORTED_MODULE_0___default()('#popup-sale').html($popupCopy);

                        setTimeout(() => {
                            jquery__WEBPACK_IMPORTED_MODULE_0___default.a.magnificPopup.open({
                                mainClass: 'mfp-with-zoom',
                                items: {
                                    src: '#popup-sale', // can be a HTML string, jQuery object, or CSS selector
                                    type: 'inline'
                                }
                            });
                        }, 500)
                    })
                })


                jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-open-form').on('click', () => {

                    setTimeout(() => {
                        jquery__WEBPACK_IMPORTED_MODULE_0___default.a.magnificPopup.open({
                            mainClass: 'mfp-with-zoom',
                            items: {
                                src: '#popup-form', // can be a HTML string, jQuery object, or CSS selector
                                type: 'inline'
                            }
                        });
                    }, 500)
                })

                jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-abon-first').on('click', () => {

                    setTimeout(() => {
                        jquery__WEBPACK_IMPORTED_MODULE_0___default.a.magnificPopup.open({
                            mainClass: 'mfp-with-zoom',
                            items: {
                                src: '#popup-ban1', // can be a HTML string, jQuery object, or CSS selector
                                type: 'inline'
                            }
                        });
                    }, 500)
                })

                jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-abon-second').on('click', () => {

                    setTimeout(() => {
                        jquery__WEBPACK_IMPORTED_MODULE_0___default.a.magnificPopup.open({
                            mainClass: 'mfp-with-zoom',
                            items: {
                                src: '#popup-ban2', // can be a HTML string, jQuery object, or CSS selector
                                type: 'inline'
                            }
                        });
                    }, 500)
                })

                jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-dop1').on('click', () => {

                    setTimeout(() => {
                        jquery__WEBPACK_IMPORTED_MODULE_0___default.a.magnificPopup.open({
                            mainClass: 'mfp-with-zoom',
                            items: {
                                src: '#popup-ban2', // can be a HTML string, jQuery object, or CSS selector
                                type: 'inline'
                            }
                        });
                    }, 500)
                })

                jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-dop2').on('click', () => {

                    setTimeout(() => {
                        jquery__WEBPACK_IMPORTED_MODULE_0___default.a.magnificPopup.open({
                            mainClass: 'mfp-with-zoom',
                            items: {
                                src: '#popup-dop2', // can be a HTML string, jQuery object, or CSS selector
                                type: 'inline'
                            }
                        });
                    }, 500)
                })

                jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-tab-carousel').each((i, el) => {
                    let $id = jquery__WEBPACK_IMPORTED_MODULE_0___default()(el).data('tab');
                    jquery__WEBPACK_IMPORTED_MODULE_0___default()(el).on('click', () => {
                        jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-tab-carousel').removeClass('active');
                        jquery__WEBPACK_IMPORTED_MODULE_0___default()(el).addClass('active');
                        jquery__WEBPACK_IMPORTED_MODULE_0___default()('.products-block__sliders').addClass('hide');
                        jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-slider-block').removeClass('active');
                        jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-slider-block[data-tab="'+ $id +'"]').addClass('active');

                        setTimeout(() => {
                            jquery__WEBPACK_IMPORTED_MODULE_0___default()('.products-block__sliders').removeClass('hide');
                        }, 500)
                    });
                });

                jquery__WEBPACK_IMPORTED_MODULE_0___default()('.num-in button').on('click', function () {
                    let $input = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).parents('.num-block').find('input.in-num');
                    if(jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).hasClass('minus')) {
                        let count = parseFloat($input.val()) - 1;
                        count = count < 1 ? 1 : count;
                        if (count < 2) {
                            jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).addClass('dis');
                        }
                        else {
                            jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).removeClass('dis');
                        }
                        $input.val(count);
                    }
                    else {
                        let count = parseFloat($input.val()) + 1
                        $input.val(count);
                        if (count > 1) {
                            jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).parents('.num-block').find(('.minus')).removeClass('dis');
                        }
                    }
                    $input.change();
                    return false;
                })

                jquery__WEBPACK_IMPORTED_MODULE_0___default()('.tab-mob__triger').each(function () {
                    jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).on('click', function () {
                        jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).next('.tab-mob__list').toggleClass('show')
                    })
                })

                jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-tabTop-btn').each(function () {
                    let $this = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this);
                    let id = $this.data('id');

                    $this.on('click', () => {
                        if($this.hasClass('active') && !$this.hasClass('button--tab')) {
                            jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-tabTop-block').removeClass('active')
                            jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-tabTop-btn').removeClass('active')
                        } else {
                            jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-tabTop-block').removeClass('active')
                            jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-tabTop-btn').removeClass('active')
                            jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-tabTop-block[data-id="'+ id +'"]').addClass('active')
                            $this.addClass('active')
                        }

                    })
                })


                jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-tabBig-btn').each(function () {
                    let $this = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this);
                    let id = $this.data('id');

                    $this.on('click', () => {
                        if($this.hasClass('active') && !$this.hasClass('button--tab')) {
                            jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-tabBig-block').removeClass('active')
                            jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-tabBig-btn').removeClass('active')
                        } else {
                            jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-tabBig-btn').removeClass('active')

                            $this.addClass('active')
                            if(jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).closest('.tab-mob').length) {
                                jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).closest('.tab-mob').find('.tab-mob__triger span').text($this.text())
                                jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).closest('.tab-mob').find('.tab-mob__list').removeClass('show')
                                jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).closest('.js-tabTop-block').find('.js-tabBig-block').removeClass('active')
                                jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).closest('.js-tabTop-block').find('.js-tabBig-block[data-id="'+ id +'"]').addClass('active')
                            } else {
                                jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-tabBig-block').removeClass('active')
                                jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-tabBig-block[data-id="'+ id +'"]').addClass('active')
                            }
                        }

                    })
                })

                jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-tab-btn').each(function () {
                    let $this = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this);
                    let id = $this.data('id');

                    $this.on('click', () => {
                        if($this.hasClass('active') && !$this.hasClass('button--tab')) {
                            if($this.closest('.js-tabBig-block').length) {
                                $this.closest('.js-tabBig-block').find('.js-tab-block').removeClass('active')
                                $this.closest('.js-tabBig-block').find('.js-tab-btn').removeClass('active')
                            } else {
                                jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-tab-block').removeClass('active')
                                jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-tab-btn').removeClass('active')
                            }
                        } else {
                            if($this.closest('.js-tabBig-block').length) {
                                $this.closest('.js-tabBig-block').find('.js-tab-block').removeClass('active')
                                $this.closest('.js-tabBig-block').find('.js-tab-btn').removeClass('active')
                                jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-tab-block[data-id="'+ id +'"]').addClass('active')
                                $this.addClass('active')
                            } else {
                                jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-tab-block').removeClass('active')
                                jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-tab-btn').removeClass('active')
                                jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-tab-block[data-id="'+ id +'"]').addClass('active')
                                $this.addClass('active')
                            }

                        }

                    })
                })

                jquery__WEBPACK_IMPORTED_MODULE_0___default()('.popup-gallery').magnificPopup({
                    delegate: 'a',
                    type: 'image',
                    tLoading: 'Loading image #%curr%...',
                    mainClass: 'mfp-img-mobile',
                    gallery: {
                        enabled: true,
                        navigateByImgClick: true,
                        preload: [0,1] // Will preload 0 - before current, and 1 after the current image
                    },
                    image: {

                    }
                });

                if(jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).scrollTop() > 50  ){
                    jquery__WEBPACK_IMPORTED_MODULE_0___default()('.short-header').addClass('scroll')
                    jquery__WEBPACK_IMPORTED_MODULE_0___default()('.header').addClass('mini')
                    setTimeout(() => {
                        jquery__WEBPACK_IMPORTED_MODULE_0___default()('.header').addClass('show')
                    }, 300)
                } else {
                    jquery__WEBPACK_IMPORTED_MODULE_0___default()('.short-header').removeClass('scroll')
                    jquery__WEBPACK_IMPORTED_MODULE_0___default()('.header').removeClass('mini')
                    setTimeout(() => {
                        jquery__WEBPACK_IMPORTED_MODULE_0___default()('.header').removeClass('show')
                    }, 300)
                }

                jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).on('scroll', function () {
                    if(jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).scrollTop() > 50  ){
                        jquery__WEBPACK_IMPORTED_MODULE_0___default()('.short-header').addClass('scroll')
                        jquery__WEBPACK_IMPORTED_MODULE_0___default()('.header').addClass('mini')

                        setTimeout(() => {
                            jquery__WEBPACK_IMPORTED_MODULE_0___default()('.header').addClass('show')
                        }, 300)
                    } else {
                        jquery__WEBPACK_IMPORTED_MODULE_0___default()('.short-header').removeClass('scroll')
                        jquery__WEBPACK_IMPORTED_MODULE_0___default()('.header').removeClass('mini')

                        setTimeout(() => {
                            jquery__WEBPACK_IMPORTED_MODULE_0___default()('.header').removeClass('show')
                        }, 300)
                    }

                })

                if(jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-owl-carousel-items').length) {
                    jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-owl-carousel-items').each(function () {
                        let $index = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).closest('.slider-block').data('slider');
                        jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).owlCarousel({
                            lazyLoad: true,
                            lazyLoadEager: 1,
                            responsiveClass: true,
                            smartSpeed: 250,
                            autoWidth: false,
                            items: 2,
                            slideBy: 2,
                            loop: false,
                            nav: true,
                            margin: 15,
                            dots: false,
                            navText: [jquery__WEBPACK_IMPORTED_MODULE_0___default()('.nav-next[data-slider="'+ $index +'"]'),jquery__WEBPACK_IMPORTED_MODULE_0___default()('.nav-prev[data-slider="'+ $index +'"]')],
                            responsive : {
                                640 : {
                                    items: 3
                                },
                                920 : {
                                    items: 4
                                }
                            }
                        })
                    }).on('changed.owl.carousel', function(event) {
                        jquery__WEBPACK_IMPORTED_MODULE_0___default()("img.lazyload").Lazy({
                            afterLoad: function(element) {
                                element.addClass('load')
                            },
                            threshold: 50
                        });
                    })
                }

                if(jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-owl-carousel-items').length) {
                    jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-owl-carousel-items').each(function () {
                        let $index = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).closest('.slider-block').data('slider');
                        jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).owlCarousel({
                            lazyLoad: true,
                            lazyLoadEager: 1,
                            responsiveClass: true,
                            smartSpeed: 250,
                            autoWidth: false,
                            items: 2,
                            slideBy: 2,
                            loop: false,
                            nav: true,
                            margin: 15,
                            dots: false,
                            navText: [jquery__WEBPACK_IMPORTED_MODULE_0___default()('.nav-next[data-slider="'+ $index +'"]'),jquery__WEBPACK_IMPORTED_MODULE_0___default()('.nav-prev[data-slider="'+ $index +'"]')],
                            responsive : {
                                640 : {
                                    items: 3
                                },
                                920 : {
                                    items: 4
                                }
                            }
                        })
                    }).on('changed.owl.carousel', function(event) {
                        jquery__WEBPACK_IMPORTED_MODULE_0___default()("img.lazyload").Lazy({
                            afterLoad: function(element) {
                                element.addClass('load')
                            },
                            threshold: 50
                        });
                    })
                }

                if(jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-owl-carousel-prog').length) {

                    jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-owl-carousel-prog').each(function () {
                        let $index = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).data('slider');
                        jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).owlCarousel({
                            lazyLoad: true,
                            lazyLoadEager: 1,
                            responsiveClass: true,
                            smartSpeed: 250,
                            autoWidth: false,
                            items: 1,
                            slideBy: 1,
                            margin:20,
                            loop: false,
                            nav: true,
                            dots: true,
                            navText: [jquery__WEBPACK_IMPORTED_MODULE_0___default()('.nav-next[data-slider="'+ $index +'"]'),jquery__WEBPACK_IMPORTED_MODULE_0___default()('.nav-prev[data-slider="'+ $index +'"]')],
                            responsive : {
                                640 : {
                                    items: 3
                                },
                                920 : {
                                    items: 4
                                }
                            }
                        })
                    }).on('changed.owl.carousel', function(event) {
                        jquery__WEBPACK_IMPORTED_MODULE_0___default()("img.lazyload").Lazy({
                            afterLoad: function(element) {
                                element.addClass('load')
                            },
                            threshold: 50
                        });
                    })

                }

                if(jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-owl-carousel-pics').length) {
                    jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-owl-carousel-pics').each(function () {
                        let $index = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).closest('.slider-block').data('slider');
                        jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).owlCarousel({
                            lazyLoad: true,
                            lazyLoadEager: 1,
                            responsiveClass: true,
                            smartSpeed: 250,
                            autoWidth: false,
                            items: 2,
                            slideBy: 2,
                            loop: false,
                            nav: true,
                            margin: 10,
                            dots: false,
                            navText: [jquery__WEBPACK_IMPORTED_MODULE_0___default()('.nav-next[data-slider="'+ $index +'"]'),jquery__WEBPACK_IMPORTED_MODULE_0___default()('.nav-prev[data-slider="'+ $index +'"]')],
                            responsive : {
                                640 : {
                                    items: 3,
                                    margin: 30
                                }
                            }
                        })
                    }).on('changed.owl.carousel', function(event) {
                        jquery__WEBPACK_IMPORTED_MODULE_0___default()("img.lazyload").Lazy({
                            afterLoad: function(element) {
                                element.addClass('load')
                            },
                            threshold: 50
                        });
                    })

                }

                if(jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-owl-bide-gallery').length) {
                    jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-owl-bide-gallery').owlCarousel({
                        lazyLoad: true,
                        lazyLoadEager: 1,
                        center: true,
                        responsiveClass: true,
                        smartSpeed: 250,
                        autoWidth: false,
                        items: 1,
                        slideBy: 1,
                        loop: false,
                        nav: false,
                        dots: true,
                        autoplay: false
                    }).on('changed.owl.carousel', function(event) {
                        jquery__WEBPACK_IMPORTED_MODULE_0___default()("img.lazyload").Lazy({
                            afterLoad: function(element) {
                                element.addClass('load')
                            },
                            threshold: 50
                        });
                    })
                }


                if(jquery__WEBPACK_IMPORTED_MODULE_0___default()('.slider-for').length) {
                    var $carousel = jquery__WEBPACK_IMPORTED_MODULE_0___default()('.slider-for');

                    $carousel.slick({
                        slidesToShow: 1,
                        slidesToScroll: 1,
                        arrows: true,
                        fade: true,
                        adaptiveHeight: true,
                        asNavFor: '.slider-nav'
                    })

                    jquery__WEBPACK_IMPORTED_MODULE_0___default()('.slider-nav').slick({
                        slidesToShow: 5,
                        slidesToScroll: 1,
                        asNavFor: '.slider-for',
                        dots: false,
                        arrows: false,
                        centerMode: false,
                        focusOnSelect: true,
                        responsive: [
                            {
                                breakpoint: 1024,
                                settings: {
                                    slidesToShow: 4
                                }
                            },
                            {
                                breakpoint: 600,
                                settings: {
                                    slidesToShow: 3
                                }
                            }
                        ]
                    });
                }


                if(jquery__WEBPACK_IMPORTED_MODULE_0___default()('.slider-for-about').length) {
                    var $carouselAbout = jquery__WEBPACK_IMPORTED_MODULE_0___default()('.slider-for-about');

                    $carouselAbout.slick({
                        slidesToShow: 1,
                        slidesToScroll: 1,
                        fade: true,
                        arrows: false,
                        dots: true,
                        adaptiveHeight: true,
                        asNavFor: '.slider-nav-about'
                    })

                    jquery__WEBPACK_IMPORTED_MODULE_0___default()('.slider-nav-about').slick({
                        slidesToShow: 4,
                        slidesToScroll: 2,
                        asNavFor: '.slider-for-about',
                        dots: false,
                        arrows: false,
                        centerMode: false,
                        infinite: false,
                        focusOnSelect: true,
                        responsive: [
                            {
                                breakpoint: 1024,
                                settings: {
                                    slidesToShow: 4
                                }
                            },
                            {
                                breakpoint: 600,
                                settings: {
                                    slidesToShow: 4
                                }
                            }
                        ]
                    }).on("beforeChange", function (){
                        jquery__WEBPACK_IMPORTED_MODULE_0___default()("img.lazyload").Lazy({
                            afterLoad: function(element) {
                                element.addClass('load')
                            },
                            threshold: 50
                        });
                    });
                }

                const rangePrice = jquery__WEBPACK_IMPORTED_MODULE_0___default()("#range-slider");

                if(rangePrice.length) {
                    let from = jquery__WEBPACK_IMPORTED_MODULE_0___default()('.filter__from').data('from')
                    let to = jquery__WEBPACK_IMPORTED_MODULE_0___default()('.filter__to').data('to')
                    let max = jquery__WEBPACK_IMPORTED_MODULE_0___default()('.filter__price-inputs').data('max-value');

                    rangePrice.ionRangeSlider({
                        type: 'double',
                        skin: "big",
                        hide_min_max: true,
                        hide_from_to: true,
                        min: 0,
                        max: max,
                        from: from,
                        to: to
                    });

                    rangePrice.on("change", function () {
                        var $inp = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this);
                        var from = $inp.data("from");
                        var to = $inp.data("to");

                        jquery__WEBPACK_IMPORTED_MODULE_0___default()('.filter__from').val(from)
                        jquery__WEBPACK_IMPORTED_MODULE_0___default()('.filter__to').val(to)
                    });
                }


                // accordion

                jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-accordion-title').on('click', function () {
                    jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).next().slideToggle(200);
                    jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).parent().toggleClass('open', 200);
                });

                jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-accordion-body').each(function () {
                    if(jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).is(':visible')) {
                        jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).parent().addClass('open')
                    }
                });

                // showcountfilter
                let showCountFilter = function () {
                    if(jquery__WEBPACK_IMPORTED_MODULE_0___default()('.filter-block').find('.js-filter-check:checked').length > 0) {
                        jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-filter-shower').addClass('show');
                    } else {
                        jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-filter-shower').removeClass('show');
                    }
                }
                showCountFilter();
                let checker = jquery__WEBPACK_IMPORTED_MODULE_0___default()('.filter-block').find('.js-filter-check');
                checker.each(function () {
                    let $this = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this);

                    $this.on('change', () => {
                        showCountFilter();
                    })
                });

                //open filter

                jquery__WEBPACK_IMPORTED_MODULE_0___default()('.button--filter').on('click', () => {
                    jquery__WEBPACK_IMPORTED_MODULE_0___default()('.filter-block__form').addClass('show')
                })

                jquery__WEBPACK_IMPORTED_MODULE_0___default()('.filter-close').on('click', () => {
                    jquery__WEBPACK_IMPORTED_MODULE_0___default()('.filter-block__form').removeClass('show')
                })

                jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-open-menu').on('click', function () {
                    jquery__WEBPACK_IMPORTED_MODULE_0___default()('body').toggleClass('ohidden')
                    jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-mmenu').addClass('show')
                })

                jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-mmenu-hide').on('click', function () {
                    jquery__WEBPACK_IMPORTED_MODULE_0___default()('body').removeClass('ohidden')
                    jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-mmenu').removeClass('show')
                    jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-filter').removeClass('show')
                })

                let innerLink = jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-inner-link');
                let backLink = jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-inn-back');
                let wrap = jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-inner-wrap');
                let mainMenu = jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-main-menu');

                innerLink.each(function () {
                    let $this = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this);
                    let id = $this.data('id');

                    $this.on('click', function () {
                        jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-inn-menu').removeClass('show');
                        jquery__WEBPACK_IMPORTED_MODULE_0___default()('[data-menu="'+ id +'"]').addClass('show');
                        wrap.addClass('show');
                        mainMenu.addClass('hide');
                    })
                });

                backLink.each(function () {
                    jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).on('click', function () {
                        mainMenu.removeClass('hide');
                        if(jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).hasClass('js-inn-third')) {
                            jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).closest('.js-inn-menu').removeClass('show')
                            jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-inn-main').addClass('show')
                        } else {
                            wrap.removeClass('show');
                        }
                    });
                })

                jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-full-menu').on('click', () => {
                    jquery__WEBPACK_IMPORTED_MODULE_0___default()('.big-menu').show();
                    jquery__WEBPACK_IMPORTED_MODULE_0___default()('body').css('overflow', 'hidden')
                })

                jquery__WEBPACK_IMPORTED_MODULE_0___default()('.js-full-close').on('click', () => {
                    jquery__WEBPACK_IMPORTED_MODULE_0___default()('.big-menu').hide();
                    jquery__WEBPACK_IMPORTED_MODULE_0___default()('body').css('overflow', 'auto')
                })

                jquery__WEBPACK_IMPORTED_MODULE_0___default()('.open-lk').on('click', () => {
                    jquery__WEBPACK_IMPORTED_MODULE_0___default()('.reg-block__left').addClass('open')
                });

                jquery__WEBPACK_IMPORTED_MODULE_0___default()('.reg-block__close').on('click', () => {
                    jquery__WEBPACK_IMPORTED_MODULE_0___default()('.reg-block__left').removeClass('open')
                })

                jquery__WEBPACK_IMPORTED_MODULE_0___default()('.reg-block__menu').on('click', () => {
                    jquery__WEBPACK_IMPORTED_MODULE_0___default()('.reg-block__list').toggleClass('open')
                })

                function myFunction() {
                    var copyText = document.getElementById("myInput");

                    copyText.select();

                    document.execCommand("copy");

                    alert("Скопировано в буфер" + ' ' + copyText.value);
                }

                var btn = document.getElementById("btn");

                if(btn) {
                    btn.addEventListener('click', function () {
                        myFunction();
                    })
                }

                let inputFile = jquery__WEBPACK_IMPORTED_MODULE_0___default()('input[id="file"]');

                inputFile.on('change', function () {
                    var filename = inputFile.val().split('\\').pop();
                    jquery__WEBPACK_IMPORTED_MODULE_0___default()('.file-name').text(filename)
                })
            });



            /***/ }),

        /***/ "./src/scss/style.scss":
        /*!*****************************!*\
  !*** ./src/scss/style.scss ***!
  \*****************************/
        /*! no static exports found */
        /***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

            /***/ }),

        /***/ 0:
        /*!*****************************************************!*\
  !*** multi ./src/js/index.js ./src/scss/style.scss ***!
  \*****************************************************/
        /*! no static exports found */
        /***/ (function(module, exports, __webpack_require__) {

            __webpack_require__(/*! ./src/js/index.js */"./src/js/index.js");
            module.exports = __webpack_require__(/*! ./src/scss/style.scss */"./src/scss/style.scss");


            /***/ })

        /******/ });
//# sourceMappingURL=bundle.js.map
